{
  "version": "2.0",
  "deck": {
    "name": "Design Patterns",
    "description": "Common software design patterns for developers",
    "category": "Technical English",
    "tags": ["english", "programming", "design patterns", "OOP"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "design pattern",
      "pronunciation": "ดี-ไซน์-แพท-เทิร์น",
      "meaning": "รูปแบบการแก้ปัญหาที่ใช้ซ้ำได้",
      "example": "Design patterns provide reusable solutions.",
      "exampleTranslation": "Design pattern ให้วิธีแก้ปัญหาที่ใช้ซ้ำได้"
    },
    {
      "vocab": "creational pattern",
      "pronunciation": "ครี-เอ-ชัน-นัล-แพท-เทิร์น",
      "meaning": "pattern เกี่ยวกับการสร้าง object",
      "example": "Factory and Singleton are creational patterns.",
      "exampleTranslation": "Factory และ Singleton เป็น creational pattern"
    },
    {
      "vocab": "structural pattern",
      "pronunciation": "สตรัค-เชอ-รัล-แพท-เทิร์น",
      "meaning": "pattern เกี่ยวกับโครงสร้าง class",
      "example": "Adapter and Decorator are structural patterns.",
      "exampleTranslation": "Adapter และ Decorator เป็น structural pattern"
    },
    {
      "vocab": "behavioral pattern",
      "pronunciation": "บิ-เฮ-วี-เออ-รัล-แพท-เทิร์น",
      "meaning": "pattern เกี่ยวกับพฤติกรรม object",
      "example": "Observer and Strategy are behavioral patterns.",
      "exampleTranslation": "Observer และ Strategy เป็น behavioral pattern"
    },
    {
      "vocab": "Singleton",
      "pronunciation": "ซิง-เกิล-ทัน",
      "meaning": "pattern ที่มี instance เดียวทั้งระบบ",
      "example": "Use Singleton for database connections.",
      "exampleTranslation": "ใช้ Singleton สำหรับ database connection"
    },
    {
      "vocab": "Factory",
      "pronunciation": "แฟค-ทอ-รี่",
      "meaning": "pattern สร้าง object โดยไม่ระบุ class ตรงๆ",
      "example": "Factory creates objects without exposing creation logic.",
      "exampleTranslation": "Factory สร้าง object โดยไม่เปิดเผย logic การสร้าง"
    },
    {
      "vocab": "Factory Method",
      "pronunciation": "แฟค-ทอ-รี่-เม-ธอด",
      "meaning": "ให้ subclass ตัดสินใจว่าจะสร้าง object อะไร",
      "example": "Factory Method lets subclasses decide object type.",
      "exampleTranslation": "Factory Method ให้ subclass เลือกประเภท object"
    },
    {
      "vocab": "Abstract Factory",
      "pronunciation": "แอบ-สแทรค-แฟค-ทอ-รี่",
      "meaning": "สร้างกลุ่ม object ที่เกี่ยวข้องกัน",
      "example": "Abstract Factory creates families of related objects.",
      "exampleTranslation": "Abstract Factory สร้างกลุ่ม object ที่เกี่ยวข้อง"
    },
    {
      "vocab": "Builder",
      "pronunciation": "บิล-เดอะ",
      "meaning": "สร้าง object ทีละขั้นตอน",
      "example": "Builder constructs complex objects step by step.",
      "exampleTranslation": "Builder สร้าง object ซับซ้อนทีละขั้น"
    },
    {
      "vocab": "Prototype",
      "pronunciation": "โพร-โท-ไทพ์",
      "meaning": "สร้าง object ใหม่โดยการ clone",
      "example": "Prototype creates new objects by cloning.",
      "exampleTranslation": "Prototype สร้าง object ใหม่โดยการ clone"
    },
    {
      "vocab": "Adapter",
      "pronunciation": "อะ-แดป-เทอะ",
      "meaning": "แปลง interface ให้ใช้งานร่วมกันได้",
      "example": "Adapter converts one interface to another.",
      "exampleTranslation": "Adapter แปลง interface หนึ่งเป็นอีกอัน"
    },
    {
      "vocab": "Bridge",
      "pronunciation": "บริดจ์",
      "meaning": "แยก abstraction ออกจาก implementation",
      "example": "Bridge separates abstraction from implementation.",
      "exampleTranslation": "Bridge แยก abstraction จาก implementation"
    },
    {
      "vocab": "Composite",
      "pronunciation": "คอม-โพ-สิท",
      "meaning": "จัดการ object เดี่ยวและกลุ่มเหมือนกัน",
      "example": "Composite treats individual and group objects uniformly.",
      "exampleTranslation": "Composite จัดการ object เดี่ยวและกลุ่มเหมือนกัน"
    },
    {
      "vocab": "Decorator",
      "pronunciation": "เด-โค-เร-เทอะ",
      "meaning": "เพิ่มความสามารถให้ object แบบ dynamic",
      "example": "Decorator adds functionality without changing the class.",
      "exampleTranslation": "Decorator เพิ่มความสามารถโดยไม่แก้ class"
    },
    {
      "vocab": "Facade",
      "pronunciation": "ฟา-ซาด",
      "meaning": "ให้ interface ง่ายๆ สำหรับระบบซับซ้อน",
      "example": "Facade provides a simple interface to complex systems.",
      "exampleTranslation": "Facade ให้ interface ง่ายสำหรับระบบซับซ้อน"
    },
    {
      "vocab": "Flyweight",
      "pronunciation": "ฟลาย-เวท",
      "meaning": "แชร์ข้อมูลเพื่อประหยัดหน่วยความจำ",
      "example": "Flyweight shares data to minimize memory usage.",
      "exampleTranslation": "Flyweight แชร์ข้อมูลเพื่อลดการใช้หน่วยความจำ"
    },
    {
      "vocab": "Proxy",
      "pronunciation": "พร็อก-ซี่",
      "meaning": "ตัวแทนควบคุมการเข้าถึง object",
      "example": "Proxy controls access to another object.",
      "exampleTranslation": "Proxy ควบคุมการเข้าถึง object อื่น"
    },
    {
      "vocab": "Chain of Responsibility",
      "pronunciation": "เชน-ออฟ-ริส-พอน-ซิ-บิล-ลิ-ที่",
      "meaning": "ส่ง request ผ่านสายโซ่ handler",
      "example": "Chain of Responsibility passes requests along a chain.",
      "exampleTranslation": "Chain of Responsibility ส่ง request ผ่านสายโซ่"
    },
    {
      "vocab": "Command",
      "pronunciation": "คอม-มานด์",
      "meaning": "ห่อหุ้ม request เป็น object",
      "example": "Command encapsulates a request as an object.",
      "exampleTranslation": "Command ห่อหุ้ม request เป็น object"
    },
    {
      "vocab": "Iterator",
      "pronunciation": "อิท-เทอ-เร-เทอะ",
      "meaning": "เข้าถึง element ทีละตัวโดยไม่เปิดเผยโครงสร้าง",
      "example": "Iterator accesses elements sequentially.",
      "exampleTranslation": "Iterator เข้าถึง element ตามลำดับ"
    },
    {
      "vocab": "Mediator",
      "pronunciation": "มี-ดิ-เอ-เทอะ",
      "meaning": "ลดการ coupling โดยให้สื่อสารผ่านตัวกลาง",
      "example": "Mediator reduces direct communication between objects.",
      "exampleTranslation": "Mediator ลดการสื่อสารตรงระหว่าง object"
    },
    {
      "vocab": "Memento",
      "pronunciation": "เม-เมน-โท",
      "meaning": "บันทึกและคืนสถานะ object",
      "example": "Memento saves and restores object state.",
      "exampleTranslation": "Memento บันทึกและคืนสถานะ object"
    },
    {
      "vocab": "Observer",
      "pronunciation": "อ็อบ-เซอร์-เวอะ",
      "meaning": "แจ้งเตือน object อื่นเมื่อมีการเปลี่ยนแปลง",
      "example": "Observer notifies dependents of state changes.",
      "exampleTranslation": "Observer แจ้ง object ที่เกี่ยวข้องเมื่อ state เปลี่ยน"
    },
    {
      "vocab": "State",
      "pronunciation": "สเตท",
      "meaning": "เปลี่ยนพฤติกรรมตาม state ภายใน",
      "example": "State pattern changes behavior based on internal state.",
      "exampleTranslation": "State pattern เปลี่ยนพฤติกรรมตาม state ภายใน"
    },
    {
      "vocab": "Strategy",
      "pronunciation": "สแตร-ทิ-จี้",
      "meaning": "เลือก algorithm ได้ตอน runtime",
      "example": "Strategy allows switching algorithms at runtime.",
      "exampleTranslation": "Strategy ให้เปลี่ยน algorithm ตอน runtime ได้"
    },
    {
      "vocab": "Template Method",
      "pronunciation": "เทม-เพลท-เม-ธอด",
      "meaning": "กำหนดโครง algorithm ให้ subclass แก้บางส่วน",
      "example": "Template Method defines the skeleton of an algorithm.",
      "exampleTranslation": "Template Method กำหนดโครงของ algorithm"
    },
    {
      "vocab": "Visitor",
      "pronunciation": "วิ-ซิ-เทอะ",
      "meaning": "เพิ่ม operation ใหม่โดยไม่แก้ class",
      "example": "Visitor adds operations without modifying classes.",
      "exampleTranslation": "Visitor เพิ่ม operation โดยไม่แก้ class"
    },
    {
      "vocab": "Dependency Injection",
      "pronunciation": "ดี-เพน-เดน-ซี่-อิน-เจ็ค-ชั่น",
      "meaning": "ส่ง dependency เข้ามาแทนการสร้างเอง",
      "example": "DI makes code more testable.",
      "exampleTranslation": "DI ทำให้โค้ด test ง่ายขึ้น"
    },
    {
      "vocab": "Inversion of Control",
      "pronunciation": "อิน-เวอร์-ชั่น-ออฟ-คอน-โทรล",
      "meaning": "กลับความรับผิดชอบให้ framework จัดการ",
      "example": "IoC lets the framework control the flow.",
      "exampleTranslation": "IoC ให้ framework ควบคุม flow"
    },
    {
      "vocab": "Repository",
      "pronunciation": "รี-พอ-ซิ-ทอ-รี่",
      "meaning": "pattern แยกการเข้าถึงข้อมูลออกจาก logic",
      "example": "Repository pattern abstracts data access.",
      "exampleTranslation": "Repository pattern แยกการเข้าถึงข้อมูล"
    },
    {
      "vocab": "MVC",
      "pronunciation": "เอ็ม-วี-ซี",
      "meaning": "Model-View-Controller แยก 3 ส่วน",
      "example": "MVC separates data, UI, and logic.",
      "exampleTranslation": "MVC แยกข้อมูล, UI และ logic"
    },
    {
      "vocab": "MVP",
      "pronunciation": "เอ็ม-วี-พี",
      "meaning": "Model-View-Presenter",
      "example": "MVP has a Presenter that handles all logic.",
      "exampleTranslation": "MVP มี Presenter จัดการ logic ทั้งหมด"
    },
    {
      "vocab": "MVVM",
      "pronunciation": "เอ็ม-วี-วี-เอ็ม",
      "meaning": "Model-View-ViewModel",
      "example": "MVVM uses data binding between View and ViewModel.",
      "exampleTranslation": "MVVM ใช้ data binding ระหว่าง View กับ ViewModel"
    },
    {
      "vocab": "Clean Architecture",
      "pronunciation": "คลีน-อาร์-คิ-เท็ค-เชอะ",
      "meaning": "แยกชั้นให้ business logic ไม่ขึ้นกับ framework",
      "example": "Clean Architecture separates concerns into layers.",
      "exampleTranslation": "Clean Architecture แยก concern เป็นชั้น"
    },
    {
      "vocab": "Domain-Driven Design",
      "pronunciation": "โด-เมน-ดริฟ-เวน-ดี-ไซน์",
      "meaning": "ออกแบบโดยเน้น business domain",
      "example": "DDD focuses on the core business domain.",
      "exampleTranslation": "DDD เน้นที่ business domain หลัก"
    },
    {
      "vocab": "Event Sourcing",
      "pronunciation": "อี-เวนท์-ซอร์-ซิง",
      "meaning": "เก็บ state เป็นลำดับ event",
      "example": "Event Sourcing stores all changes as events.",
      "exampleTranslation": "Event Sourcing เก็บทุกการเปลี่ยนแปลงเป็น event"
    },
    {
      "vocab": "CQRS",
      "pronunciation": "ซี-คิว-อาร์-เอส",
      "meaning": "แยก read และ write เป็นคนละ model",
      "example": "CQRS separates read and write operations.",
      "exampleTranslation": "CQRS แยกการ read และ write"
    },
    {
      "vocab": "Saga",
      "pronunciation": "ซา-ก้า",
      "meaning": "จัดการ transaction ข้าม service",
      "example": "Saga pattern manages distributed transactions.",
      "exampleTranslation": "Saga pattern จัดการ distributed transaction"
    },
    {
      "vocab": "Circuit Breaker",
      "pronunciation": "เซอร์-คิท-เบรค-เกอะ",
      "meaning": "หยุดเรียก service ที่ล้มเหลวชั่วคราว",
      "example": "Circuit Breaker prevents cascading failures.",
      "exampleTranslation": "Circuit Breaker ป้องกันความล้มเหลวลามไป"
    },
    {
      "vocab": "Retry Pattern",
      "pronunciation": "รี-ทราย-แพท-เทิร์น",
      "meaning": "ลองใหม่เมื่อ request ล้มเหลว",
      "example": "Retry pattern handles transient failures.",
      "exampleTranslation": "Retry pattern จัดการความล้มเหลวชั่วคราว"
    },
    {
      "vocab": "Bulkhead",
      "pronunciation": "บัลค์-เฮด",
      "meaning": "แยกส่วนเพื่อจำกัดความเสียหาย",
      "example": "Bulkhead pattern isolates failures.",
      "exampleTranslation": "Bulkhead pattern แยกส่วนที่ล้มเหลว"
    },
    {
      "vocab": "Service Locator",
      "pronunciation": "เซอร์-วิส-โล-เค-เทอะ",
      "meaning": "registry กลางสำหรับหา service",
      "example": "Service Locator finds dependencies at runtime.",
      "exampleTranslation": "Service Locator หา dependency ตอน runtime"
    },
    {
      "vocab": "Null Object",
      "pronunciation": "นัล-อ็อบ-เจ็คท์",
      "meaning": "object ที่ไม่ทำอะไรแทนการ return null",
      "example": "Null Object avoids null checks.",
      "exampleTranslation": "Null Object หลีกเลี่ยงการเช็ค null"
    },
    {
      "vocab": "Object Pool",
      "pronunciation": "อ็อบ-เจ็คท์-พูล",
      "meaning": "เก็บ object ไว้ใช้ซ้ำ",
      "example": "Object Pool reuses expensive objects.",
      "exampleTranslation": "Object Pool ใช้ object ที่สร้างแพงซ้ำ"
    },
    {
      "vocab": "Lazy Initialization",
      "pronunciation": "เล-ซี่-อิ-นิ-เชียล-ไล-เซ-ชั่น",
      "meaning": "สร้าง object เมื่อต้องใช้จริงเท่านั้น",
      "example": "Lazy Initialization delays object creation.",
      "exampleTranslation": "Lazy Initialization เลื่อนการสร้าง object"
    },
    {
      "vocab": "coupling",
      "pronunciation": "คัพ-พลิง",
      "meaning": "ความผูกพันระหว่าง module",
      "example": "Loose coupling makes code easier to change.",
      "exampleTranslation": "Loose coupling ทำให้โค้ดแก้ไขง่าย"
    },
    {
      "vocab": "cohesion",
      "pronunciation": "โค-ฮี-ชั่น",
      "meaning": "ความเกี่ยวข้องกันภายใน module",
      "example": "High cohesion means related code stays together.",
      "exampleTranslation": "High cohesion หมายถึงโค้ดที่เกี่ยวข้องอยู่ด้วยกัน"
    },
    {
      "vocab": "separation of concerns",
      "pronunciation": "เซ-พา-เร-ชั่น-ออฟ-คอน-เซิร์นส",
      "meaning": "แยกความรับผิดชอบแต่ละส่วน",
      "example": "Separation of concerns improves maintainability.",
      "exampleTranslation": "การแยก concern ช่วยให้ maintain ง่ายขึ้น"
    },
    {
      "vocab": "single responsibility",
      "pronunciation": "ซิง-เกิล-ริส-พอน-ซิ-บิล-ลิ-ที่",
      "meaning": "แต่ละ class มีหน้าที่เดียว",
      "example": "Single responsibility keeps classes focused.",
      "exampleTranslation": "Single responsibility ทำให้ class โฟกัส"
    },
    {
      "vocab": "open-closed principle",
      "pronunciation": "โอ-เพน-โคลสด์-พริน-ซิ-เพิล",
      "meaning": "เปิดให้ขยาย ปิดไม่ให้แก้",
      "example": "Open-closed: extend, don't modify.",
      "exampleTranslation": "Open-closed: ขยายได้ แต่อย่าแก้"
    },
    {
      "vocab": "Liskov substitution",
      "pronunciation": "ลิส-คอฟ-ซับ-สติ-ทู-ชั่น",
      "meaning": "subclass แทนที่ parent ได้โดยไม่พัง",
      "example": "Liskov: subclasses must be substitutable.",
      "exampleTranslation": "Liskov: subclass ต้องแทนที่ได้"
    },
    {
      "vocab": "interface segregation",
      "pronunciation": "อิน-เทอะ-เฟซ-เซก-ริ-เก-ชั่น",
      "meaning": "แยก interface เล็กๆ แทน interface ใหญ่",
      "example": "Interface segregation: many small interfaces.",
      "exampleTranslation": "Interface segregation: หลาย interface เล็ก"
    },
    {
      "vocab": "dependency inversion",
      "pronunciation": "ดี-เพน-เดน-ซี่-อิน-เวอร์-ชั่น",
      "meaning": "ขึ้นกับ abstraction ไม่ใช่ concrete",
      "example": "Depend on abstractions, not concretions.",
      "exampleTranslation": "ขึ้นกับ abstraction ไม่ใช่ concrete class"
    }
  ]
}
