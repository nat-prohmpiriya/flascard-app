{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "Next.js 16 Concepts",
    "description": "Core Next.js 16 concepts including App Router, Server Components, caching, Server Actions, and modern features",
    "category": "Programming",
    "tags": ["nextjs", "react", "frontend", "fullstack", "app-router"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is Next.js and why use it?",
      "pronunciation": "// Next.js: React framework by Vercel\n// Full-stack framework with:\n// - File-based routing\n// - Server-side rendering (SSR)\n// - Static site generation (SSG)\n// - API routes\n// - Built-in optimizations\n\n// Create new project\nnpx create-next-app@latest my-app\n\n// Project structure (App Router)\napp/\n├── layout.tsx      // Root layout\n├── page.tsx        // Home page (/)\n├── globals.css     // Global styles\n├── about/\n│   └── page.tsx    // About page (/about)\n└── api/\n    └── route.ts    // API endpoint\n\n// Start development\nnpm run dev         // http://localhost:3000\nnpm run build       // Production build\nnpm run start       // Start production\n\n// Key features:\n// - React Server Components (default)\n// - Automatic code splitting\n// - Image, Font, Script optimization\n// - Middleware\n// - Turbopack (fast bundler)",
      "meaning": "Next.js คืออะไรและทำไมต้องใช้?",
      "example": "Next.js is a React framework for production. Provides: file-based routing, SSR/SSG/ISR, API routes, automatic optimization. App Router (default) uses React Server Components. Benefits: SEO-friendly, fast performance, full-stack capabilities, great DX. Used by major companies. Turbopack for faster dev builds.",
      "exampleTranslation": "Next.js คือ React framework สำหรับ production ให้: file-based routing, SSR/SSG/ISR, API routes, automatic optimization App Router (default) ใช้ React Server Components ข้อดี: SEO-friendly, performance เร็ว, full-stack capabilities, DX ดี ใช้โดย major companies Turbopack สำหรับ dev builds เร็วขึ้น"
    },
    {
      "vocab": "What is App Router vs Pages Router?",
      "pronunciation": "// App Router (recommended, Next.js 13+)\napp/\n├── layout.tsx        // Shared layout\n├── page.tsx          // Route segment\n├── loading.tsx       // Loading UI\n├── error.tsx         // Error UI\n├── not-found.tsx     // 404 UI\n└── dashboard/\n    ├── layout.tsx    // Nested layout\n    └── page.tsx      // /dashboard\n\n// Pages Router (legacy)\npages/\n├── _app.tsx          // Custom App\n├── _document.tsx     // Custom Document\n├── index.tsx         // Home (/)\n├── about.tsx         // /about\n└── api/\n    └── hello.ts      // /api/hello\n\n// App Router benefits:\n// - React Server Components (default)\n// - Nested layouts\n// - Loading/Error UI per route\n// - Streaming\n// - Server Actions\n// - Parallel & Intercepting routes\n\n// Pages Router:\n// - Still supported\n// - getServerSideProps, getStaticProps\n// - Can coexist with App Router\n\n// Migration: gradual adoption possible\n// Start new features in app/, keep pages/",
      "meaning": "App Router vs Pages Router คืออะไร?",
      "example": "App Router (app/) is the modern approach with Server Components, nested layouts, streaming, Server Actions. Pages Router (pages/) is legacy with getServerSideProps/getStaticProps. App Router benefits: better performance, simpler data fetching, granular loading states. Both can coexist for gradual migration. Use App Router for new projects.",
      "exampleTranslation": "App Router (app/) คือ approach สมัยใหม่กับ Server Components, nested layouts, streaming, Server Actions Pages Router (pages/) เป็น legacy กับ getServerSideProps/getStaticProps App Router ข้อดี: performance ดีกว่า, data fetching ง่ายกว่า, granular loading states ทั้งคู่อยู่ร่วมกันได้สำหรับ gradual migration ใช้ App Router สำหรับ projects ใหม่"
    },
    {
      "vocab": "How does file-based routing work?",
      "pronunciation": "// File structure = URL routes\napp/\n├── page.tsx              // /\n├── about/\n│   └── page.tsx          // /about\n├── blog/\n│   ├── page.tsx          // /blog\n│   └── [slug]/\n│       └── page.tsx      // /blog/:slug (dynamic)\n├── shop/\n│   └── [...slug]/\n│       └── page.tsx      // /shop/* (catch-all)\n├── docs/\n│   └── [[...slug]]/\n│       └── page.tsx      // /docs or /docs/* (optional catch-all)\n└── (marketing)/          // Route group (no URL impact)\n    ├── about/\n    └── contact/\n\n// Special files:\n// page.tsx      - UI for route (required for route to be accessible)\n// layout.tsx    - Shared UI for segment and children\n// loading.tsx   - Loading UI (Suspense wrapper)\n// error.tsx     - Error UI (Error Boundary)\n// not-found.tsx - 404 UI\n// route.ts      - API endpoint\n// template.tsx  - Like layout but remounts\n\n// Dynamic segments\n// [id]          - Single dynamic segment\n// [...slug]     - Catch-all segments\n// [[...slug]]   - Optional catch-all",
      "meaning": "File-based routing ทำงานอย่างไร?",
      "example": "Folder structure defines URL routes. page.tsx makes route accessible. Special files: layout.tsx (shared UI), loading.tsx (loading state), error.tsx (error boundary), not-found.tsx (404). Dynamic routes: [param] single, [...slug] catch-all, [[...slug]] optional catch-all. Route groups (folder) don't affect URL. No manual route configuration needed.",
      "exampleTranslation": "Folder structure กำหนด URL routes page.tsx ทำให้ route accessible Special files: layout.tsx (shared UI), loading.tsx (loading state), error.tsx (error boundary), not-found.tsx (404) Dynamic routes: [param] single, [...slug] catch-all, [[...slug]] optional catch-all Route groups (folder) ไม่กระทบ URL ไม่ต้อง manual route configuration"
    },
    {
      "vocab": "What are Layouts and Templates?",
      "pronunciation": "// layout.tsx: Shared UI, preserves state\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <nav>Navigation</nav>\n        <main>{children}</main>\n        <footer>Footer</footer>\n      </body>\n    </html>\n  );\n}\n\n// Nested layout\n// app/dashboard/layout.tsx\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <div className=\"dashboard\">\n      <Sidebar />\n      <div>{children}</div>\n    </div>\n  );\n}\n\n// template.tsx: Like layout but remounts on navigation\n// Use when you need:\n// - Enter/exit animations\n// - useEffect on every navigation\n// - Reset state on navigation\n\nexport default function Template({ children }) {\n  return <div className=\"animate-in\">{children}</div>;\n}\n\n// Root layout is required\n// Must include <html> and <body>\n// Layouts don't re-render on navigation\n// Templates re-render on every navigation",
      "meaning": "Layouts และ Templates คืออะไร?",
      "example": "Layouts wrap pages and preserve state across navigations. Root layout required with <html><body>. Nested layouts for sections (dashboard, admin). Templates are like layouts but remount on navigation - use for animations or resetting state. Layouts don't re-render, templates do. Both receive children prop.",
      "exampleTranslation": "Layouts wrap pages และรักษา state ข้าม navigations Root layout จำเป็นกับ <html><body> Nested layouts สำหรับ sections (dashboard, admin) Templates เหมือน layouts แต่ remount เมื่อ navigation - ใช้สำหรับ animations หรือ resetting state Layouts ไม่ re-render, templates re-render ทั้งคู่รับ children prop"
    },
    {
      "vocab": "What are Server Components vs Client Components?",
      "pronunciation": "// Server Component (default in App Router)\n// app/page.tsx\nasync function ServerPage() {\n  // Can use async/await directly\n  const data = await fetch('https://api.example.com/data');\n  const posts = await data.json();\n\n  // Can access server-only resources\n  const secret = process.env.API_SECRET;\n\n  return (\n    <div>\n      {posts.map(post => <h2 key={post.id}>{post.title}</h2>)}\n    </div>\n  );\n}\n\n// Client Component\n// app/components/Counter.tsx\n'use client';  // ← This directive makes it client\n\nimport { useState } from 'react';\n\nexport function Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <button onClick={() => setCount(c => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}\n\n// Server can import Client, not vice versa\n// app/page.tsx\nimport { Counter } from './components/Counter';\n\nexport default async function Page() {\n  const data = await fetchData();  // Server\n  return (\n    <div>\n      <h1>{data.title}</h1>  {/* Server */}\n      <Counter />             {/* Client island */}\n    </div>\n  );\n}",
      "meaning": "Server Components vs Client Components คืออะไร?",
      "example": "Server Components (default): render on server, zero client JS, can use async/await, access databases/secrets directly. Client Components: add 'use client' directive, use for interactivity, hooks, browser APIs. Server imports Client, not vice versa. Client Components are 'islands' of interactivity. Smaller bundles with Server Components.",
      "exampleTranslation": "Server Components (default): render บน server, ไม่มี client JS, ใช้ async/await ได้, เข้าถึง databases/secrets โดยตรง Client Components: เพิ่ม 'use client' directive, ใช้สำหรับ interactivity, hooks, browser APIs Server import Client ไม่ใช่กลับกัน Client Components เป็น 'islands' ของ interactivity Bundles เล็กลงกับ Server Components"
    },
    {
      "vocab": "How does data fetching work in App Router?",
      "pronunciation": "// Server Component: fetch directly\nasync function Page() {\n  // Cached by default (similar to SSG)\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n  return <div>{data.title}</div>;\n}\n\n// Caching options\n// Static (cached forever until revalidate)\nfetch(url, { cache: 'force-cache' });  // default\n\n// Dynamic (no cache, like SSR)\nfetch(url, { cache: 'no-store' });\n\n// Revalidate (ISR)\nfetch(url, { next: { revalidate: 60 } });  // 60 seconds\n\n// Tags for on-demand revalidation\nfetch(url, { next: { tags: ['posts'] } });\n// Later: revalidateTag('posts')\n\n// Parallel fetching\nasync function Page() {\n  // Start both requests simultaneously\n  const postsPromise = fetchPosts();\n  const userPromise = fetchUser();\n  \n  const [posts, user] = await Promise.all([\n    postsPromise,\n    userPromise,\n  ]);\n  \n  return <div>...</div>;\n}\n\n// Using ORM/Database directly\nimport { db } from '@/lib/db';\n\nasync function Page() {\n  const posts = await db.post.findMany();  // Direct DB access\n  return <PostList posts={posts} />;\n}",
      "meaning": "Data fetching ทำงานอย่างไรใน App Router?",
      "example": "In Server Components, fetch directly with async/await. Default: cached (like SSG). cache: 'no-store' for dynamic (SSR). next: { revalidate: 60 } for ISR. Use tags for on-demand revalidation. Parallel fetch with Promise.all. Can access database/ORM directly. No getServerSideProps/getStaticProps needed.",
      "exampleTranslation": "ใน Server Components fetch โดยตรงด้วย async/await Default: cached (เหมือน SSG) cache: 'no-store' สำหรับ dynamic (SSR) next: { revalidate: 60 } สำหรับ ISR ใช้ tags สำหรับ on-demand revalidation Parallel fetch ด้วย Promise.all เข้าถึง database/ORM โดยตรงได้ ไม่ต้อง getServerSideProps/getStaticProps"
    },
    {
      "vocab": "What are Server Actions?",
      "pronunciation": "// Server Action: async function that runs on server\n// app/actions.ts\n'use server';\n\nimport { revalidatePath } from 'next/cache';\nimport { redirect } from 'next/navigation';\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get('title') as string;\n  const content = formData.get('content') as string;\n\n  // Validate\n  if (!title) {\n    return { error: 'Title is required' };\n  }\n\n  // Save to database\n  await db.post.create({ data: { title, content } });\n\n  // Revalidate and redirect\n  revalidatePath('/posts');\n  redirect('/posts');\n}\n\n// Use in form\n// app/posts/new/page.tsx\nimport { createPost } from '@/app/actions';\n\nexport default function NewPost() {\n  return (\n    <form action={createPost}>\n      <input name=\"title\" required />\n      <textarea name=\"content\" />\n      <button type=\"submit\">Create</button>\n    </form>\n  );\n}\n\n// Use with useActionState (React 19)\n'use client';\nimport { useActionState } from 'react';\n\nfunction Form() {\n  const [state, action, pending] = useActionState(createPost, null);\n  return (\n    <form action={action}>\n      <button disabled={pending}>Submit</button>\n      {state?.error && <p>{state.error}</p>}\n    </form>\n  );\n}",
      "meaning": "Server Actions คืออะไร?",
      "example": "Server Actions are async functions running on server, callable from client. Mark with 'use server'. Use in form action attribute - works without JavaScript (progressive enhancement). Can validate, save to database, revalidate cache, redirect. useActionState for pending/error states. Replace API routes for mutations. Secure by default.",
      "exampleTranslation": "Server Actions เป็น async functions ที่รันบน server เรียกจาก client ได้ Mark ด้วย 'use server' ใช้ใน form action attribute - ทำงานโดยไม่มี JavaScript (progressive enhancement) Validate, save to database, revalidate cache, redirect ได้ useActionState สำหรับ pending/error states แทนที่ API routes สำหรับ mutations Secure by default"
    },
    {
      "vocab": "How to handle loading states?",
      "pronunciation": "// loading.tsx: automatic Suspense boundary\n// app/dashboard/loading.tsx\nexport default function Loading() {\n  return <div>Loading dashboard...</div>;\n}\n\n// Skeleton loader\nexport default function Loading() {\n  return (\n    <div className=\"animate-pulse\">\n      <div className=\"h-4 bg-gray-200 rounded w-3/4\" />\n      <div className=\"h-4 bg-gray-200 rounded w-1/2 mt-2\" />\n    </div>\n  );\n}\n\n// Manual Suspense for granular control\nimport { Suspense } from 'react';\n\nasync function Page() {\n  return (\n    <div>\n      <h1>Dashboard</h1>  {/* Renders immediately */}\n      \n      <Suspense fallback={<ChartSkeleton />}>\n        <ChartSection />  {/* Streams when ready */}\n      </Suspense>\n      \n      <Suspense fallback={<TableSkeleton />}>\n        <DataTable />     {/* Streams independently */}\n      </Suspense>\n    </div>\n  );\n}\n\n// Streaming: page shells render first\n// Heavy components stream in as ready\n// User sees content progressively\n\n// loading.tsx wraps page.tsx in Suspense automatically\n// Nested loading.tsx for nested routes",
      "meaning": "วิธีจัดการ loading states ทำอย่างไร?",
      "example": "loading.tsx creates automatic Suspense boundary for route. Shows while page.tsx loads. Use skeleton loaders for better UX. Manual Suspense for granular control - different loading states for different sections. Streaming: shell renders immediately, heavy components stream in progressively. Nested loading.tsx for nested routes.",
      "exampleTranslation": "loading.tsx สร้าง automatic Suspense boundary สำหรับ route แสดงขณะ page.tsx โหลด ใช้ skeleton loaders สำหรับ UX ที่ดีกว่า Manual Suspense สำหรับ granular control - loading states ต่างกันสำหรับ sections ต่างกัน Streaming: shell render ทันที, heavy components stream เข้ามาทีละส่วน Nested loading.tsx สำหรับ nested routes"
    },
    {
      "vocab": "How to handle errors?",
      "pronunciation": "// error.tsx: Error boundary for route\n// app/dashboard/error.tsx\n'use client';  // Must be client component\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <p>{error.message}</p>\n      <button onClick={() => reset()}>Try again</button>\n    </div>\n  );\n}\n\n// global-error.tsx: Catches root layout errors\n// app/global-error.tsx\n'use client';\n\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error;\n  reset: () => void;\n}) {\n  return (\n    <html>\n      <body>\n        <h2>Something went wrong!</h2>\n        <button onClick={() => reset()}>Try again</button>\n      </body>\n    </html>\n  );\n}\n\n// not-found.tsx: 404 page\n// app/not-found.tsx\nexport default function NotFound() {\n  return (\n    <div>\n      <h2>Not Found</h2>\n      <p>Could not find requested resource</p>\n    </div>\n  );\n}\n\n// Trigger 404 programmatically\nimport { notFound } from 'next/navigation';\n\nasync function Page({ params }) {\n  const post = await getPost(params.id);\n  if (!post) notFound();\n  return <div>{post.title}</div>;\n}",
      "meaning": "วิธีจัดการ errors ทำอย่างไร?",
      "example": "error.tsx creates Error Boundary for route segment. Must be 'use client'. Receives error and reset function. global-error.tsx for root layout errors (must include html/body). not-found.tsx for 404 pages. notFound() triggers 404 programmatically. Errors bubble up to nearest error.tsx. Each route can have own error handling.",
      "exampleTranslation": "error.tsx สร้าง Error Boundary สำหรับ route segment ต้องเป็น 'use client' รับ error และ reset function global-error.tsx สำหรับ root layout errors (ต้องมี html/body) not-found.tsx สำหรับ 404 pages notFound() trigger 404 โดย programmatic Errors bubble up ไปยัง error.tsx ที่ใกล้ที่สุด แต่ละ route มี error handling ของตัวเองได้"
    },
    {
      "vocab": "What are Route Groups?",
      "pronunciation": "// Route Group: organize without affecting URL\napp/\n├── (marketing)/         // Group name in parentheses\n│   ├── layout.tsx       // Shared marketing layout\n│   ├── about/\n│   │   └── page.tsx     // /about (not /marketing/about)\n│   └── contact/\n│       └── page.tsx     // /contact\n├── (shop)/\n│   ├── layout.tsx       // Different layout\n│   ├── products/\n│   │   └── page.tsx     // /products\n│   └── cart/\n│       └── page.tsx     // /cart\n└── (auth)/\n    ├── layout.tsx       // Auth layout (no nav)\n    ├── login/\n    │   └── page.tsx     // /login\n    └── register/\n        └── page.tsx     // /register\n\n// Use cases:\n// 1. Organize routes by feature/team\n// 2. Different layouts for sections\n// 3. Multiple root layouts\n\n// Multiple root layouts\napp/\n├── (marketing)/\n│   └── layout.tsx       // Marketing root layout\n└── (app)/\n    └── layout.tsx       // App root layout\n\n// Note: Each layout needs <html><body>",
      "meaning": "Route Groups คืออะไร?",
      "example": "Route Groups use (folderName) syntax to organize routes without affecting URL path. Group name not included in URL. Use cases: organize by feature/team, apply different layouts to sections, create multiple root layouts. Each group can have own layout.tsx. Great for separating marketing site from app, or public from authenticated routes.",
      "exampleTranslation": "Route Groups ใช้ (folderName) syntax เพื่อจัดระเบียบ routes โดยไม่กระทบ URL path ชื่อ group ไม่รวมใน URL Use cases: จัดระเบียบตาม feature/team, apply layouts ต่างกันให้ sections, สร้าง multiple root layouts แต่ละ group มี layout.tsx ของตัวเองได้ ดีสำหรับแยก marketing site จาก app หรือ public จาก authenticated routes"
    },
    {
      "vocab": "What are Dynamic Routes?",
      "pronunciation": "// Dynamic segment: [param]\n// app/blog/[slug]/page.tsx\nexport default async function BlogPost({\n  params,\n}: {\n  params: Promise<{ slug: string }>;\n}) {\n  const { slug } = await params;\n  const post = await getPost(slug);\n  return <article>{post.content}</article>;\n}\n\n// Multiple dynamic segments\n// app/blog/[category]/[slug]/page.tsx\n// URL: /blog/tech/hello-world\n// params: { category: 'tech', slug: 'hello-world' }\n\n// Catch-all segments: [...slug]\n// app/docs/[...slug]/page.tsx\n// /docs/a → { slug: ['a'] }\n// /docs/a/b/c → { slug: ['a', 'b', 'c'] }\n\n// Optional catch-all: [[...slug]]\n// app/docs/[[...slug]]/page.tsx\n// /docs → { slug: undefined }\n// /docs/a → { slug: ['a'] }\n\n// Generate static params (SSG)\nexport async function generateStaticParams() {\n  const posts = await getPosts();\n  return posts.map((post) => ({\n    slug: post.slug,\n  }));\n}\n\n// With dynamic segments\n// Returns: [{ slug: 'post-1' }, { slug: 'post-2' }]\n// These paths are pre-rendered at build time",
      "meaning": "Dynamic Routes คืออะไร?",
      "example": "Dynamic routes use brackets for variable segments. [param] for single segment, [...slug] for catch-all, [[...slug]] for optional catch-all. Access via params prop (Promise in Next.js 15+). generateStaticParams for SSG - returns array of param objects to pre-render. Combine with revalidate for ISR behavior.",
      "exampleTranslation": "Dynamic routes ใช้ brackets สำหรับ variable segments [param] สำหรับ single segment, [...slug] สำหรับ catch-all, [[...slug]] สำหรับ optional catch-all เข้าถึงผ่าน params prop (Promise ใน Next.js 15+) generateStaticParams สำหรับ SSG - return array ของ param objects เพื่อ pre-render รวมกับ revalidate สำหรับ ISR behavior"
    },
    {
      "vocab": "What are Parallel Routes?",
      "pronunciation": "// Parallel Routes: render multiple pages simultaneously\n// Use @folder naming convention\n\napp/\n├── layout.tsx\n├── page.tsx\n└── @modal/              // Slot named 'modal'\n│   ├── default.tsx      // Default when not active\n│   └── login/\n│       └── page.tsx     // /login renders in modal slot\n├── @sidebar/            // Slot named 'sidebar'\n│   └── page.tsx\n└── dashboard/\n    └── page.tsx\n\n// Layout receives slots as props\n// app/layout.tsx\nexport default function Layout({\n  children,\n  modal,\n  sidebar,\n}: {\n  children: React.ReactNode;\n  modal: React.ReactNode;\n  sidebar: React.ReactNode;\n}) {\n  return (\n    <div>\n      <div className=\"sidebar\">{sidebar}</div>\n      <main>{children}</main>\n      {modal}  {/* Modal overlay */}\n    </div>\n  );\n}\n\n// default.tsx: shown when slot doesn't match current URL\n// Required for unmatched parallel routes\n\n// Use cases:\n// - Modals (URL-addressable)\n// - Dashboards with independent sections\n// - Split views\n// - Conditional rendering by user type",
      "meaning": "Parallel Routes คืออะไร?",
      "example": "Parallel Routes render multiple pages simultaneously using @folder slots. Layout receives slots as props alongside children. Each slot can have independent loading/error states. default.tsx for unmatched routes. Use cases: modals with URL, dashboards, split views. Slots render in parallel, not sequentially. Great for complex layouts.",
      "exampleTranslation": "Parallel Routes render หลาย pages พร้อมกันโดยใช้ @folder slots Layout รับ slots เป็น props ควบคู่กับ children แต่ละ slot มี loading/error states อิสระได้ default.tsx สำหรับ unmatched routes Use cases: modals พร้อม URL, dashboards, split views Slots render แบบ parallel ไม่ใช่ sequentially ดีสำหรับ complex layouts"
    },
    {
      "vocab": "What are Intercepting Routes?",
      "pronunciation": "// Intercepting Routes: show route in different context\n// Convention: (.)folder, (..)folder, (...)folder\n\napp/\n├── feed/\n│   └── page.tsx           // Feed page\n├── photo/\n│   └── [id]/\n│       └── page.tsx       // Full photo page (/photo/123)\n└── @modal/\n    └── (.)photo/          // (.) intercepts same level\n        └── [id]/\n            └── page.tsx   // Modal version of photo\n\n// Interception patterns:\n// (.)  - same level\n// (..) - one level up\n// (..)(..) - two levels up\n// (...) - from root\n\n// Example: Instagram-like photo modal\n// 1. User clicks photo in feed\n// 2. Modal opens with photo (intercepted)\n// 3. URL changes to /photo/123\n// 4. Refresh shows full page version\n// 5. Direct link shows full page version\n\n// Layout with modal slot\nexport default function Layout({ children, modal }) {\n  return (\n    <>\n      {children}\n      {modal}  {/* Intercepted route renders here */}\n    </>\n  );\n}\n\n// Use cases:\n// - Photo/product modals\n// - Login modal (share login URL)\n// - Quick preview without leaving context",
      "meaning": "Intercepting Routes คืออะไร?",
      "example": "Intercepting Routes show a route in different context while keeping URL. Use with parallel routes (@modal). Patterns: (.) same level, (..) parent, (...) root. Instagram-like modals: click opens modal, URL changes, refresh shows full page. Soft navigation intercepts, hard navigation shows original. Great for modals with shareable URLs.",
      "exampleTranslation": "Intercepting Routes แสดง route ใน context ต่างกันขณะเก็บ URL ใช้กับ parallel routes (@modal) Patterns: (.) level เดียว, (..) parent, (...) root Modals แบบ Instagram: click เปิด modal, URL เปลี่ยน, refresh แสดง full page Soft navigation intercepts, hard navigation แสดง original ดีสำหรับ modals ที่มี shareable URLs"
    },
    {
      "vocab": "What are Route Handlers?",
      "pronunciation": "// Route Handler: API endpoints in App Router\n// app/api/posts/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\n\n// GET /api/posts\nexport async function GET(request: NextRequest) {\n  const posts = await db.post.findMany();\n  return NextResponse.json(posts);\n}\n\n// POST /api/posts\nexport async function POST(request: NextRequest) {\n  const body = await request.json();\n  const post = await db.post.create({ data: body });\n  return NextResponse.json(post, { status: 201 });\n}\n\n// Dynamic route\n// app/api/posts/[id]/route.ts\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  const { id } = await params;\n  const post = await db.post.findUnique({ where: { id } });\n  if (!post) {\n    return NextResponse.json({ error: 'Not found' }, { status: 404 });\n  }\n  return NextResponse.json(post);\n}\n\n// Supported methods:\n// GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS\n\n// Access headers, cookies\nconst headersList = request.headers;\nconst cookies = request.cookies;\n\n// Search params\nconst searchParams = request.nextUrl.searchParams;\nconst query = searchParams.get('q');\n\n// Caching (GET requests)\nexport const dynamic = 'force-static';  // Cache\nexport const revalidate = 60;  // ISR",
      "meaning": "Route Handlers คืออะไร?",
      "example": "Route Handlers are API endpoints using route.ts file. Export functions named after HTTP methods: GET, POST, PUT, DELETE. Receive NextRequest with headers, cookies, searchParams. Return NextResponse.json() for JSON. Dynamic routes with [param]. GET requests cached by default. Use for: webhooks, external API integration, when Server Actions don't fit.",
      "exampleTranslation": "Route Handlers คือ API endpoints ที่ใช้ route.ts file Export functions ตั้งชื่อตาม HTTP methods: GET, POST, PUT, DELETE รับ NextRequest พร้อม headers, cookies, searchParams Return NextResponse.json() สำหรับ JSON Dynamic routes กับ [param] GET requests cached by default ใช้สำหรับ: webhooks, external API integration, เมื่อ Server Actions ไม่เหมาะ"
    },
    {
      "vocab": "What is Middleware in Next.js?",
      "pronunciation": "// middleware.ts (root of project)\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  // Get pathname\n  const pathname = request.nextUrl.pathname;\n\n  // Check auth\n  const token = request.cookies.get('token');\n  if (pathname.startsWith('/dashboard') && !token) {\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n\n  // Add headers\n  const response = NextResponse.next();\n  response.headers.set('x-custom-header', 'value');\n  \n  // Rewrite URL\n  if (pathname === '/old-page') {\n    return NextResponse.rewrite(new URL('/new-page', request.url));\n  }\n\n  return response;\n}\n\n// Configure which paths run middleware\nexport const config = {\n  matcher: [\n    // Match all paths except static files\n    '/((?!_next/static|_next/image|favicon.ico).*)',\n    // Or specific paths\n    '/dashboard/:path*',\n    '/api/:path*',\n  ],\n};\n\n// Middleware runs on Edge Runtime\n// Limited APIs (no Node.js APIs)\n// Runs before cached content\n// Use for: auth, redirects, rewrites, headers, A/B tests",
      "meaning": "Middleware ใน Next.js คืออะไร?",
      "example": "Middleware runs before request completes. Single middleware.ts at project root. Use for: authentication redirects, rewrites, adding headers, geolocation, A/B testing. Runs on Edge Runtime (limited Node.js APIs). matcher config specifies which paths. Can redirect, rewrite, or modify response. Runs before cache - good for auth checks.",
      "exampleTranslation": "Middleware รันก่อน request เสร็จ middleware.ts ไฟล์เดียวที่ project root ใช้สำหรับ: authentication redirects, rewrites, adding headers, geolocation, A/B testing รันบน Edge Runtime (Node.js APIs จำกัด) matcher config ระบุ paths ไหน Redirect, rewrite หรือ modify response ได้ รันก่อน cache - ดีสำหรับ auth checks"
    },
    {
      "vocab": "How to handle navigation?",
      "pronunciation": "// Link component: client-side navigation\nimport Link from 'next/link';\n\n<Link href=\"/about\">About</Link>\n<Link href=\"/blog/hello-world\">Post</Link>\n<Link href={{ pathname: '/blog', query: { sort: 'date' } }}>Blog</Link>\n\n// Prefetching (automatic for visible Links)\n<Link href=\"/dashboard\" prefetch={false}>Dashboard</Link>\n\n// Replace history (no back button)\n<Link href=\"/login\" replace>Login</Link>\n\n// useRouter: programmatic navigation\n'use client';\nimport { useRouter } from 'next/navigation';\n\nfunction Component() {\n  const router = useRouter();\n\n  const handleClick = () => {\n    router.push('/dashboard');      // Navigate\n    router.replace('/login');       // Replace\n    router.back();                  // Go back\n    router.forward();               // Go forward\n    router.refresh();               // Refresh current route\n    router.prefetch('/about');      // Prefetch route\n  };\n}\n\n// Other navigation hooks\nimport { usePathname, useSearchParams } from 'next/navigation';\n\nfunction Component() {\n  const pathname = usePathname();        // '/dashboard'\n  const searchParams = useSearchParams(); // URLSearchParams\n  const query = searchParams.get('q');   // Get param\n}\n\n// redirect() in Server Components/Actions\nimport { redirect } from 'next/navigation';\n\nasync function createPost() {\n  'use server';\n  await savePost();\n  redirect('/posts');  // Server-side redirect\n}",
      "meaning": "วิธีจัดการ navigation ทำอย่างไร?",
      "example": "Link component for client-side navigation with automatic prefetching. useRouter() for programmatic navigation: push, replace, back, forward, refresh. usePathname() for current path, useSearchParams() for query params. redirect() for server-side redirects in Server Components/Actions. Link prefetches visible links automatically.",
      "exampleTranslation": "Link component สำหรับ client-side navigation พร้อม automatic prefetching useRouter() สำหรับ programmatic navigation: push, replace, back, forward, refresh usePathname() สำหรับ current path, useSearchParams() สำหรับ query params redirect() สำหรับ server-side redirects ใน Server Components/Actions Link prefetch visible links อัตโนมัติ"
    },
    {
      "vocab": "How to handle Metadata and SEO?",
      "pronunciation": "// Static metadata\n// app/layout.tsx or app/page.tsx\nimport type { Metadata } from 'next';\n\nexport const metadata: Metadata = {\n  title: 'My App',\n  description: 'Welcome to my app',\n  keywords: ['next.js', 'react'],\n  openGraph: {\n    title: 'My App',\n    description: 'Welcome to my app',\n    images: ['/og-image.png'],\n  },\n  twitter: {\n    card: 'summary_large_image',\n  },\n};\n\n// Dynamic metadata\n// app/blog/[slug]/page.tsx\nexport async function generateMetadata(\n  { params }: { params: Promise<{ slug: string }> }\n): Promise<Metadata> {\n  const { slug } = await params;\n  const post = await getPost(slug);\n\n  return {\n    title: post.title,\n    description: post.excerpt,\n    openGraph: {\n      images: [post.image],\n    },\n  };\n}\n\n// Template for title\nexport const metadata: Metadata = {\n  title: {\n    template: '%s | My App',  // Page title | My App\n    default: 'My App',\n  },\n};\n\n// Icons\nexport const metadata: Metadata = {\n  icons: {\n    icon: '/favicon.ico',\n    apple: '/apple-touch-icon.png',\n  },\n};\n\n// Metadata is merged from root to page\n// Page metadata overrides layout metadata",
      "meaning": "วิธีจัดการ Metadata และ SEO ทำอย่างไร?",
      "example": "Export metadata object or generateMetadata function from layouts/pages. Static metadata for fixed values, generateMetadata for dynamic (async). Includes: title, description, openGraph, twitter, icons, robots. Template pattern for consistent titles. Metadata merges from root layout to page - page overrides layout. Built-in SEO optimization.",
      "exampleTranslation": "Export metadata object หรือ generateMetadata function จาก layouts/pages Static metadata สำหรับค่าคงที่ generateMetadata สำหรับ dynamic (async) รวม: title, description, openGraph, twitter, icons, robots Template pattern สำหรับ titles ที่ consistent Metadata merge จาก root layout ถึง page - page override layout Built-in SEO optimization"
    },
    {
      "vocab": "How to optimize images?",
      "pronunciation": "// next/image: automatic optimization\nimport Image from 'next/image';\n\n// Local image (auto width/height from import)\nimport profilePic from './profile.png';\n\n<Image\n  src={profilePic}\n  alt=\"Profile\"\n  placeholder=\"blur\"  // Blur while loading\n/>\n\n// Remote image (must specify dimensions)\n<Image\n  src=\"https://example.com/photo.jpg\"\n  alt=\"Photo\"\n  width={500}\n  height={300}\n/>\n\n// Fill container\n<div className=\"relative w-full h-64\">\n  <Image\n    src=\"/hero.jpg\"\n    alt=\"Hero\"\n    fill\n    className=\"object-cover\"\n  />\n</div>\n\n// Priority (disable lazy loading for LCP)\n<Image src=\"/hero.jpg\" alt=\"Hero\" priority />\n\n// Sizes for responsive\n<Image\n  src=\"/photo.jpg\"\n  alt=\"Photo\"\n  fill\n  sizes=\"(max-width: 768px) 100vw, 50vw\"\n/>\n\n// Configure remote patterns\n// next.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n      },\n    ],\n  },\n};\n\n// Benefits:\n// - Automatic WebP/AVIF conversion\n// - Lazy loading by default\n// - Prevents layout shift\n// - Responsive srcset generation",
      "meaning": "วิธี optimize images ทำอย่างไร?",
      "example": "next/image provides automatic optimization: WebP/AVIF conversion, lazy loading, responsive srcset. Local images auto-detect dimensions. Remote images need width/height or fill. Use priority for above-fold images (LCP). sizes attribute for responsive images. Configure remotePatterns for external domains. Prevents Cumulative Layout Shift.",
      "exampleTranslation": "next/image ให้ automatic optimization: WebP/AVIF conversion, lazy loading, responsive srcset Local images auto-detect dimensions Remote images ต้อง width/height หรือ fill ใช้ priority สำหรับ above-fold images (LCP) sizes attribute สำหรับ responsive images Configure remotePatterns สำหรับ external domains ป้องกัน Cumulative Layout Shift"
    },
    {
      "vocab": "How to optimize fonts?",
      "pronunciation": "// next/font: automatic font optimization\nimport { Inter, Roboto_Mono } from 'next/font/google';\n\n// Variable font (recommended)\nconst inter = Inter({\n  subsets: ['latin'],\n  display: 'swap',\n});\n\n// Specific weights\nconst roboto = Roboto_Mono({\n  weight: ['400', '700'],\n  subsets: ['latin'],\n  display: 'swap',\n});\n\n// Use in layout\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\" className={inter.className}>\n      <body>{children}</body>\n    </html>\n  );\n}\n\n// CSS variable approach\nconst inter = Inter({\n  subsets: ['latin'],\n  variable: '--font-inter',\n});\n\n<html className={inter.variable}>\n// In CSS: font-family: var(--font-inter);\n\n// Local fonts\nimport localFont from 'next/font/local';\n\nconst myFont = localFont({\n  src: './my-font.woff2',\n  display: 'swap',\n});\n\n// Benefits:\n// - Self-hosted (no external requests)\n// - Zero layout shift\n// - Automatic subsetting\n// - Preloaded at build time",
      "meaning": "วิธี optimize fonts ทำอย่างไร?",
      "example": "next/font auto-optimizes Google and local fonts. Self-hosts fonts (no external requests). Zero layout shift with size-adjust. Import from next/font/google or next/font/local. Use className or CSS variable. Variable fonts recommended for flexibility. Fonts preloaded at build time. Automatic subsetting reduces file size.",
      "exampleTranslation": "next/font auto-optimize Google และ local fonts Self-host fonts (ไม่มี external requests) Zero layout shift ด้วย size-adjust Import จาก next/font/google หรือ next/font/local ใช้ className หรือ CSS variable Variable fonts แนะนำสำหรับความยืดหยุ่น Fonts preloaded ตอน build time Automatic subsetting ลด file size"
    },
    {
      "vocab": "What is Static vs Dynamic Rendering?",
      "pronunciation": "// Static Rendering (default)\n// - Rendered at build time\n// - Cached and served from CDN\n// - Great for content that doesn't change often\n\nasync function StaticPage() {\n  const data = await fetch('https://api.example.com/data');\n  // Cached at build time\n  return <div>{data}</div>;\n}\n\n// Dynamic Rendering\n// - Rendered at request time\n// - Fresh data on each request\n\n// Force dynamic rendering\nexport const dynamic = 'force-dynamic';\n\n// Or use dynamic functions\nimport { cookies, headers } from 'next/headers';\n\nasync function DynamicPage() {\n  const cookieStore = await cookies();  // Makes route dynamic\n  const token = cookieStore.get('token');\n  \n  // Or uncached fetch\n  const data = await fetch('https://api.example.com/data', {\n    cache: 'no-store',\n  });\n  \n  return <div>{data}</div>;\n}\n\n// Dynamic functions (opt into dynamic):\n// - cookies()\n// - headers()\n// - searchParams prop\n// - fetch with cache: 'no-store'\n\n// Route segment config\nexport const dynamic = 'auto';         // Default\nexport const dynamic = 'force-dynamic'; // Always dynamic\nexport const dynamic = 'error';         // Error if dynamic\nexport const dynamic = 'force-static';  // Force static",
      "meaning": "Static vs Dynamic Rendering คืออะไร?",
      "example": "Static: rendered at build, cached on CDN, fast. Default for routes without dynamic functions. Dynamic: rendered per request, fresh data. Triggered by: cookies(), headers(), searchParams, uncached fetch. Route config: force-dynamic, force-static. Static for content sites, dynamic for personalized/real-time data. Mix in same app.",
      "exampleTranslation": "Static: render ตอน build, cached บน CDN, เร็ว Default สำหรับ routes ที่ไม่มี dynamic functions Dynamic: render ต่อ request, data ใหม่ Triggered โดย: cookies(), headers(), searchParams, uncached fetch Route config: force-dynamic, force-static Static สำหรับ content sites, dynamic สำหรับ personalized/real-time data ผสมใน app เดียวกันได้"
    },
    {
      "vocab": "What is Incremental Static Regeneration (ISR)?",
      "pronunciation": "// ISR: Static + automatic updates\n// Best of static (fast) and dynamic (fresh)\n\n// Time-based revalidation\nasync function Page() {\n  const data = await fetch('https://api.example.com/posts', {\n    next: { revalidate: 60 },  // Revalidate every 60 seconds\n  });\n  return <PostList posts={data} />;\n}\n\n// Or at route level\nexport const revalidate = 60;  // Revalidate every 60 seconds\n\n// How it works:\n// 1. First request: serve cached version\n// 2. After 60s: still serve cache, trigger regeneration\n// 3. Next request: serve new version\n// Stale-while-revalidate pattern\n\n// On-demand revalidation (webhooks, CMS updates)\n// app/api/revalidate/route.ts\nimport { revalidatePath, revalidateTag } from 'next/cache';\n\nexport async function POST(request: Request) {\n  const { path, tag } = await request.json();\n  \n  // Revalidate specific path\n  revalidatePath('/blog');\n  \n  // Revalidate by tag\n  revalidateTag('posts');\n  \n  return Response.json({ revalidated: true });\n}\n\n// Tag fetches for selective revalidation\nfetch('https://api.example.com/posts', {\n  next: { tags: ['posts'] },\n});\n\n// Then revalidateTag('posts') clears all tagged caches",
      "meaning": "Incremental Static Regeneration (ISR) คืออะไร?",
      "example": "ISR combines static generation with automatic updates. Set revalidate time in fetch or route config. Stale-while-revalidate: serve cached, regenerate in background. On-demand revalidation: revalidatePath() or revalidateTag() for instant updates (webhooks, CMS). Tag fetches for selective cache invalidation. Best for semi-dynamic content.",
      "exampleTranslation": "ISR รวม static generation กับ automatic updates Set revalidate time ใน fetch หรือ route config Stale-while-revalidate: serve cached, regenerate ใน background On-demand revalidation: revalidatePath() หรือ revalidateTag() สำหรับ instant updates (webhooks, CMS) Tag fetches สำหรับ selective cache invalidation ดีที่สุดสำหรับ semi-dynamic content"
    },
    {
      "vocab": "How to use cookies and headers?",
      "pronunciation": "// Reading cookies (Server Component)\nimport { cookies } from 'next/headers';\n\nasync function Page() {\n  const cookieStore = await cookies();\n  const theme = cookieStore.get('theme')?.value;\n  const all = cookieStore.getAll();\n  const hasToken = cookieStore.has('token');\n  \n  return <div>Theme: {theme}</div>;\n}\n\n// Setting cookies (Server Action)\n'use server';\nimport { cookies } from 'next/headers';\n\nexport async function setTheme(theme: string) {\n  const cookieStore = await cookies();\n  cookieStore.set('theme', theme, {\n    httpOnly: true,\n    secure: true,\n    sameSite: 'lax',\n    maxAge: 60 * 60 * 24 * 7,  // 1 week\n  });\n}\n\n// Deleting cookies\ncookieStore.delete('theme');\n\n// Reading headers\nimport { headers } from 'next/headers';\n\nasync function Page() {\n  const headersList = await headers();\n  const userAgent = headersList.get('user-agent');\n  const referer = headersList.get('referer');\n  \n  return <div>UA: {userAgent}</div>;\n}\n\n// Note: cookies() and headers() make route dynamic\n// They return a Promise in Next.js 15+\n// Can only set cookies in:\n// - Server Actions\n// - Route Handlers\n// - Middleware",
      "meaning": "วิธีใช้ cookies และ headers ทำอย่างไร?",
      "example": "cookies() and headers() from next/headers for server-side access. Both return Promise (await required). Reading makes route dynamic. cookies(): get, getAll, has, set, delete. Set cookies only in Server Actions, Route Handlers, Middleware. headers(): read-only access to request headers. Use for auth, personalization, user preferences.",
      "exampleTranslation": "cookies() และ headers() จาก next/headers สำหรับ server-side access ทั้งคู่ return Promise (ต้อง await) Reading ทำให้ route dynamic cookies(): get, getAll, has, set, delete Set cookies ได้ใน Server Actions, Route Handlers, Middleware เท่านั้น headers(): read-only access ถึง request headers ใช้สำหรับ auth, personalization, user preferences"
    },
    {
      "vocab": "How to configure next.config.js?",
      "pronunciation": "// next.config.js (or next.config.ts)\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Strict mode\n  reactStrictMode: true,\n\n  // Image optimization\n  images: {\n    remotePatterns: [\n      { protocol: 'https', hostname: 'example.com' },\n    ],\n  },\n\n  // Environment variables\n  env: {\n    API_URL: process.env.API_URL,\n  },\n\n  // Redirects\n  async redirects() {\n    return [\n      { source: '/old', destination: '/new', permanent: true },\n    ];\n  },\n\n  // Rewrites\n  async rewrites() {\n    return [\n      { source: '/api/:path*', destination: 'https://api.example.com/:path*' },\n    ];\n  },\n\n  // Headers\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [{ key: 'X-Frame-Options', value: 'DENY' }],\n      },\n    ];\n  },\n\n  // Experimental features\n  experimental: {\n    ppr: true,  // Partial Prerendering\n    serverActions: {\n      bodySizeLimit: '2mb',\n    },\n  },\n\n  // Turbopack (dev)\n  // Run: next dev --turbo\n};\n\nmodule.exports = nextConfig;",
      "meaning": "วิธี configure next.config.js ทำอย่างไร?",
      "example": "next.config.js configures Next.js behavior. Common options: images (remote patterns), redirects, rewrites, headers, env vars, experimental features. Redirects for URL changes, rewrites for proxying. TypeScript: use next.config.ts. Supports async functions for dynamic config. Restart dev server after changes.",
      "exampleTranslation": "next.config.js configure Next.js behavior Options ที่ใช้บ่อย: images (remote patterns), redirects, rewrites, headers, env vars, experimental features Redirects สำหรับ URL changes, rewrites สำหรับ proxying TypeScript: ใช้ next.config.ts รองรับ async functions สำหรับ dynamic config Restart dev server หลังเปลี่ยน"
    },
    {
      "vocab": "What is Partial Prerendering (PPR)?",
      "pronunciation": "// PPR: Static shell with dynamic holes\n// Experimental feature in Next.js 14+\n\n// next.config.js\nmodule.exports = {\n  experimental: {\n    ppr: true,\n  },\n};\n\n// How it works:\n// 1. Static shell rendered at build\n// 2. Dynamic parts wrapped in Suspense\n// 3. Shell served instantly from CDN\n// 4. Dynamic parts stream in\n\n// app/page.tsx\nimport { Suspense } from 'react';\n\nexport default function Page() {\n  return (\n    <div>\n      {/* Static - prerendered */}\n      <header>My App</header>\n      <nav>Navigation</nav>\n      \n      {/* Dynamic - streams in */}\n      <Suspense fallback={<UserSkeleton />}>\n        <UserInfo />  {/* Uses cookies() */}\n      </Suspense>\n      \n      {/* Static */}\n      <footer>Footer</footer>\n    </div>\n  );\n}\n\n// Benefits:\n// - Instant static shell (TTFB)\n// - Dynamic personalization\n// - No waterfall for dynamic data\n// - Single HTTP response (streaming)\n\n// Without PPR:\n// - Choose between static OR dynamic\n// - Dynamic routes fully server-rendered\n\n// With PPR:\n// - Static parts instant\n// - Only dynamic parts wait for data",
      "meaning": "Partial Prerendering (PPR) คืออะไร?",
      "example": "PPR combines static shell with dynamic holes. Static parts prerendered at build, served instantly from CDN. Dynamic parts (using cookies, headers) wrapped in Suspense, stream in. Best of both: static speed + dynamic personalization. Enable in experimental config. Suspense boundaries define static/dynamic split. Revolutionary for hybrid pages.",
      "exampleTranslation": "PPR รวม static shell กับ dynamic holes Static parts prerendered ตอน build, served ทันทีจาก CDN Dynamic parts (ใช้ cookies, headers) wrap ใน Suspense, stream เข้ามา ดีที่สุดของทั้งคู่: static speed + dynamic personalization Enable ใน experimental config Suspense boundaries กำหนด static/dynamic split Revolutionary สำหรับ hybrid pages"
    },
    {
      "vocab": "How to handle authentication?",
      "pronunciation": "// Middleware for route protection\n// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  const token = request.cookies.get('token')?.value;\n  \n  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n  \n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/dashboard/:path*'],\n};\n\n// Server Component auth check\nimport { cookies } from 'next/headers';\nimport { redirect } from 'next/navigation';\n\nasync function DashboardPage() {\n  const cookieStore = await cookies();\n  const token = cookieStore.get('token');\n  \n  if (!token) {\n    redirect('/login');\n  }\n  \n  const user = await verifyToken(token.value);\n  return <Dashboard user={user} />;\n}\n\n// Server Action for login\n'use server';\nimport { cookies } from 'next/headers';\n\nexport async function login(formData: FormData) {\n  const email = formData.get('email');\n  const password = formData.get('password');\n  \n  const token = await authenticate(email, password);\n  \n  const cookieStore = await cookies();\n  cookieStore.set('token', token, {\n    httpOnly: true,\n    secure: true,\n    sameSite: 'lax',\n  });\n  \n  redirect('/dashboard');\n}\n\n// Libraries: NextAuth.js, Clerk, Auth0, Lucia",
      "meaning": "วิธีจัดการ authentication ทำอย่างไร?",
      "example": "Multiple layers: Middleware for route protection (runs on edge), Server Components for page-level checks, Server Actions for login/logout. Store tokens in httpOnly cookies (secure). Middleware redirects before page loads. Popular libraries: NextAuth.js (Auth.js), Clerk, Lucia. Check auth in layouts for section-wide protection.",
      "exampleTranslation": "หลาย layers: Middleware สำหรับ route protection (runs on edge), Server Components สำหรับ page-level checks, Server Actions สำหรับ login/logout เก็บ tokens ใน httpOnly cookies (secure) Middleware redirect ก่อน page loads Libraries ที่นิยม: NextAuth.js (Auth.js), Clerk, Lucia Check auth ใน layouts สำหรับ section-wide protection"
    },
    {
      "vocab": "How to handle environment variables?",
      "pronunciation": "// .env.local (not committed)\nDATABASE_URL=\"postgresql://...\"\nAPI_SECRET=\"secret-key\"\nNEXT_PUBLIC_API_URL=\"https://api.example.com\"\n\n// Environment files (loaded in order)\n// .env                 - all environments\n// .env.local           - local overrides (gitignored)\n// .env.development     - development only\n// .env.production      - production only\n\n// Server-only variables\n// Only accessible in:\n// - Server Components\n// - Route Handlers\n// - Server Actions\n// - next.config.js\n\nconst secret = process.env.API_SECRET;  // Server only\n\n// Client-accessible variables\n// Must prefix with NEXT_PUBLIC_\nconst apiUrl = process.env.NEXT_PUBLIC_API_URL;  // Client OK\n\n// Type-safe env with validation\n// lib/env.ts\nimport { z } from 'zod';\n\nconst envSchema = z.object({\n  DATABASE_URL: z.string().url(),\n  API_SECRET: z.string().min(1),\n  NEXT_PUBLIC_API_URL: z.string().url(),\n});\n\nexport const env = envSchema.parse(process.env);\n\n// Usage\nimport { env } from '@/lib/env';\nconst url = env.DATABASE_URL;  // Type-safe\n\n// Note: Changes require restart\n// NEXT_PUBLIC_ vars are inlined at build time",
      "meaning": "วิธีจัดการ environment variables ทำอย่างไร?",
      "example": "Use .env files for configuration. Server-only vars: accessible in Server Components, Actions, Route Handlers. Client vars: prefix with NEXT_PUBLIC_ (inlined at build). Priority: .env.local > .env.development > .env. Use Zod for type-safe validation. Never expose secrets to client. Restart dev server after changes.",
      "exampleTranslation": "ใช้ .env files สำหรับ configuration Server-only vars: เข้าถึงได้ใน Server Components, Actions, Route Handlers Client vars: prefix ด้วย NEXT_PUBLIC_ (inlined ตอน build) Priority: .env.local > .env.development > .env ใช้ Zod สำหรับ type-safe validation อย่า expose secrets ให้ client Restart dev server หลังเปลี่ยน"
    },
    {
      "vocab": "What are the caching layers in Next.js?",
      "pronunciation": "// 4 Caching mechanisms in Next.js\n\n// 1. Request Memoization\n// Same fetch in one render = deduplicated\nasync function Page() {\n  const data1 = await fetch('/api/data');  // Fetched\n  const data2 = await fetch('/api/data');  // Memoized (same request)\n}\n\n// 2. Data Cache\n// Fetch results cached across requests\nfetch(url);  // Cached by default\nfetch(url, { cache: 'no-store' });  // Skip cache\nfetch(url, { next: { revalidate: 60 } });  // Revalidate\nfetch(url, { next: { tags: ['posts'] } });  // Tagged\n\n// 3. Full Route Cache\n// Rendered pages cached at build time\n// Static routes cached until revalidation\nexport const revalidate = 3600;  // Page-level revalidate\n\n// 4. Router Cache (client-side)\n// Visited routes cached in browser\n// Prefetched routes cached\n// Default: 30s for dynamic, 5min for static\n\n// Opting out of caching\nexport const dynamic = 'force-dynamic';  // Route level\nexport const revalidate = 0;  // Disable cache\nfetch(url, { cache: 'no-store' });  // Fetch level\n\n// Revalidating cache\nrevalidatePath('/posts');  // Path-based\nrevalidateTag('posts');     // Tag-based\n\n// Force refresh client cache\nimport { useRouter } from 'next/navigation';\nrouter.refresh();  // Refresh current route",
      "meaning": "Caching layers ใน Next.js มีอะไรบ้าง?",
      "example": "4 layers: 1) Request Memoization - dedupes same fetch in render, 2) Data Cache - persists fetch results, 3) Full Route Cache - caches rendered pages, 4) Router Cache - client-side cache for navigation. Opt out with cache: 'no-store', dynamic: 'force-dynamic'. Revalidate with revalidatePath/revalidateTag. Understanding caching is key to Next.js.",
      "exampleTranslation": "4 layers: 1) Request Memoization - dedupe fetch เดียวกันใน render 2) Data Cache - persist fetch results 3) Full Route Cache - cache rendered pages 4) Router Cache - client-side cache สำหรับ navigation Opt out ด้วย cache: 'no-store', dynamic: 'force-dynamic' Revalidate ด้วย revalidatePath/revalidateTag เข้าใจ caching เป็น key สำหรับ Next.js"
    },
    {
      "vocab": "How to deploy Next.js?",
      "pronunciation": "// Vercel (recommended, zero-config)\n// 1. Push to GitHub\n// 2. Import project on vercel.com\n// 3. Deploy!\n\n// Build output\nnpm run build\n// Creates .next/ folder\n\n// Self-hosting with Node.js\n// package.json\n{\n  \"scripts\": {\n    \"start\": \"next start -p $PORT\"\n  }\n}\n\n// Run production\nNODE_ENV=production npm start\n\n// Docker\n// Dockerfile\nFROM node:20-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY .next ./.next\nCOPY public ./public\nEXPOSE 3000\nCMD [\"npm\", \"start\"]\n\n// Static Export (no server needed)\n// next.config.js\nmodule.exports = {\n  output: 'export',\n};\n// Generates static HTML in out/ folder\n// Host on any static host (S3, Cloudflare Pages)\n\n// Standalone output (smaller Docker)\nmodule.exports = {\n  output: 'standalone',\n};\n// Creates minimal server in .next/standalone\n\n// Edge deployments\n// Vercel Edge, Cloudflare Workers\n// Some features may not be available",
      "meaning": "วิธี deploy Next.js ทำอย่างไร?",
      "example": "Vercel: zero-config, best integration, automatic previews. Self-host: npm run build, npm start with Node.js. Docker: use standalone output for minimal image. Static export: output: 'export' for static HTML (limited features). Edge: Vercel Edge, Cloudflare. Consider: ISR support, Edge vs Node runtime, serverless limits.",
      "exampleTranslation": "Vercel: zero-config, integration ดีที่สุด, automatic previews Self-host: npm run build, npm start กับ Node.js Docker: ใช้ standalone output สำหรับ minimal image Static export: output: 'export' สำหรับ static HTML (features จำกัด) Edge: Vercel Edge, Cloudflare พิจารณา: ISR support, Edge vs Node runtime, serverless limits"
    },
    {
      "vocab": "What is Turbopack?",
      "pronunciation": "// Turbopack: Next.js incremental bundler\n// Written in Rust, successor to Webpack\n\n// Enable in development\nnext dev --turbo\n\n// package.json\n{\n  \"scripts\": {\n    \"dev\": \"next dev --turbo\"\n  }\n}\n\n// Benefits:\n// - 700x faster than Webpack (cold start)\n// - 10x faster than Vite (large apps)\n// - Incremental computation\n// - Persistent caching\n\n// Supported features:\n// - TypeScript\n// - JSX\n// - CSS Modules\n// - Tailwind CSS\n// - postcss\n// - next/image, next/font\n// - Server Components\n// - App Router\n\n// Current status (Next.js 15):\n// - Stable for development\n// - Production builds still use Webpack\n// - Most features supported\n\n// Check if Turbopack is running\n// Look for 'ready - started server on' message\n// With Turbopack: shows '(turbo)'\n\n// If issues, disable Turbopack\nnext dev  // Without --turbo flag\n\n// Future:\n// - Full production support\n// - Complete Webpack feature parity\n// - Even faster incremental builds",
      "meaning": "Turbopack คืออะไร?",
      "example": "Turbopack is Rust-based bundler, successor to Webpack. 700x faster cold starts, 10x faster than Vite for large apps. Enable with --turbo flag. Stable for development in Next.js 15. Supports: TypeScript, CSS Modules, Tailwind, Server Components. Production still uses Webpack. Incremental architecture for fast HMR.",
      "exampleTranslation": "Turbopack คือ Rust-based bundler ที่สืบทอดจาก Webpack Cold starts เร็วกว่า 700x, เร็วกว่า Vite 10x สำหรับ large apps Enable ด้วย --turbo flag Stable สำหรับ development ใน Next.js 15 รองรับ: TypeScript, CSS Modules, Tailwind, Server Components Production ยังใช้ Webpack Incremental architecture สำหรับ HMR เร็ว"
    },
    {
      "vocab": "What are common Next.js patterns?",
      "pronunciation": "// 1. Fetch in Server Component, pass to Client\nasync function Page() {\n  const data = await fetchData();  // Server\n  return <ClientChart data={data} />;  // Client receives\n}\n\n// 2. Compose layouts\napp/\n├── (auth)/layout.tsx    // No nav layout\n├── (main)/layout.tsx    // With nav layout\n\n// 3. Parallel data fetching\nconst [posts, users] = await Promise.all([\n  fetchPosts(),\n  fetchUsers(),\n]);\n\n// 4. Streaming with Suspense\n<Suspense fallback={<Skeleton />}>\n  <SlowComponent />\n</Suspense>\n\n// 5. Optimistic updates\nconst [optimisticItems, addOptimistic] = useOptimistic(items);\n\n// 6. Server Action forms\n<form action={serverAction}>\n  <SubmitButton />  {/* Uses useFormStatus */}\n</form>\n\n// 7. Search params for state\nconst searchParams = useSearchParams();\nconst page = searchParams.get('page') || '1';\n\n// 8. Catch-all for CMS pages\napp/[...slug]/page.tsx\n\n// 9. API route for webhooks\napp/api/webhook/route.ts\n\n// 10. Modal with intercepting route\napp/@modal/(.)photo/[id]/page.tsx",
      "meaning": "Next.js patterns ที่ใช้บ่อยมีอะไรบ้าง?",
      "example": "Common patterns: Server fetch + Client display, route groups for layouts, parallel fetching with Promise.all, Suspense streaming, optimistic updates, Server Action forms, URL state with searchParams, catch-all for CMS, intercepting routes for modals. Mix static and dynamic with Suspense boundaries. Keep Client Components small.",
      "exampleTranslation": "Patterns ที่ใช้บ่อย: Server fetch + Client display, route groups สำหรับ layouts, parallel fetching ด้วย Promise.all, Suspense streaming, optimistic updates, Server Action forms, URL state ด้วย searchParams, catch-all สำหรับ CMS, intercepting routes สำหรับ modals Mix static และ dynamic ด้วย Suspense boundaries Keep Client Components เล็ก"
    },
    {
      "vocab": "What are common Next.js mistakes to avoid?",
      "pronunciation": "// 1. Using 'use client' unnecessarily\n// ❌ Making everything client\n'use client';\nexport function StaticContent() {...}  // Doesn't need client\n\n// ✅ Keep server by default\nexport function StaticContent() {...}  // Server component\n\n// 2. Not using Suspense for streaming\n// ❌ Everything waits for slowest\nasync function Page() {\n  const slow = await slowFetch();\n  return <div>{slow}</div>;\n}\n\n// ✅ Stream with Suspense\n<Suspense fallback={<Loading />}>\n  <SlowComponent />\n</Suspense>\n\n// 3. Fetching in client when server works\n// ❌ useEffect + fetch\n'use client';\nuseEffect(() => { fetchData(); }, []);\n\n// ✅ Server Component\nasync function Page() {\n  const data = await fetch('...');\n}\n\n// 4. Not handling loading/error states\n// ✅ Add loading.tsx and error.tsx\n\n// 5. Wrong cache configuration\n// ❌ Always no-store\nfetch(url, { cache: 'no-store' });  // Every request\n\n// ✅ Use revalidate\nfetch(url, { next: { revalidate: 60 } });\n\n// 6. Ignoring metadata\n// ✅ Add metadata for SEO\nexport const metadata = { title: '...' };\n\n// 7. Large client bundles\n// ✅ Code split with dynamic imports\nconst Heavy = dynamic(() => import('./Heavy'));",
      "meaning": "Next.js mistakes ที่ควรหลีกเลี่ยงมีอะไรบ้าง?",
      "example": "Avoid: unnecessary 'use client', not using Suspense for streaming, client fetching when server works, missing loading/error files, wrong cache config (always no-store), ignoring metadata, large client bundles. Keep components server by default. Use streaming for better UX. Leverage caching properly. Add error boundaries.",
      "exampleTranslation": "หลีกเลี่ยง: 'use client' ที่ไม่จำเป็น, ไม่ใช้ Suspense สำหรับ streaming, client fetching เมื่อ server ใช้ได้, ไม่มี loading/error files, cache config ผิด (always no-store), ไม่ใส่ metadata, large client bundles Keep components เป็น server by default ใช้ streaming สำหรับ UX ที่ดีกว่า Leverage caching อย่างเหมาะสม Add error boundaries"
    }
  ]
}
