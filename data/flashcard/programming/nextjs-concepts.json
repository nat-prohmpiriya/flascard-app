{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "Next.js 16 Concepts",
    "description": "Core Next.js 16 concepts including App Router, Server Components, caching, Server Actions, and modern features",
    "category": "Programming",
    "tags": ["nextjs", "react", "frontend", "fullstack", "app-router"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is Next.js and why use it?",
      "pronunciation": "",
      "meaning": "Next.js คืออะไรและทำไมต้องใช้?",
      "example": "Next.js is a React framework for production. Provides: file-based routing, SSR/SSG/ISR, API routes, automatic optimization. App Router (default) uses React Server Components. Benefits: SEO-friendly, fast performance, full-stack capabilities, great DX. Used by major companies. Turbopack for faster dev builds.",
      "exampleTranslation": "Next.js คือ React framework สำหรับ production ให้: file-based routing, SSR/SSG/ISR, API routes, automatic optimization App Router (default) ใช้ React Server Components ข้อดี: SEO-friendly, performance เร็ว, full-stack capabilities, DX ดี ใช้โดย major companies Turbopack สำหรับ dev builds เร็วขึ้น"
    },
    {
      "vocab": "What is App Router vs Pages Router?",
      "pronunciation": "app/ vs pages/",
      "meaning": "App Router vs Pages Router คืออะไร?",
      "example": "App Router (app/) is the modern approach with Server Components, nested layouts, streaming, Server Actions. Pages Router (pages/) is legacy with getServerSideProps/getStaticProps. App Router benefits: better performance, simpler data fetching, granular loading states. Both can coexist for gradual migration.",
      "exampleTranslation": "App Router (app/) คือ approach สมัยใหม่กับ Server Components, nested layouts, streaming, Server Actions Pages Router (pages/) เป็น legacy กับ getServerSideProps/getStaticProps App Router ข้อดี: performance ดีกว่า, data fetching ง่ายกว่า, granular loading states ทั้งคู่อยู่ร่วมกันได้สำหรับ gradual migration"
    },
    {
      "vocab": "How does file-based routing work?",
      "pronunciation": "[param], [...slug], [[...slug]]",
      "meaning": "File-based routing ทำงานอย่างไร?",
      "example": "Folder structure defines URL routes. page.tsx makes route accessible. Special files: layout.tsx (shared UI), loading.tsx (loading state), error.tsx (error boundary), not-found.tsx (404). Dynamic routes: [param] single, [...slug] catch-all, [[...slug]] optional catch-all. Route groups (folder) don't affect URL.",
      "exampleTranslation": "Folder structure กำหนด URL routes page.tsx ทำให้ route accessible Special files: layout.tsx (shared UI), loading.tsx (loading state), error.tsx (error boundary), not-found.tsx (404) Dynamic routes: [param] single, [...slug] catch-all, [[...slug]] optional catch-all Route groups (folder) ไม่กระทบ URL"
    },
    {
      "vocab": "What are Layouts and Templates?",
      "pronunciation": "layout.tsx, template.tsx",
      "meaning": "Layouts และ Templates คืออะไร?",
      "example": "Layouts wrap pages and preserve state across navigations. Root layout required with <html><body>. Nested layouts for sections (dashboard, admin). Templates are like layouts but remount on navigation - use for animations or resetting state. Layouts don't re-render, templates do.",
      "exampleTranslation": "Layouts wrap pages และรักษา state ข้าม navigations Root layout จำเป็นกับ <html><body> Nested layouts สำหรับ sections (dashboard, admin) Templates เหมือน layouts แต่ remount เมื่อ navigation ใช้สำหรับ animations หรือ resetting state Layouts ไม่ re-render, templates re-render"
    },
    {
      "vocab": "What are Server Components vs Client Components?",
      "pronunciation": "'use client' directive",
      "meaning": "Server Components vs Client Components คืออะไร?",
      "example": "Server Components (default): render on server, zero client JS, can use async/await, access databases/secrets directly. Client Components: add 'use client' directive, use for interactivity, hooks, browser APIs. Server imports Client, not vice versa. Client Components are 'islands' of interactivity.",
      "exampleTranslation": "Server Components (default): render บน server, ไม่มี client JS, ใช้ async/await ได้, เข้าถึง databases/secrets โดยตรง Client Components: เพิ่ม 'use client' directive, ใช้สำหรับ interactivity, hooks, browser APIs Server import Client ไม่ใช่กลับกัน Client Components เป็น 'islands' ของ interactivity"
    },
    {
      "vocab": "How does data fetching work in App Router?",
      "pronunciation": "cache, revalidate, tags",
      "meaning": "Data fetching ทำงานอย่างไรใน App Router?",
      "example": "In Server Components, fetch directly with async/await. Default: cached (like SSG). cache: 'no-store' for dynamic (SSR). next: { revalidate: 60 } for ISR. Use tags for on-demand revalidation. Parallel fetch with Promise.all. Can access database/ORM directly.",
      "exampleTranslation": "ใน Server Components fetch โดยตรงด้วย async/await Default: cached (เหมือน SSG) cache: 'no-store' สำหรับ dynamic (SSR) next: { revalidate: 60 } สำหรับ ISR ใช้ tags สำหรับ on-demand revalidation Parallel fetch ด้วย Promise.all เข้าถึง database/ORM โดยตรงได้"
    },
    {
      "vocab": "What are Server Actions?",
      "pronunciation": "'use server', action={fn}",
      "meaning": "Server Actions คืออะไร?",
      "example": "Server Actions are async functions running on server, callable from client. Mark with 'use server'. Use in form action attribute - works without JavaScript (progressive enhancement). Can validate, save to database, revalidate cache, redirect. useActionState for pending/error states.",
      "exampleTranslation": "Server Actions เป็น async functions ที่รันบน server เรียกจาก client ได้ Mark ด้วย 'use server' ใช้ใน form action attribute ทำงานโดยไม่มี JavaScript (progressive enhancement) Validate, save to database, revalidate cache, redirect ได้ useActionState สำหรับ pending/error states"
    },
    {
      "vocab": "How to handle loading states?",
      "pronunciation": "loading.tsx, <Suspense>",
      "meaning": "วิธีจัดการ loading states ทำอย่างไร?",
      "example": "loading.tsx creates automatic Suspense boundary for route. Shows while page.tsx loads. Use skeleton loaders for better UX. Manual Suspense for granular control - different loading states for different sections. Streaming: shell renders immediately, heavy components stream in progressively.",
      "exampleTranslation": "loading.tsx สร้าง automatic Suspense boundary สำหรับ route แสดงขณะ page.tsx โหลด ใช้ skeleton loaders สำหรับ UX ที่ดีกว่า Manual Suspense สำหรับ granular control loading states ต่างกันสำหรับ sections ต่างกัน Streaming: shell render ทันที, heavy components stream เข้ามาทีละส่วน"
    },
    {
      "vocab": "How to handle errors?",
      "pronunciation": "error.tsx, global-error.tsx, notFound()",
      "meaning": "วิธีจัดการ errors ทำอย่างไร?",
      "example": "error.tsx creates Error Boundary for route segment. Must be 'use client'. Receives error and reset function. global-error.tsx for root layout errors (must include html/body). not-found.tsx for 404 pages. notFound() triggers 404 programmatically. Errors bubble up to nearest error.tsx.",
      "exampleTranslation": "error.tsx สร้าง Error Boundary สำหรับ route segment ต้องเป็น 'use client' รับ error และ reset function global-error.tsx สำหรับ root layout errors (ต้องมี html/body) not-found.tsx สำหรับ 404 pages notFound() trigger 404 โดย programmatic Errors bubble up ไปยัง error.tsx ที่ใกล้ที่สุด"
    },
    {
      "vocab": "What are Route Groups?",
      "pronunciation": "(folderName)",
      "meaning": "Route Groups คืออะไร?",
      "example": "Route Groups use (folderName) syntax to organize routes without affecting URL path. Group name not included in URL. Use cases: organize by feature/team, apply different layouts to sections, create multiple root layouts. Great for separating marketing site from app.",
      "exampleTranslation": "Route Groups ใช้ (folderName) syntax เพื่อจัดระเบียบ routes โดยไม่กระทบ URL path ชื่อ group ไม่รวมใน URL Use cases: จัดระเบียบตาม feature/team, apply layouts ต่างกันให้ sections, สร้าง multiple root layouts ดีสำหรับแยก marketing site จาก app"
    },
    {
      "vocab": "What are Dynamic Routes?",
      "pronunciation": "[slug], [...slug], [[...slug]]",
      "meaning": "Dynamic Routes คืออะไร?",
      "example": "Dynamic routes use brackets for variable segments. [param] for single segment, [...slug] for catch-all, [[...slug]] for optional catch-all. Access via params prop (Promise in Next.js 15+). generateStaticParams for SSG - returns array of param objects to pre-render.",
      "exampleTranslation": "Dynamic routes ใช้ brackets สำหรับ variable segments [param] สำหรับ single segment, [...slug] สำหรับ catch-all, [[...slug]] สำหรับ optional catch-all เข้าถึงผ่าน params prop (Promise ใน Next.js 15+) generateStaticParams สำหรับ SSG return array ของ param objects เพื่อ pre-render"
    },
    {
      "vocab": "What are Parallel Routes?",
      "pronunciation": "@folder slots",
      "meaning": "Parallel Routes คืออะไร?",
      "example": "Parallel Routes render multiple pages simultaneously using @folder slots. Layout receives slots as props alongside children. Each slot can have independent loading/error states. default.tsx for unmatched routes. Use cases: modals with URL, dashboards, split views.",
      "exampleTranslation": "Parallel Routes render หลาย pages พร้อมกันโดยใช้ @folder slots Layout รับ slots เป็น props ควบคู่กับ children แต่ละ slot มี loading/error states อิสระได้ default.tsx สำหรับ unmatched routes Use cases: modals พร้อม URL, dashboards, split views"
    },
    {
      "vocab": "What are Intercepting Routes?",
      "pronunciation": "(.) (..) (...)",
      "meaning": "Intercepting Routes คืออะไร?",
      "example": "Intercepting Routes show a route in different context while keeping URL. Use with parallel routes (@modal). Patterns: (.) same level, (..) parent, (...) root. Instagram-like modals: click opens modal, URL changes, refresh shows full page. Soft navigation intercepts, hard navigation shows original.",
      "exampleTranslation": "Intercepting Routes แสดง route ใน context ต่างกันขณะเก็บ URL ใช้กับ parallel routes (@modal) Patterns: (.) level เดียว, (..) parent, (...) root Modals แบบ Instagram: click เปิด modal, URL เปลี่ยน, refresh แสดง full page Soft navigation intercepts, hard navigation แสดง original"
    },
    {
      "vocab": "What are Route Handlers?",
      "pronunciation": "route.ts GET, POST, PUT, DELETE",
      "meaning": "Route Handlers คืออะไร?",
      "example": "Route Handlers are API endpoints using route.ts file. Export functions named after HTTP methods: GET, POST, PUT, DELETE. Receive NextRequest with headers, cookies, searchParams. Return NextResponse.json() for JSON. Dynamic routes with [param]. GET requests cached by default.",
      "exampleTranslation": "Route Handlers คือ API endpoints ที่ใช้ route.ts file Export functions ตั้งชื่อตาม HTTP methods: GET, POST, PUT, DELETE รับ NextRequest พร้อม headers, cookies, searchParams Return NextResponse.json() สำหรับ JSON Dynamic routes กับ [param] GET requests cached by default"
    },
    {
      "vocab": "What is Middleware in Next.js?",
      "pronunciation": "middleware.ts, matcher config",
      "meaning": "Middleware ใน Next.js คืออะไร?",
      "example": "Middleware runs before request completes. Single middleware.ts at project root. Use for: authentication redirects, rewrites, adding headers, geolocation, A/B testing. Runs on Edge Runtime (limited Node.js APIs). matcher config specifies which paths. Runs before cache.",
      "exampleTranslation": "Middleware รันก่อน request เสร็จ middleware.ts ไฟล์เดียวที่ project root ใช้สำหรับ: authentication redirects, rewrites, adding headers, geolocation, A/B testing รันบน Edge Runtime (Node.js APIs จำกัด) matcher config ระบุ paths ไหน รันก่อน cache"
    },
    {
      "vocab": "How to handle navigation?",
      "pronunciation": "Link, useRouter, redirect",
      "meaning": "วิธีจัดการ navigation ทำอย่างไร?",
      "example": "Link component for client-side navigation with automatic prefetching. useRouter() for programmatic navigation: push, replace, back, forward, refresh. usePathname() for current path, useSearchParams() for query params. redirect() for server-side redirects in Server Components/Actions.",
      "exampleTranslation": "Link component สำหรับ client-side navigation พร้อม automatic prefetching useRouter() สำหรับ programmatic navigation: push, replace, back, forward, refresh usePathname() สำหรับ current path, useSearchParams() สำหรับ query params redirect() สำหรับ server-side redirects ใน Server Components/Actions"
    },
    {
      "vocab": "How to handle Metadata and SEO?",
      "pronunciation": "metadata, generateMetadata",
      "meaning": "วิธีจัดการ Metadata และ SEO ทำอย่างไร?",
      "example": "Export metadata object or generateMetadata function from layouts/pages. Static metadata for fixed values, generateMetadata for dynamic (async). Includes: title, description, openGraph, twitter, icons. Template pattern for consistent titles. Metadata merges from root layout to page.",
      "exampleTranslation": "Export metadata object หรือ generateMetadata function จาก layouts/pages Static metadata สำหรับค่าคงที่ generateMetadata สำหรับ dynamic (async) รวม: title, description, openGraph, twitter, icons Template pattern สำหรับ titles ที่ consistent Metadata merge จาก root layout ถึง page"
    },
    {
      "vocab": "How to optimize images?",
      "pronunciation": "next/image, priority, fill",
      "meaning": "วิธี optimize images ทำอย่างไร?",
      "example": "next/image provides automatic optimization: WebP/AVIF conversion, lazy loading, responsive srcset. Local images auto-detect dimensions. Remote images need width/height or fill. Use priority for above-fold images (LCP). sizes attribute for responsive images. Prevents Cumulative Layout Shift.",
      "exampleTranslation": "next/image ให้ automatic optimization: WebP/AVIF conversion, lazy loading, responsive srcset Local images auto-detect dimensions Remote images ต้อง width/height หรือ fill ใช้ priority สำหรับ above-fold images (LCP) sizes attribute สำหรับ responsive images ป้องกัน Cumulative Layout Shift"
    },
    {
      "vocab": "How to optimize fonts?",
      "pronunciation": "next/font/google, next/font/local",
      "meaning": "วิธี optimize fonts ทำอย่างไร?",
      "example": "next/font auto-optimizes Google and local fonts. Self-hosts fonts (no external requests). Zero layout shift with size-adjust. Import from next/font/google or next/font/local. Use className or CSS variable. Variable fonts recommended for flexibility. Fonts preloaded at build time.",
      "exampleTranslation": "next/font auto-optimize Google และ local fonts Self-host fonts (ไม่มี external requests) Zero layout shift ด้วย size-adjust Import จาก next/font/google หรือ next/font/local ใช้ className หรือ CSS variable Variable fonts แนะนำสำหรับความยืดหยุ่น Fonts preloaded ตอน build time"
    },
    {
      "vocab": "What is Static vs Dynamic Rendering?",
      "pronunciation": "force-dynamic, force-static",
      "meaning": "Static vs Dynamic Rendering คืออะไร?",
      "example": "Static: rendered at build, cached on CDN, fast. Default for routes without dynamic functions. Dynamic: rendered per request, fresh data. Triggered by: cookies(), headers(), searchParams, uncached fetch. Route config: force-dynamic, force-static. Mix in same app.",
      "exampleTranslation": "Static: render ตอน build, cached บน CDN, เร็ว Default สำหรับ routes ที่ไม่มี dynamic functions Dynamic: render ต่อ request, data ใหม่ Triggered โดย: cookies(), headers(), searchParams, uncached fetch Route config: force-dynamic, force-static ผสมใน app เดียวกันได้"
    },
    {
      "vocab": "What is Incremental Static Regeneration (ISR)?",
      "pronunciation": "revalidate, revalidatePath, revalidateTag",
      "meaning": "Incremental Static Regeneration (ISR) คืออะไร?",
      "example": "ISR combines static generation with automatic updates. Set revalidate time in fetch or route config. Stale-while-revalidate: serve cached, regenerate in background. On-demand revalidation: revalidatePath() or revalidateTag() for instant updates (webhooks, CMS). Best for semi-dynamic content.",
      "exampleTranslation": "ISR รวม static generation กับ automatic updates Set revalidate time ใน fetch หรือ route config Stale-while-revalidate: serve cached, regenerate ใน background On-demand revalidation: revalidatePath() หรือ revalidateTag() สำหรับ instant updates (webhooks, CMS) ดีที่สุดสำหรับ semi-dynamic content"
    },
    {
      "vocab": "How to use cookies and headers?",
      "pronunciation": "cookies(), headers() from next/headers",
      "meaning": "วิธีใช้ cookies และ headers ทำอย่างไร?",
      "example": "cookies() and headers() from next/headers for server-side access. Both return Promise (await required). Reading makes route dynamic. cookies(): get, getAll, has, set, delete. Set cookies only in Server Actions, Route Handlers, Middleware. headers(): read-only access.",
      "exampleTranslation": "cookies() และ headers() จาก next/headers สำหรับ server-side access ทั้งคู่ return Promise (ต้อง await) Reading ทำให้ route dynamic cookies(): get, getAll, has, set, delete Set cookies ได้ใน Server Actions, Route Handlers, Middleware เท่านั้น headers(): read-only access"
    },
    {
      "vocab": "How to configure next.config.js?",
      "pronunciation": "images, redirects, rewrites, headers",
      "meaning": "วิธี configure next.config.js ทำอย่างไร?",
      "example": "next.config.js configures Next.js behavior. Common options: images (remote patterns), redirects, rewrites, headers, env vars, experimental features. Redirects for URL changes, rewrites for proxying. TypeScript: use next.config.ts. Restart dev server after changes.",
      "exampleTranslation": "next.config.js configure Next.js behavior Options ที่ใช้บ่อย: images (remote patterns), redirects, rewrites, headers, env vars, experimental features Redirects สำหรับ URL changes, rewrites สำหรับ proxying TypeScript: ใช้ next.config.ts Restart dev server หลังเปลี่ยน"
    },
    {
      "vocab": "What is Partial Prerendering (PPR)?",
      "pronunciation": "experimental.ppr",
      "meaning": "Partial Prerendering (PPR) คืออะไร?",
      "example": "PPR combines static shell with dynamic holes. Static parts prerendered at build, served instantly from CDN. Dynamic parts (using cookies, headers) wrapped in Suspense, stream in. Best of both: static speed + dynamic personalization. Enable in experimental config.",
      "exampleTranslation": "PPR รวม static shell กับ dynamic holes Static parts prerendered ตอน build, served ทันทีจาก CDN Dynamic parts (ใช้ cookies, headers) wrap ใน Suspense, stream เข้ามา ดีที่สุดของทั้งคู่: static speed + dynamic personalization Enable ใน experimental config"
    },
    {
      "vocab": "How to handle authentication?",
      "pronunciation": "middleware, cookies, redirect",
      "meaning": "วิธีจัดการ authentication ทำอย่างไร?",
      "example": "Multiple layers: Middleware for route protection (runs on edge), Server Components for page-level checks, Server Actions for login/logout. Store tokens in httpOnly cookies (secure). Middleware redirects before page loads. Popular libraries: NextAuth.js, Clerk, Lucia.",
      "exampleTranslation": "หลาย layers: Middleware สำหรับ route protection (runs on edge), Server Components สำหรับ page-level checks, Server Actions สำหรับ login/logout เก็บ tokens ใน httpOnly cookies (secure) Middleware redirect ก่อน page loads Libraries ที่นิยม: NextAuth.js, Clerk, Lucia"
    },
    {
      "vocab": "How to handle environment variables?",
      "pronunciation": "NEXT_PUBLIC_, .env.local",
      "meaning": "วิธีจัดการ environment variables ทำอย่างไร?",
      "example": "Use .env files for configuration. Server-only vars: accessible in Server Components, Actions, Route Handlers. Client vars: prefix with NEXT_PUBLIC_ (inlined at build). Priority: .env.local > .env.development > .env. Use Zod for type-safe validation. Restart dev server after changes.",
      "exampleTranslation": "ใช้ .env files สำหรับ configuration Server-only vars: เข้าถึงได้ใน Server Components, Actions, Route Handlers Client vars: prefix ด้วย NEXT_PUBLIC_ (inlined ตอน build) Priority: .env.local > .env.development > .env ใช้ Zod สำหรับ type-safe validation Restart dev server หลังเปลี่ยน"
    },
    {
      "vocab": "What are the caching layers in Next.js?",
      "pronunciation": "memoization, data cache, route cache, router cache",
      "meaning": "Caching layers ใน Next.js มีอะไรบ้าง?",
      "example": "4 layers: 1) Request Memoization - dedupes same fetch in render, 2) Data Cache - persists fetch results, 3) Full Route Cache - caches rendered pages, 4) Router Cache - client-side cache for navigation. Opt out with cache: 'no-store', dynamic: 'force-dynamic'. Revalidate with revalidatePath/revalidateTag.",
      "exampleTranslation": "4 layers: 1) Request Memoization dedupe fetch เดียวกันใน render 2) Data Cache persist fetch results 3) Full Route Cache cache rendered pages 4) Router Cache client-side cache สำหรับ navigation Opt out ด้วย cache: 'no-store', dynamic: 'force-dynamic' Revalidate ด้วย revalidatePath/revalidateTag"
    },
    {
      "vocab": "How to deploy Next.js?",
      "pronunciation": "Vercel, output: 'standalone', output: 'export'",
      "meaning": "วิธี deploy Next.js ทำอย่างไร?",
      "example": "Vercel: zero-config, best integration, automatic previews. Self-host: npm run build, npm start with Node.js. Docker: use standalone output for minimal image. Static export: output: 'export' for static HTML (limited features). Edge: Vercel Edge, Cloudflare.",
      "exampleTranslation": "Vercel: zero-config, integration ดีที่สุด, automatic previews Self-host: npm run build, npm start กับ Node.js Docker: ใช้ standalone output สำหรับ minimal image Static export: output: 'export' สำหรับ static HTML (features จำกัด) Edge: Vercel Edge, Cloudflare"
    },
    {
      "vocab": "What is Turbopack?",
      "pronunciation": "next dev --turbo",
      "meaning": "Turbopack คืออะไร?",
      "example": "Turbopack is Rust-based bundler, successor to Webpack. 700x faster cold starts, 10x faster than Vite for large apps. Enable with --turbo flag. Stable for development in Next.js 15. Supports: TypeScript, CSS Modules, Tailwind, Server Components. Production still uses Webpack.",
      "exampleTranslation": "Turbopack คือ Rust-based bundler ที่สืบทอดจาก Webpack Cold starts เร็วกว่า 700x, เร็วกว่า Vite 10x สำหรับ large apps Enable ด้วย --turbo flag Stable สำหรับ development ใน Next.js 15 รองรับ: TypeScript, CSS Modules, Tailwind, Server Components Production ยังใช้ Webpack"
    },
    {
      "vocab": "What are common Next.js patterns?",
      "pronunciation": "",
      "meaning": "Next.js patterns ที่ใช้บ่อยมีอะไรบ้าง?",
      "example": "Common patterns: Server fetch + Client display, route groups for layouts, parallel fetching with Promise.all, Suspense streaming, optimistic updates, Server Action forms, URL state with searchParams, catch-all for CMS, intercepting routes for modals. Keep Client Components small.",
      "exampleTranslation": "Patterns ที่ใช้บ่อย: Server fetch + Client display, route groups สำหรับ layouts, parallel fetching ด้วย Promise.all, Suspense streaming, optimistic updates, Server Action forms, URL state ด้วย searchParams, catch-all สำหรับ CMS, intercepting routes สำหรับ modals Keep Client Components เล็ก"
    },
    {
      "vocab": "What are common Next.js mistakes to avoid?",
      "pronunciation": "",
      "meaning": "Next.js mistakes ที่ควรหลีกเลี่ยงมีอะไรบ้าง?",
      "example": "Avoid: unnecessary 'use client', not using Suspense for streaming, client fetching when server works, missing loading/error files, wrong cache config (always no-store), ignoring metadata, large client bundles. Keep components server by default. Use streaming for better UX.",
      "exampleTranslation": "หลีกเลี่ยง: 'use client' ที่ไม่จำเป็น, ไม่ใช้ Suspense สำหรับ streaming, client fetching เมื่อ server ใช้ได้, ไม่มี loading/error files, cache config ผิด (always no-store), ไม่ใส่ metadata, large client bundles Keep components เป็น server by default ใช้ streaming สำหรับ UX ที่ดีกว่า"
    }
  ]
}
