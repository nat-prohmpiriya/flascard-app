{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "Svelte Concepts",
    "description": "Core Svelte concepts including reactivity, components, stores, SvelteKit, and Svelte 5 runes",
    "category": "Programming",
    "tags": ["svelte", "sveltekit", "frontend", "javascript", "runes"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is Svelte and how is it different?",
      "pronunciation": "",
      "meaning": "Svelte คืออะไรและต่างจากอื่นอย่างไร?",
      "example": "Svelte is a compile-time framework that compiles components to efficient vanilla JavaScript at build time. No virtual DOM overhead. Key differences from React/Vue: smaller bundles, less boilerplate, true reactivity without hooks, scoped CSS by default, built-in animations.",
      "exampleTranslation": "Svelte คือ compile-time framework ที่ compile components เป็น vanilla JavaScript ที่มีประสิทธิภาพตอน build time ไม่มี virtual DOM overhead ต่างจาก React/Vue: bundles เล็กกว่า, boilerplate น้อยกว่า, true reactivity โดยไม่ต้อง hooks, scoped CSS default, built-in animations"
    },
    {
      "vocab": "How does reactivity work in Svelte?",
      "pronunciation": "$: doubled = count * 2",
      "meaning": "Reactivity ใน Svelte ทำงานอย่างไร?",
      "example": "In Svelte 4, variables are reactive by default. The $: prefix creates reactive statements that rerun when dependencies change. Arrays and objects need reassignment to trigger updates. Svelte 5 uses runes: $state() for reactive state, $derived() for computed values.",
      "exampleTranslation": "ใน Svelte 4 variables เป็น reactive by default $: prefix สร้าง reactive statements ที่รันใหม่เมื่อ dependencies เปลี่ยน Arrays และ objects ต้อง reassignment เพื่อ trigger updates Svelte 5 ใช้ runes: $state() สำหรับ reactive state, $derived() สำหรับ computed values"
    },
    {
      "vocab": "What are Svelte 5 Runes?",
      "pronunciation": "$state(), $derived(), $effect()",
      "meaning": "Svelte 5 Runes คืออะไร?",
      "example": "Runes are Svelte 5's new reactivity primitives. $state() creates reactive state with deep reactivity by default. $derived() creates computed values. $effect() handles side effects with automatic cleanup. $props() declares component props. More explicit than Svelte 4's implicit reactivity.",
      "exampleTranslation": "Runes คือ reactivity primitives ใหม่ของ Svelte 5 $state() สร้าง reactive state พร้อม deep reactivity by default $derived() สร้าง computed values $effect() จัดการ side effects พร้อม cleanup อัตโนมัติ $props() ประกาศ component props Explicit มากกว่า implicit reactivity ของ Svelte 4"
    },
    {
      "vocab": "How to handle Props in Svelte?",
      "pronunciation": "let { name, age = 0 } = $props()",
      "meaning": "วิธีจัดการ Props ใน Svelte ทำอย่างไร?",
      "example": "Svelte 4 uses export let to declare props with optional defaults. Svelte 5 uses $props() rune with destructuring. Spread props with {...props}. TypeScript: define interface for props. $bindable() enables two-way binding. Rest props with ...rest pattern.",
      "exampleTranslation": "Svelte 4 ใช้ export let ประกาศ props พร้อม optional defaults Svelte 5 ใช้ $props() rune กับ destructuring Spread props ด้วย {...props} TypeScript: define interface สำหรับ props $bindable() enable two-way binding Rest props ด้วย ...rest pattern"
    },
    {
      "vocab": "How to handle Events in Svelte?",
      "pronunciation": "on:click|preventDefault={handler}",
      "meaning": "วิธีจัดการ Events ใน Svelte ทำอย่างไร?",
      "example": "Use on:event for DOM events. Modifiers include |preventDefault, |stopPropagation, |once, |self, |capture and can be chained. Svelte 4 uses createEventDispatcher for component events. Svelte 5 prefers callback props (onEvent pattern).",
      "exampleTranslation": "ใช้ on:event สำหรับ DOM events Modifiers มี |preventDefault, |stopPropagation, |once, |self, |capture และ chain ได้ Svelte 4 ใช้ createEventDispatcher สำหรับ component events Svelte 5 ใช้ callback props แทน (onEvent pattern)"
    },
    {
      "vocab": "What are Bindings in Svelte?",
      "pronunciation": "bind:value, bind:checked, bind:this",
      "meaning": "Bindings ใน Svelte คืออะไร?",
      "example": "The bind: directive creates two-way data binding. Works with value (text inputs), checked (checkbox), group (radio/checkbox groups), this (element reference). Read-only bindings include clientWidth, clientHeight, scrollX, scrollY. Component binding passes value back to parent.",
      "exampleTranslation": "bind: directive สร้าง two-way data binding ใช้กับ value (text inputs), checked (checkbox), group (radio/checkbox groups), this (element reference) Read-only bindings มี clientWidth, clientHeight, scrollX, scrollY Component binding ส่งค่ากลับไป parent"
    },
    {
      "vocab": "How to use conditional rendering and loops?",
      "pronunciation": "{#if} {#each items as item (key)}",
      "meaning": "วิธีใช้ conditional rendering และ loops ทำอย่างไร?",
      "example": "Use {#if}, {:else if}, {:else}, {/if} for conditionals. {#each items as item} for loops with optional index and key. Key is important for proper DOM updates. {:else} after each handles empty state. {#await} for promises with loading, success, error states.",
      "exampleTranslation": "{#if}, {:else if}, {:else}, {/if} สำหรับ conditionals {#each items as item} สำหรับ loops พร้อม optional index และ key Key สำคัญสำหรับ DOM updates ที่ถูกต้อง {:else} หลัง each สำหรับ empty state {#await} สำหรับ promises พร้อม loading, success, error states"
    },
    {
      "vocab": "What are Stores in Svelte?",
      "pronunciation": "writable, readable, derived",
      "meaning": "Stores ใน Svelte คืออะไร?",
      "example": "Stores are reactive state containers for sharing state across components. writable is read/write, readable is read-only for external sources, derived computes from other stores. Use $ prefix for auto-subscription in components. Custom stores return object with subscribe and custom methods.",
      "exampleTranslation": "Stores เป็น reactive state containers สำหรับ share state ข้าม components writable คือ read/write, readable คือ read-only สำหรับ external sources, derived คำนวณจาก stores อื่น ใช้ $ prefix สำหรับ auto-subscription ใน components Custom stores return object ที่มี subscribe และ custom methods"
    },
    {
      "vocab": "What are Lifecycle functions?",
      "pronunciation": "onMount, onDestroy, $effect",
      "meaning": "Lifecycle functions คืออะไร?",
      "example": "Svelte 4 has onMount (after mount, return cleanup), onDestroy (before destroy), beforeUpdate, afterUpdate. tick() waits for pending DOM updates. Svelte 5 uses $effect which runs on mount and when dependencies change, with optional cleanup return function.",
      "exampleTranslation": "Svelte 4 มี onMount (หลัง mount, return cleanup), onDestroy (ก่อน destroy), beforeUpdate, afterUpdate tick() รอ pending DOM updates Svelte 5 ใช้ $effect ซึ่งรันตอน mount และเมื่อ dependencies เปลี่ยน พร้อม optional cleanup return function"
    },
    {
      "vocab": "What are Transitions and Animations?",
      "pronunciation": "transition:fade, animate:flip",
      "meaning": "Transitions และ Animations คืออะไร?",
      "example": "Built-in transitions include fade, fly, slide, scale, blur, draw. Use transition: for both in and out, or separate with in: and out:. Customize with duration, delay, easing. flip handles list reordering animations. Motion stores tweened and spring provide smooth value changes.",
      "exampleTranslation": "Built-in transitions มี fade, fly, slide, scale, blur, draw ใช้ transition: สำหรับทั้ง in และ out หรือแยกด้วย in: และ out: Customize ด้วย duration, delay, easing flip จัดการ list reordering animations Motion stores tweened และ spring ให้ smooth value changes"
    },
    {
      "vocab": "What are Actions in Svelte?",
      "pronunciation": "use:actionName",
      "meaning": "Actions ใน Svelte คืออะไร?",
      "example": "Actions are functions that run when element is mounted using use:action directive. They receive node and optional parameters, returning object with update() for param changes and destroy() for cleanup. Great for reusable DOM behaviors like tooltips, click outside, intersection observer.",
      "exampleTranslation": "Actions เป็น functions ที่รันเมื่อ element ถูก mount โดยใช้ use:action directive รับ node และ optional parameters return object ที่มี update() สำหรับ param เปลี่ยน และ destroy() สำหรับ cleanup ดีสำหรับ reusable DOM behaviors เช่น tooltips, click outside, intersection observer"
    },
    {
      "vocab": "What are Slots in Svelte?",
      "pronunciation": "<slot /> <slot name=\"header\" />",
      "meaning": "Slots ใน Svelte คืออะไร?",
      "example": "Slots allow passing content to components. Default slot uses <slot />. Named slots use <slot name=\"x\" /> with slot=\"x\" on content. Fallback content goes inside slot tags. Slot props pass data back to parent with let: directive. $$slots object checks if slot has content.",
      "exampleTranslation": "Slots อนุญาตให้ส่ง content ไปยัง components Default slot ใช้ <slot /> Named slots ใช้ <slot name=\"x\" /> กับ slot=\"x\" บน content Fallback content ใส่ใน slot tags Slot props ส่ง data กลับไป parent ด้วย let: directive $$slots object check ว่า slot มี content"
    },
    {
      "vocab": "What is Context in Svelte?",
      "pronunciation": "setContext, getContext",
      "meaning": "Context ใน Svelte คืออะไร?",
      "example": "Context shares data with descendants without prop drilling. setContext(key, value) in parent, getContext(key) in child. Must be called during component init. Use symbols for private context. Combine with stores for reactive context. Simpler than React Context since no Provider component needed.",
      "exampleTranslation": "Context share data กับ descendants โดยไม่ต้อง prop drilling setContext(key, value) ใน parent, getContext(key) ใน child ต้องเรียกระหว่าง component init ใช้ symbols สำหรับ private context รวมกับ stores สำหรับ reactive context ง่ายกว่า React Context เพราะไม่ต้อง Provider component"
    },
    {
      "vocab": "What is SvelteKit?",
      "pronunciation": "",
      "meaning": "SvelteKit คืออะไร?",
      "example": "SvelteKit is the full-stack framework for Svelte, similar to Next.js for React. Features include file-based routing, SSR/SSG/SPA modes, server data loading, form actions, API routes. Special files: +page.svelte (page), +layout.svelte (layout), +page.server.ts (server load), +server.ts (API).",
      "exampleTranslation": "SvelteKit คือ full-stack framework สำหรับ Svelte เหมือน Next.js สำหรับ React Features มี file-based routing, SSR/SSG/SPA modes, server data loading, form actions, API routes Special files: +page.svelte (page), +layout.svelte (layout), +page.server.ts (server load), +server.ts (API)"
    },
    {
      "vocab": "How does routing work in SvelteKit?",
      "pronunciation": "[param] [...rest] [[optional]]",
      "meaning": "Routing ทำงานอย่างไรใน SvelteKit?",
      "example": "SvelteKit uses file-based routing in src/routes/. [param] for dynamic segments, [...rest] for catch-all, [[optional]] for optional parameters. +page.svelte is the page component. Access params in load function. Route groups with (name) don't affect URL. Layouts apply to nested routes.",
      "exampleTranslation": "SvelteKit ใช้ file-based routing ใน src/routes/ [param] สำหรับ dynamic segments, [...rest] สำหรับ catch-all, [[optional]] สำหรับ optional parameters +page.svelte คือ page component เข้าถึง params ใน load function Route groups ด้วย (name) ไม่กระทบ URL Layouts apply กับ nested routes"
    },
    {
      "vocab": "How to load data in SvelteKit?",
      "pronunciation": "+page.server.ts, +page.ts",
      "meaning": "วิธี load data ใน SvelteKit ทำอย่างไร?",
      "example": "Use +page.server.ts for server-only load (database, secrets). +page.ts for universal load (runs on server and client). Return object becomes data prop in page. +layout.server.ts provides shared data across routes. Load context includes params, fetch, cookies, url.",
      "exampleTranslation": "+page.server.ts สำหรับ server-only load (database, secrets) +page.ts สำหรับ universal load (รันบน server และ client) Return object กลายเป็น data prop ใน page +layout.server.ts ให้ shared data ข้าม routes Load context มี params, fetch, cookies, url"
    },
    {
      "vocab": "What are Form Actions in SvelteKit?",
      "pronunciation": "actions = { default, named }",
      "meaning": "Form Actions ใน SvelteKit คืออะไร?",
      "example": "Form actions handle form submissions on server. Define in +page.server.ts actions object. Default action or named with action=\"?/name\". Return data becomes form prop in page. fail() for validation errors. redirect() for navigation. use:enhance for progressive enhancement without full reload.",
      "exampleTranslation": "Form actions จัดการ form submissions บน server Define ใน +page.server.ts actions object Default action หรือ named ด้วย action=\"?/name\" Return data กลายเป็น form prop ใน page fail() สำหรับ validation errors redirect() สำหรับ navigation use:enhance สำหรับ progressive enhancement โดยไม่ reload"
    },
    {
      "vocab": "How to create API routes in SvelteKit?",
      "pronunciation": "+server.ts GET, POST, DELETE",
      "meaning": "วิธีสร้าง API routes ใน SvelteKit ทำอย่างไร?",
      "example": "Create +server.ts and export functions named after HTTP methods: GET, POST, PUT, DELETE. Access url.searchParams, request.json(), params. Return json() or Response. throw error() for errors, redirect() for redirects. Dynamic routes use [param] like pages.",
      "exampleTranslation": "สร้าง +server.ts และ export functions ตั้งชื่อตาม HTTP methods: GET, POST, PUT, DELETE เข้าถึง url.searchParams, request.json(), params Return json() หรือ Response throw error() สำหรับ errors, redirect() สำหรับ redirects Dynamic routes ใช้ [param] เหมือน pages"
    },
    {
      "vocab": "What are Hooks in SvelteKit?",
      "pronunciation": "handle, handleError",
      "meaning": "Hooks ใน SvelteKit คืออะไร?",
      "example": "Hooks intercept requests and responses. handle() runs for every request, great for auth and logging. Access event.cookies and event.locals. sequence() chains multiple handles. handleError() customizes error responses. event.locals passes data to load functions. Type locals in app.d.ts.",
      "exampleTranslation": "Hooks intercept requests และ responses handle() รันสำหรับทุก request ดีสำหรับ auth และ logging เข้าถึง event.cookies และ event.locals sequence() chain หลาย handles handleError() customize error responses event.locals ส่ง data ให้ load functions Type locals ใน app.d.ts"
    },
    {
      "vocab": "How to handle component composition in Svelte?",
      "pronunciation": "{#snippet} {@render}",
      "meaning": "วิธีจัดการ component composition ใน Svelte ทำอย่างไร?",
      "example": "Svelte 5 introduces snippets for reusable markup: {#snippet name(params)}...{/snippet}, rendered with {@render}. Pass snippets as props for render props pattern. Special elements include svelte:component (dynamic), svelte:element (dynamic tag), svelte:window/document/body for events.",
      "exampleTranslation": "Svelte 5 แนะนำ snippets สำหรับ reusable markup: {#snippet name(params)}...{/snippet} render ด้วย {@render} ส่ง snippets เป็น props สำหรับ render props pattern Special elements มี svelte:component (dynamic), svelte:element (dynamic tag), svelte:window/document/body สำหรับ events"
    },
    {
      "vocab": "What are common Svelte patterns?",
      "pronunciation": "class:name, style:prop, $$restProps",
      "meaning": "Svelte patterns ที่ใช้บ่อยมีอะไรบ้าง?",
      "example": "Common patterns include class:name directive for conditional classes, style:prop for dynamic styles, $$restProps for forwarding props, context=\"module\" for shared state, keyed each with animations, $ prefix for store auto-subscribe, derived stores for transformations.",
      "exampleTranslation": "Patterns ที่ใช้บ่อยมี class:name directive สำหรับ conditional classes, style:prop สำหรับ dynamic styles, $$restProps สำหรับ forwarding props, context=\"module\" สำหรับ shared state, keyed each กับ animations, $ prefix สำหรับ store auto-subscribe, derived stores สำหรับ transformations"
    }
  ]
}
