{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "React Concepts",
    "description": "Core React concepts including hooks, state management, performance optimization, patterns, and React 19 features",
    "category": "Programming",
    "tags": ["react", "javascript", "frontend", "hooks", "concepts"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is React and the Virtual DOM?",
      "pronunciation": "// React: UI library by Meta\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\n\nfunction App() {\n  return <h1>Hello React!</h1>;\n}\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n// Virtual DOM concept:\n// 1. Component renders → creates Virtual DOM tree\n// 2. State changes → new Virtual DOM created\n// 3. React compares (diffs) old vs new Virtual DOM\n// 4. Only changed parts update Real DOM\n\n// Example: Only the count span updates\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <h1>Counter App</h1>  {/* doesn't re-render in DOM */}\n      <span>{count}</span>   {/* only this updates */}\n      <button onClick={() => setCount(c => c + 1)}>+</button>\n    </div>\n  );\n}",
      "meaning": "React และ Virtual DOM คืออะไร?",
      "example": "React is a JavaScript library for building user interfaces with components. Virtual DOM is an in-memory representation of Real DOM. When state changes, React creates new Virtual DOM, diffs with old one (reconciliation), and only updates changed parts in Real DOM. This makes updates efficient - no full page re-renders.",
      "exampleTranslation": "React คือ JavaScript library สำหรับสร้าง user interfaces ด้วย components Virtual DOM คือ in-memory representation ของ Real DOM เมื่อ state เปลี่ยน React สร้าง Virtual DOM ใหม่ diff กับอันเก่า (reconciliation) และ update เฉพาะส่วนที่เปลี่ยนใน Real DOM ทำให้ updates มีประสิทธิภาพ - ไม่ต้อง re-render ทั้งหน้า"
    },
    {
      "vocab": "What is JSX?",
      "pronunciation": "// JSX: JavaScript XML - syntax extension\nconst element = <h1>Hello, World!</h1>;\n\n// JSX compiles to:\nconst element = React.createElement('h1', null, 'Hello, World!');\n\n// Embedding expressions with {}\nconst name = 'John';\nconst greeting = <h1>Hello, {name}!</h1>;\nconst math = <p>2 + 2 = {2 + 2}</p>;\n\n// Attributes\nconst link = <a href=\"https://react.dev\">React</a>;\nconst input = <input className=\"field\" type=\"text\" />;\n\n// camelCase for attributes\n<div className=\"container\">  {/* not 'class' */}\n<label htmlFor=\"input\">     {/* not 'for' */}\n<button onClick={handleClick}> {/* not 'onclick' */}\n\n// Inline styles as object\n<div style={{ color: 'red', fontSize: '16px' }}>\n\n// Must have single root or use Fragment\nreturn (\n  <>  {/* Fragment shorthand */}\n    <h1>Title</h1>\n    <p>Content</p>\n  </>\n);\n\n// Conditional rendering\n{isLoggedIn && <UserPanel />}\n{isAdmin ? <AdminView /> : <UserView />}",
      "meaning": "JSX คืออะไร?",
      "example": "JSX is syntax extension that looks like HTML in JavaScript. Compiles to React.createElement() calls. Use {} for JavaScript expressions. Differences from HTML: className (not class), htmlFor (not for), camelCase events (onClick). Styles as objects. Must return single element - use Fragment (<></>) for multiple. Makes component code readable.",
      "exampleTranslation": "JSX คือ syntax extension ที่ดูเหมือน HTML ใน JavaScript Compile เป็น React.createElement() calls ใช้ {} สำหรับ JavaScript expressions ต่างจาก HTML: className (ไม่ใช่ class), htmlFor (ไม่ใช่ for), camelCase events (onClick) Styles เป็น objects ต้อง return element เดียว - ใช้ Fragment (<></>) สำหรับหลายตัว ทำให้ component code อ่านง่าย"
    },
    {
      "vocab": "What are Components in React?",
      "pronunciation": "// Function Component (recommended)\nfunction Welcome({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\n// Arrow function component\nconst Welcome = ({ name }) => <h1>Hello, {name}!</h1>;\n\n// Class Component (legacy, still works)\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}!</h1>;\n  }\n}\n\n// Using components\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Alice\" />\n      <Welcome name=\"Bob\" />\n    </div>\n  );\n}\n\n// Component rules:\n// 1. Name must start with capital letter\n// 2. Must return JSX (or null)\n// 3. Pure with respect to props\n\n// Composition\nfunction Card({ children, title }) {\n  return (\n    <div className=\"card\">\n      <h2>{title}</h2>\n      {children}\n    </div>\n  );\n}\n\n<Card title=\"User\">\n  <p>Card content here</p>\n</Card>",
      "meaning": "Components ใน React คืออะไร?",
      "example": "Components are reusable UI building blocks. Function components are recommended (simpler, hooks support). Class components still work but legacy. Must start with capital letter. Return JSX or null. Should be pure - same props = same output. Use composition with children prop for flexible layouts. Break UI into small, focused components.",
      "exampleTranslation": "Components คือ reusable UI building blocks Function components แนะนำ (ง่ายกว่า รองรับ hooks) Class components ยังใช้ได้แต่เป็น legacy ต้องขึ้นต้นด้วยตัวพิมพ์ใหญ่ Return JSX หรือ null ควรเป็น pure - props เดียวกัน = output เดียวกัน ใช้ composition ด้วย children prop สำหรับ layouts ที่ยืดหยุ่น แบ่ง UI เป็น components เล็กๆ ที่ focus"
    },
    {
      "vocab": "What are Props?",
      "pronunciation": "// Props: data passed from parent to child\nfunction Greeting({ name, age, isAdmin }) {\n  return (\n    <div>\n      <h1>Hello, {name}!</h1>\n      <p>Age: {age}</p>\n      {isAdmin && <span>Admin</span>}\n    </div>\n  );\n}\n\n// Passing props\n<Greeting name=\"John\" age={30} isAdmin={true} />\n<Greeting name=\"Jane\" age={25} isAdmin={false} />\n\n// Default props\nfunction Button({ variant = 'primary', children }) {\n  return <button className={variant}>{children}</button>;\n}\n\n// Spread props\nconst props = { name: 'John', age: 30 };\n<Greeting {...props} />\n\n// Children prop\nfunction Card({ children }) {\n  return <div className=\"card\">{children}</div>;\n}\n\n<Card>\n  <h1>Title</h1>\n  <p>Content</p>\n</Card>\n\n// Props are read-only!\nfunction Bad({ name }) {\n  name = 'Changed';  // ❌ Don't mutate props!\n}\n\n// TypeScript props\ninterface ButtonProps {\n  variant?: 'primary' | 'secondary';\n  onClick: () => void;\n  children: React.ReactNode;\n}",
      "meaning": "Props คืออะไร?",
      "example": "Props are read-only data passed from parent to child component. Destructure in function parameters. Can pass strings, numbers, booleans, objects, functions, JSX. Default values with = in destructuring. Spread operator for passing multiple props. children is special prop for nested content. Never mutate props - they're immutable.",
      "exampleTranslation": "Props คือ read-only data ที่ส่งจาก parent ไปยัง child component Destructure ใน function parameters ส่ง strings, numbers, booleans, objects, functions, JSX ได้ Default values ด้วย = ใน destructuring Spread operator สำหรับส่งหลาย props children เป็น special prop สำหรับ nested content ห้าม mutate props - มันเป็น immutable"
    },
    {
      "vocab": "What is useState hook?",
      "pronunciation": "import { useState } from 'react';\n\nfunction Counter() {\n  // [currentValue, setterFunction] = useState(initialValue)\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n      <button onClick={() => setCount(c => c - 1)}>-</button>\n    </div>\n  );\n}\n\n// Functional update (when new state depends on old)\nsetCount(prevCount => prevCount + 1);  // ✅ Always correct\nsetCount(count + 1);  // ⚠️ May be stale in async\n\n// Object state\nconst [user, setUser] = useState({ name: '', age: 0 });\n// Must spread to update (state is replaced, not merged)\nsetUser({ ...user, name: 'John' });  // ✅\nsetUser({ name: 'John' });  // ❌ Loses 'age'\n\n// Array state\nconst [items, setItems] = useState([]);\nsetItems([...items, newItem]);  // add\nsetItems(items.filter(i => i.id !== id));  // remove\nsetItems(items.map(i => i.id === id ? updated : i));  // update\n\n// Lazy initialization (expensive initial value)\nconst [data, setData] = useState(() => {\n  return computeExpensiveValue();\n});",
      "meaning": "useState hook คืออะไร?",
      "example": "useState adds state to function components. Returns [value, setter]. Setter triggers re-render. Use functional update (prev => new) when new state depends on old - avoids stale closure issues. For objects/arrays, create new reference (spread) since React uses shallow comparison. Lazy initializer for expensive computations.",
      "exampleTranslation": "useState เพิ่ม state ให้ function components Return [value, setter] Setter trigger re-render ใช้ functional update (prev => new) เมื่อ state ใหม่ขึ้นกับอันเก่า - หลีกเลี่ยง stale closure issues สำหรับ objects/arrays สร้าง reference ใหม่ (spread) เพราะ React ใช้ shallow comparison Lazy initializer สำหรับ expensive computations"
    },
    {
      "vocab": "What is useEffect hook?",
      "pronunciation": "import { useEffect, useState } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n\n  // Effect with cleanup\n  useEffect(() => {\n    // Setup: runs after render\n    const controller = new AbortController();\n    \n    fetch(`/api/users/${userId}`, { signal: controller.signal })\n      .then(res => res.json())\n      .then(data => setUser(data));\n\n    // Cleanup: runs before next effect or unmount\n    return () => {\n      controller.abort();\n    };\n  }, [userId]);  // Dependency array\n\n  return <div>{user?.name}</div>;\n}\n\n// Dependency array patterns:\nuseEffect(() => {}, []);        // Run once on mount\nuseEffect(() => {}, [a, b]);    // Run when a or b changes\nuseEffect(() => {});            // Run every render (rare)\n\n// Common use cases:\n// - Data fetching\n// - Subscriptions\n// - DOM manipulation\n// - Timers\n\n// ❌ Common mistakes:\nuseEffect(() => {\n  setCount(count + 1);  // Infinite loop!\n});\n\nuseEffect(() => {\n  // Missing userId in deps\n  fetch(`/api/users/${userId}`);\n}, []);  // ❌ Stale userId",
      "meaning": "useEffect hook คืออะไร?",
      "example": "useEffect handles side effects: data fetching, subscriptions, DOM manipulation. Runs after render. Dependency array controls when it runs: [] once on mount, [deps] when deps change, omit for every render. Return cleanup function for subscriptions/timers. Cleanup runs before next effect and on unmount. List all used values in deps.",
      "exampleTranslation": "useEffect จัดการ side effects: data fetching, subscriptions, DOM manipulation รันหลัง render Dependency array ควบคุมว่ารันเมื่อไหร่: [] ครั้งเดียวตอน mount, [deps] เมื่อ deps เปลี่ยน, ไม่ใส่สำหรับทุก render Return cleanup function สำหรับ subscriptions/timers Cleanup รันก่อน effect ถัดไปและตอน unmount ใส่ทุกค่าที่ใช้ใน deps"
    },
    {
      "vocab": "What is useContext hook?",
      "pronunciation": "import { createContext, useContext, useState } from 'react';\n\n// 1. Create context\nconst ThemeContext = createContext('light');  // default value\n\n// 2. Provider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const value = {\n    theme,\n    toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light'),\n  };\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 3. Consume with useContext\nfunction ThemedButton() {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n  \n  return (\n    <button \n      className={theme}\n      onClick={toggleTheme}\n    >\n      Current: {theme}\n    </button>\n  );\n}\n\n// 4. Wrap app with provider\nfunction App() {\n  return (\n    <ThemeProvider>\n      <ThemedButton />\n    </ThemeProvider>\n  );\n}\n\n// Custom hook pattern (recommended)\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}",
      "meaning": "useContext hook คืออะไร?",
      "example": "useContext provides way to pass data through component tree without prop drilling. Create context with createContext(), provide value with Provider, consume with useContext(). Good for: themes, user auth, locale. Create custom hook (useTheme) for better DX and error handling. Context changes trigger re-render in all consumers.",
      "exampleTranslation": "useContext ให้วิธีส่ง data ผ่าน component tree โดยไม่ต้อง prop drilling สร้าง context ด้วย createContext() ให้ value ด้วย Provider ใช้ด้วย useContext() ดีสำหรับ: themes, user auth, locale สร้าง custom hook (useTheme) สำหรับ DX ที่ดีกว่าและ error handling Context เปลี่ยน trigger re-render ใน consumers ทั้งหมด"
    },
    {
      "vocab": "What is useReducer hook?",
      "pronunciation": "import { useReducer } from 'react';\n\n// Reducer function: (state, action) => newState\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    case 'reset':\n      return { count: action.payload };\n    default:\n      throw new Error(`Unknown action: ${action.type}`);\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'reset', payload: 0 })}>\n        Reset\n      </button>\n    </div>\n  );\n}\n\n// Lazy initialization\nconst [state, dispatch] = useReducer(\n  reducer,\n  initialArg,\n  init  // init(initialArg) called once\n);\n\n// When to use useReducer vs useState:\n// - Complex state logic\n// - Next state depends on previous\n// - Multiple sub-values\n// - Easier testing (reducer is pure function)",
      "meaning": "useReducer hook คืออะไร?",
      "example": "useReducer manages complex state with reducer pattern. reducer(state, action) returns new state. dispatch(action) triggers state update. Better than useState for: complex logic, multiple sub-values, state depending on previous state. Reducer is pure function - easy to test. Often used with useContext for global state.",
      "exampleTranslation": "useReducer จัดการ complex state ด้วย reducer pattern reducer(state, action) return state ใหม่ dispatch(action) trigger state update ดีกว่า useState สำหรับ: complex logic, multiple sub-values, state ที่ขึ้นกับ previous state Reducer เป็น pure function - test ง่าย มักใช้กับ useContext สำหรับ global state"
    },
    {
      "vocab": "What is useMemo hook?",
      "pronunciation": "import { useMemo, useState } from 'react';\n\nfunction ExpensiveComponent({ items, filter }) {\n  // Memoize expensive computation\n  const filteredItems = useMemo(() => {\n    console.log('Filtering...');  // Only runs when deps change\n    return items.filter(item => item.name.includes(filter));\n  }, [items, filter]);  // Dependencies\n\n  return (\n    <ul>\n      {filteredItems.map(item => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n}\n\n// Without useMemo: filters on EVERY render\n// With useMemo: filters only when items or filter changes\n\n// Memoize object/array to maintain reference\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  // Without useMemo: new object every render\n  const config = { theme: 'dark' };  // ❌ New reference\n  \n  // With useMemo: same reference if deps unchanged\n  const config = useMemo(() => ({ theme: 'dark' }), []);  // ✅\n  \n  return <Child config={config} />;\n}\n\n// When to use:\n// - Expensive calculations\n// - Referential equality for props\n// - Dependency for other hooks\n\n// Don't overuse - memoization has cost too\n// Profile first, optimize second",
      "meaning": "useMemo hook คืออะไร?",
      "example": "useMemo memoizes computed values - recalculates only when dependencies change. Use for: expensive calculations, maintaining referential equality for object/array props. Returns cached value between renders. Don't overuse - memoization has memory/comparison cost. Profile first to identify real performance issues before adding useMemo.",
      "exampleTranslation": "useMemo memoize computed values - คำนวณใหม่เฉพาะเมื่อ dependencies เปลี่ยน ใช้สำหรับ: expensive calculations, รักษา referential equality สำหรับ object/array props Return cached value ระหว่าง renders อย่าใช้มากเกินไป - memoization มี memory/comparison cost Profile ก่อนเพื่อระบุ performance issues จริงก่อนเพิ่ม useMemo"
    },
    {
      "vocab": "What is useCallback hook?",
      "pronunciation": "import { useCallback, useState, memo } from 'react';\n\n// Child won't re-render if props unchanged\nconst ExpensiveChild = memo(function ExpensiveChild({ onClick }) {\n  console.log('Child rendered');\n  return <button onClick={onClick}>Click me</button>;\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // ❌ Without useCallback: new function every render\n  const handleClick = () => {\n    setCount(c => c + 1);\n  };\n\n  // ✅ With useCallback: same function reference\n  const handleClick = useCallback(() => {\n    setCount(c => c + 1);\n  }, []);  // Empty deps = never changes\n\n  // With dependencies\n  const handleSubmit = useCallback(() => {\n    console.log(text);  // Uses text\n  }, [text]);  // New function when text changes\n\n  return (\n    <div>\n      <input value={text} onChange={e => setText(e.target.value)} />\n      <ExpensiveChild onClick={handleClick} />\n      <p>Count: {count}</p>\n    </div>\n  );\n}\n\n// useCallback(fn, deps) is equivalent to:\n// useMemo(() => fn, deps)\n\n// When to use:\n// - Passing callbacks to memoized children\n// - Dependencies in useEffect\n// - Not needed for every function!",
      "meaning": "useCallback hook คืออะไร?",
      "example": "useCallback memoizes functions - returns same reference if dependencies unchanged. Use when passing callbacks to memoized children (React.memo) to prevent unnecessary re-renders. Also useful as dependency for useEffect. Equivalent to useMemo(() => fn, deps). Don't wrap every function - only when referential equality matters.",
      "exampleTranslation": "useCallback memoize functions - return reference เดิมถ้า dependencies ไม่เปลี่ยน ใช้เมื่อส่ง callbacks ให้ memoized children (React.memo) เพื่อป้องกัน re-renders ที่ไม่จำเป็น ยังมีประโยชน์เป็น dependency สำหรับ useEffect เทียบเท่า useMemo(() => fn, deps) อย่า wrap ทุก function - เฉพาะเมื่อ referential equality สำคัญ"
    },
    {
      "vocab": "What is useRef hook?",
      "pronunciation": "import { useRef, useEffect } from 'react';\n\n// 1. DOM reference\nfunction TextInput() {\n  const inputRef = useRef(null);\n\n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus</button>\n    </>\n  );\n}\n\n// 2. Mutable value that doesn't trigger re-render\nfunction Timer() {\n  const intervalRef = useRef(null);\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    intervalRef.current = setInterval(() => {\n      setCount(c => c + 1);\n    }, 1000);\n\n    return () => clearInterval(intervalRef.current);\n  }, []);\n\n  const stop = () => clearInterval(intervalRef.current);\n\n  return <button onClick={stop}>Stop ({count})</button>;\n}\n\n// 3. Previous value\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\n// Key differences from state:\n// - Changing ref.current doesn't trigger re-render\n// - Value persists across renders\n// - Mutable (can assign directly)\n\n// Common uses:\n// - DOM elements (input focus, scroll, measure)\n// - Storing interval/timeout IDs\n// - Previous values\n// - Instance variables",
      "meaning": "useRef hook คืออะไร?",
      "example": "useRef creates mutable container that persists across renders. Two main uses: 1) DOM references via ref attribute - access DOM methods like focus(), 2) Mutable values that don't trigger re-render - store interval IDs, previous values. Unlike state, changing .current doesn't cause re-render. Value persists between renders.",
      "exampleTranslation": "useRef สร้าง mutable container ที่คงอยู่ข้าม renders การใช้งานหลัก 2 อย่าง: 1) DOM references ผ่าน ref attribute - เข้าถึง DOM methods เช่น focus(), 2) Mutable values ที่ไม่ trigger re-render - เก็บ interval IDs, previous values ต่างจาก state การเปลี่ยน .current ไม่ทำให้ re-render Value คงอยู่ระหว่าง renders"
    },
    {
      "vocab": "What are Custom Hooks?",
      "pronunciation": "import { useState, useEffect } from 'react';\n\n// Custom hook: reusable stateful logic\nfunction useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    const saved = localStorage.getItem(key);\n    return saved ? JSON.parse(saved) : initialValue;\n  });\n\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue];\n}\n\n// Usage\nfunction App() {\n  const [name, setName] = useLocalStorage('name', '');\n  return <input value={name} onChange={e => setName(e.target.value)} />;\n}\n\n// More examples:\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    fetch(url)\n      .then(res => res.json())\n      .then(setData)\n      .catch(setError)\n      .finally(() => setLoading(false));\n  }, [url]);\n\n  return { data, loading, error };\n}\n\nfunction useToggle(initial = false) {\n  const [value, setValue] = useState(initial);\n  const toggle = useCallback(() => setValue(v => !v), []);\n  return [value, toggle];\n}\n\n// Rules:\n// 1. Name must start with 'use'\n// 2. Can call other hooks\n// 3. Follow Rules of Hooks",
      "meaning": "Custom Hooks คืออะไร?",
      "example": "Custom hooks extract reusable stateful logic. Name must start with 'use'. Can use other hooks inside. Share logic, not state - each component using hook gets own state. Common patterns: useLocalStorage, useFetch, useToggle, useDebounce, useMediaQuery. Great for abstracting complex logic and making components cleaner.",
      "exampleTranslation": "Custom hooks extract reusable stateful logic ชื่อต้องขึ้นต้นด้วย 'use' ใช้ hooks อื่นข้างในได้ Share logic ไม่ใช่ state - แต่ละ component ที่ใช้ hook ได้ state ของตัวเอง Patterns ที่พบบ่อย: useLocalStorage, useFetch, useToggle, useDebounce, useMediaQuery ดีสำหรับ abstracting complex logic และทำ components สะอาดขึ้น"
    },
    {
      "vocab": "What are the Rules of Hooks?",
      "pronunciation": "// Rule 1: Only call hooks at the top level\n// ❌ Don't call in conditions\nfunction Bad({ condition }) {\n  if (condition) {\n    const [value, setValue] = useState(0);  // ❌\n  }\n}\n\n// ❌ Don't call in loops\nfunction Bad({ items }) {\n  for (const item of items) {\n    useEffect(() => {});  // ❌\n  }\n}\n\n// ❌ Don't call in nested functions\nfunction Bad() {\n  const handleClick = () => {\n    const [state, setState] = useState(0);  // ❌\n  };\n}\n\n// ✅ Correct: always at top level\nfunction Good({ condition }) {\n  const [value, setValue] = useState(0);  // ✅\n  \n  useEffect(() => {\n    if (condition) {\n      // do something\n    }\n  }, [condition]);\n}\n\n// Rule 2: Only call hooks from React functions\n// ✅ Function components\n// ✅ Custom hooks\n// ❌ Regular JavaScript functions\n// ❌ Class components\n\n// Why these rules?\n// React relies on call ORDER to track hook state\n// Hooks must always be called in same order\n\n// ESLint plugin: eslint-plugin-react-hooks\n// \"react-hooks/rules-of-hooks\": \"error\"\n// \"react-hooks/exhaustive-deps\": \"warn\"",
      "meaning": "Rules of Hooks คืออะไร?",
      "example": "Two rules: 1) Only call hooks at top level - not in conditions, loops, or nested functions. 2) Only call from React functions - components or custom hooks. React tracks hooks by call order - must be same every render. Use eslint-plugin-react-hooks to catch violations. Put conditions inside hooks, not hooks inside conditions.",
      "exampleTranslation": "สองกฎ: 1) เรียก hooks ที่ top level เท่านั้น - ไม่ใช่ใน conditions, loops หรือ nested functions 2) เรียกจาก React functions เท่านั้น - components หรือ custom hooks React track hooks ด้วย call order - ต้องเหมือนกันทุก render ใช้ eslint-plugin-react-hooks เพื่อจับ violations ใส่ conditions ข้างใน hooks ไม่ใช่ hooks ข้างใน conditions"
    },
    {
      "vocab": "What is React.memo?",
      "pronunciation": "import { memo, useState } from 'react';\n\n// memo: skip re-render if props unchanged\nconst ExpensiveList = memo(function ExpensiveList({ items }) {\n  console.log('Rendering list...');\n  return (\n    <ul>\n      {items.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  );\n});\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [items] = useState([{ id: 1, name: 'Item 1' }]);\n\n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>\n        Count: {count}\n      </button>\n      {/* Won't re-render when count changes */}\n      <ExpensiveList items={items} />\n    </div>\n  );\n}\n\n// Custom comparison function\nconst MemoizedComponent = memo(\n  function Component({ user }) {\n    return <div>{user.name}</div>;\n  },\n  (prevProps, nextProps) => {\n    // Return true to skip re-render\n    return prevProps.user.id === nextProps.user.id;\n  }\n);\n\n// When to use memo:\n// - Component renders often with same props\n// - Component is expensive to render\n// - Parent re-renders frequently\n\n// When NOT to use:\n// - Props change frequently anyway\n// - Component is simple/cheap\n// - Premature optimization",
      "meaning": "React.memo คืออะไร?",
      "example": "React.memo is HOC that memoizes component - skips re-render if props unchanged (shallow comparison). Wrap functional components that render same output for same props. Use when: component renders often with same props, expensive render, frequent parent updates. Custom comparison function for deep comparison. Don't overuse - adds overhead.",
      "exampleTranslation": "React.memo คือ HOC ที่ memoize component - ข้าม re-render ถ้า props ไม่เปลี่ยน (shallow comparison) Wrap functional components ที่ render output เดิมสำหรับ props เดิม ใช้เมื่อ: component render บ่อยกับ props เดิม, render แพง, parent updates บ่อย Custom comparison function สำหรับ deep comparison อย่าใช้มากเกินไป - เพิ่ม overhead"
    },
    {
      "vocab": "What are Controlled vs Uncontrolled Components?",
      "pronunciation": "import { useState, useRef } from 'react';\n\n// Controlled: React controls the value\nfunction ControlledForm() {\n  const [value, setValue] = useState('');\n\n  const handleChange = (e) => {\n    setValue(e.target.value);  // React controls value\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitted:', value);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        value={value}           // Controlled by state\n        onChange={handleChange}  // Update state on change\n      />\n      <button>Submit</button>\n    </form>\n  );\n}\n\n// Uncontrolled: DOM controls the value\nfunction UncontrolledForm() {\n  const inputRef = useRef(null);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitted:', inputRef.current.value);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        ref={inputRef}           // Access via ref\n        defaultValue=\"initial\"   // Initial value only\n      />\n      <button>Submit</button>\n    </form>\n  );\n}\n\n// Controlled: instant validation, conditional disable\n// Uncontrolled: simpler, less code, integrating non-React\n\n// File input is always uncontrolled\n<input type=\"file\" ref={fileRef} />",
      "meaning": "Controlled vs Uncontrolled Components คืออะไร?",
      "example": "Controlled: React state is source of truth. value + onChange make React control input. Enables instant validation, formatting, conditional logic. Uncontrolled: DOM is source of truth. Use ref to read value. defaultValue for initial. Simpler but less control. File inputs always uncontrolled. Prefer controlled for most cases.",
      "exampleTranslation": "Controlled: React state เป็น source of truth value + onChange ทำให้ React control input Enable instant validation, formatting, conditional logic Uncontrolled: DOM เป็น source of truth ใช้ ref เพื่ออ่านค่า defaultValue สำหรับค่าเริ่มต้น ง่ายกว่าแต่ control น้อยกว่า File inputs เป็น uncontrolled เสมอ ใช้ controlled สำหรับกรณีส่วนใหญ่"
    },
    {
      "vocab": "What are Error Boundaries?",
      "pronunciation": "import { Component } from 'react';\n\n// Error Boundary: catch JS errors in child tree\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  // Update state on error\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  // Log error\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught:', error, errorInfo);\n    // Send to error tracking service\n    logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div>\n          <h2>Something went wrong.</h2>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </button>\n        </div>\n      );\n    }\n    return this.props.children;\n  }\n}\n\n// Usage\n<ErrorBoundary>\n  <ComponentThatMightError />\n</ErrorBoundary>\n\n// Multiple boundaries for granular handling\n<ErrorBoundary fallback={<AppError />}>\n  <Header />\n  <ErrorBoundary fallback={<ContentError />}>\n    <MainContent />\n  </ErrorBoundary>\n</ErrorBoundary>\n\n// Does NOT catch:\n// - Event handlers (use try-catch)\n// - Async code (promises)\n// - Server-side rendering\n// - Errors in error boundary itself",
      "meaning": "Error Boundaries คืออะไร?",
      "example": "Error Boundaries are class components that catch JavaScript errors in child component tree. Use getDerivedStateFromError for fallback UI, componentDidCatch for logging. Don't catch: event handlers, async code, SSR, self errors. Must be class component (no hooks equivalent yet). Wrap sections of app for granular error handling.",
      "exampleTranslation": "Error Boundaries คือ class components ที่ catch JavaScript errors ใน child component tree ใช้ getDerivedStateFromError สำหรับ fallback UI, componentDidCatch สำหรับ logging ไม่ catch: event handlers, async code, SSR, self errors ต้องเป็น class component (ยังไม่มี hooks equivalent) Wrap sections ของ app สำหรับ granular error handling"
    },
    {
      "vocab": "What are Portals?",
      "pronunciation": "import { createPortal } from 'react-dom';\n\n// Portal: render children into different DOM node\nfunction Modal({ children, isOpen }) {\n  if (!isOpen) return null;\n\n  return createPortal(\n    <div className=\"modal-overlay\">\n      <div className=\"modal-content\">\n        {children}\n      </div>\n    </div>,\n    document.getElementById('modal-root')  // Target DOM node\n  );\n}\n\n// HTML\n// <body>\n//   <div id=\"root\">...app...</div>\n//   <div id=\"modal-root\"></div>  <!-- Modal renders here -->\n// </body>\n\n// Usage\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowModal(true)}>Open Modal</button>\n      <Modal isOpen={showModal}>\n        <h2>Modal Title</h2>\n        <button onClick={() => setShowModal(false)}>Close</button>\n      </Modal>\n    </div>\n  );\n}\n\n// Key points:\n// - Events still bubble up through React tree (not DOM tree)\n// - Context still works\n// - Child of React component, but rendered elsewhere in DOM\n\n// Use cases:\n// - Modals, dialogs\n// - Tooltips, popovers\n// - Floating menus\n// - Avoiding CSS overflow/z-index issues",
      "meaning": "Portals คืออะไร?",
      "example": "Portals render children into DOM node outside parent hierarchy. Use createPortal(children, domNode). Child is still part of React tree - events bubble up, context works. Useful for modals, tooltips, dropdowns - avoids CSS overflow:hidden and z-index issues. HTML needs target container element.",
      "exampleTranslation": "Portals render children เข้าไปใน DOM node นอก parent hierarchy ใช้ createPortal(children, domNode) Child ยังเป็นส่วนของ React tree - events bubble up, context ใช้งานได้ มีประโยชน์สำหรับ modals, tooltips, dropdowns - หลีกเลี่ยงปัญหา CSS overflow:hidden และ z-index HTML ต้องมี target container element"
    },
    {
      "vocab": "What is Suspense and lazy loading?",
      "pronunciation": "import { Suspense, lazy } from 'react';\n\n// lazy: code-split component\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\nconst Dashboard = lazy(() => import('./Dashboard'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <HeavyComponent />\n    </Suspense>\n  );\n}\n\n// Route-based code splitting\nfunction App() {\n  return (\n    <Suspense fallback={<PageLoader />}>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n      </Routes>\n    </Suspense>\n  );\n}\n\n// Nested Suspense for granular loading\nfunction App() {\n  return (\n    <Suspense fallback={<AppSkeleton />}>\n      <Header />\n      <Suspense fallback={<ContentSkeleton />}>\n        <MainContent />\n      </Suspense>\n      <Suspense fallback={<SidebarSkeleton />}>\n        <Sidebar />\n      </Suspense>\n    </Suspense>\n  );\n}\n\n// Suspense for data fetching (React 18+)\n// Works with libraries that support Suspense\n// - React Query\n// - SWR\n// - Relay\n\n// Named exports\nconst MyComponent = lazy(() => \n  import('./MyComponent').then(module => ({ default: module.MyComponent }))\n);",
      "meaning": "Suspense และ lazy loading คืออะไร?",
      "example": "lazy() enables code-splitting - component code loads on demand. Suspense shows fallback while lazy component loads. Use for route-based splitting, heavy components. Nested Suspense for granular loading states. Also works with data fetching libraries (React Query, SWR). Reduces initial bundle size, faster first load.",
      "exampleTranslation": "lazy() enable code-splitting - component code โหลดตามต้องการ Suspense แสดง fallback ขณะ lazy component โหลด ใช้สำหรับ route-based splitting, heavy components Nested Suspense สำหรับ granular loading states ยังใช้กับ data fetching libraries (React Query, SWR) ลด initial bundle size, first load เร็วขึ้น"
    },
    {
      "vocab": "What is useTransition hook?",
      "pronunciation": "import { useState, useTransition } from 'react';\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e) => {\n    const value = e.target.value;\n    \n    // Urgent: update input immediately\n    setQuery(value);\n    \n    // Non-urgent: can be interrupted\n    startTransition(() => {\n      // Expensive operation\n      const filtered = largeList.filter(item => \n        item.name.includes(value)\n      );\n      setResults(filtered);\n    });\n  };\n\n  return (\n    <div>\n      <input value={query} onChange={handleChange} />\n      {isPending && <span>Updating...</span>}\n      <ul>\n        {results.map(item => <li key={item.id}>{item.name}</li>)}\n      </ul>\n    </div>\n  );\n}\n\n// Without useTransition:\n// - Typing feels sluggish\n// - UI blocks during filtering\n\n// With useTransition:\n// - Input stays responsive\n// - Filtering happens in background\n// - Can be interrupted by new input\n\n// isPending: show loading indicator\n// startTransition: mark update as non-urgent\n\n// Use cases:\n// - Search/filter large lists\n// - Tab switching with heavy content\n// - Any non-urgent UI updates",
      "meaning": "useTransition hook คืออะไร?",
      "example": "useTransition marks state updates as non-urgent (transitions). Returns [isPending, startTransition]. Wrap slow updates in startTransition - keeps UI responsive. React can interrupt transition for urgent updates (typing). isPending shows loading state. Use for: filtering large lists, tab switching, heavy renders. Part of React 18 concurrent features.",
      "exampleTranslation": "useTransition mark state updates ว่า non-urgent (transitions) Return [isPending, startTransition] Wrap slow updates ใน startTransition - ให้ UI responsive React สามารถ interrupt transition สำหรับ urgent updates (typing) isPending แสดง loading state ใช้สำหรับ: filtering large lists, tab switching, heavy renders เป็นส่วนของ React 18 concurrent features"
    },
    {
      "vocab": "What is useDeferredValue hook?",
      "pronunciation": "import { useState, useDeferredValue, useMemo } from 'react';\n\nfunction SearchResults({ query }) {\n  // Deferred value lags behind\n  const deferredQuery = useDeferredValue(query);\n  \n  // Only re-compute when deferredQuery changes\n  const results = useMemo(() => {\n    return largeList.filter(item => \n      item.name.includes(deferredQuery)\n    );\n  }, [deferredQuery]);\n\n  // Show stale content is updating\n  const isStale = query !== deferredQuery;\n\n  return (\n    <div style={{ opacity: isStale ? 0.5 : 1 }}>\n      {results.map(item => <li key={item.id}>{item.name}</li>)}\n    </div>\n  );\n}\n\nfunction App() {\n  const [query, setQuery] = useState('');\n\n  return (\n    <div>\n      <input \n        value={query} \n        onChange={e => setQuery(e.target.value)} \n      />\n      <SearchResults query={query} />\n    </div>\n  );\n}\n\n// useDeferredValue vs useTransition:\n//\n// useTransition:\n// - Wraps setState call\n// - You control when to defer\n//\n// useDeferredValue:\n// - Wraps a value (often prop)\n// - Defers value coming from outside\n// - Simpler API for prop deferral",
      "meaning": "useDeferredValue hook คืออะไร?",
      "example": "useDeferredValue creates deferred version of a value that 'lags behind'. During urgent updates, returns old value - prevents expensive re-renders. Compare current vs deferred to show stale indicator. Simpler than useTransition when deferring props. Both are concurrent features for keeping UI responsive during heavy updates.",
      "exampleTranslation": "useDeferredValue สร้าง deferred version ของค่าที่ 'lags behind' ระหว่าง urgent updates return ค่าเก่า - ป้องกัน expensive re-renders เปรียบเทียบ current vs deferred เพื่อแสดง stale indicator ง่ายกว่า useTransition เมื่อ deferring props ทั้งคู่เป็น concurrent features สำหรับให้ UI responsive ระหว่าง heavy updates"
    },
    {
      "vocab": "What is forwardRef?",
      "pronunciation": "import { forwardRef, useRef, useImperativeHandle } from 'react';\n\n// forwardRef: pass ref to child component\nconst FancyInput = forwardRef(function FancyInput(props, ref) {\n  return <input ref={ref} className=\"fancy\" {...props} />;\n});\n\nfunction Parent() {\n  const inputRef = useRef(null);\n\n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <>\n      <FancyInput ref={inputRef} placeholder=\"Type here\" />\n      <button onClick={focusInput}>Focus</button>\n    </>\n  );\n}\n\n// useImperativeHandle: customize exposed ref\nconst FancyInput = forwardRef(function FancyInput(props, ref) {\n  const inputRef = useRef(null);\n\n  // Expose custom API instead of raw DOM\n  useImperativeHandle(ref, () => ({\n    focus: () => inputRef.current.focus(),\n    clear: () => { inputRef.current.value = ''; },\n    getValue: () => inputRef.current.value,\n  }), []);\n\n  return <input ref={inputRef} {...props} />;\n});\n\n// Usage\nfunction Parent() {\n  const inputRef = useRef(null);\n  \n  const handleClick = () => {\n    inputRef.current.focus();  // Custom method\n    inputRef.current.clear();  // Custom method\n  };\n\n  return <FancyInput ref={inputRef} />;\n}",
      "meaning": "forwardRef คืออะไร?",
      "example": "forwardRef allows passing ref through component to child DOM element. Wrap component with forwardRef((props, ref) => ...). Use when building reusable input components, focus management. useImperativeHandle customizes the ref value - expose specific methods instead of raw DOM. Combine for encapsulated component APIs.",
      "exampleTranslation": "forwardRef อนุญาตให้ส่ง ref ผ่าน component ไปยัง child DOM element Wrap component ด้วย forwardRef((props, ref) => ...) ใช้เมื่อสร้าง reusable input components, focus management useImperativeHandle customize ref value - expose specific methods แทน raw DOM รวมกันสำหรับ encapsulated component APIs"
    },
    {
      "vocab": "What are Higher-Order Components (HOC)?",
      "pronunciation": "// HOC: function that takes component, returns enhanced component\nfunction withLoading(WrappedComponent) {\n  return function WithLoadingComponent({ isLoading, ...props }) {\n    if (isLoading) {\n      return <div>Loading...</div>;\n    }\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Usage\nconst UserListWithLoading = withLoading(UserList);\n<UserListWithLoading isLoading={loading} users={users} />\n\n// withAuth HOC\nfunction withAuth(WrappedComponent) {\n  return function WithAuthComponent(props) {\n    const { user } = useAuth();\n    \n    if (!user) {\n      return <Navigate to=\"/login\" />;\n    }\n    \n    return <WrappedComponent {...props} user={user} />;\n  };\n}\n\nconst ProtectedDashboard = withAuth(Dashboard);\n\n// Conventions:\n// - Name: withXxx\n// - Pass through unrelated props\n// - Don't mutate original component\n// - Use display name for debugging\n\nWithLoadingComponent.displayName = \n  `withLoading(${WrappedComponent.displayName || WrappedComponent.name})`;\n\n// Modern alternative: Custom Hooks\n// HOCs still useful for cross-cutting concerns\n// But hooks are often simpler",
      "meaning": "Higher-Order Components (HOC) คืออะไร?",
      "example": "HOC is function that takes component and returns enhanced component. Pattern for reusing component logic: loading states, auth, theming. Convention: withXxx naming. Pass through unrelated props. Modern alternative: custom hooks often simpler. HOCs still useful for: wrapping with providers, cross-cutting concerns, class component logic reuse.",
      "exampleTranslation": "HOC คือ function ที่รับ component และ return enhanced component Pattern สำหรับ reuse component logic: loading states, auth, theming Convention: withXxx naming ส่งต่อ unrelated props Alternative สมัยใหม่: custom hooks มักง่ายกว่า HOCs ยังมีประโยชน์สำหรับ: wrapping with providers, cross-cutting concerns, class component logic reuse"
    },
    {
      "vocab": "What is the key prop and why is it important?",
      "pronunciation": "// key: unique identifier for list items\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>  {/* Unique key */}\n          {todo.text}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// ❌ Bad: using index as key\n{items.map((item, index) => (\n  <Item key={index} data={item} />  // Problems when reordering\n))}\n\n// ❌ Bad: no key\n{items.map(item => (\n  <Item data={item} />  // Warning + performance issues\n))}\n\n// Why keys matter:\n// 1. React identifies which items changed\n// 2. Preserves component state correctly\n// 3. Efficient DOM updates\n\n// Index as key problems:\nconst [items, setItems] = useState(['A', 'B', 'C']);\n// Delete 'A' → ['B', 'C']\n// With index keys: React thinks B is still at index 0\n// Input state, focus, etc. gets messed up\n\n// Force remount with key\nfunction Profile({ userId }) {\n  // Change key → component remounts, state resets\n  return <UserProfile key={userId} userId={userId} />;\n}\n\n// Key rules:\n// - Unique among siblings (not globally)\n// - Stable (don't use Math.random())\n// - Ideally from your data (id, slug)",
      "meaning": "key prop คืออะไรและทำไมสำคัญ?",
      "example": "key helps React identify list items for efficient updates. Must be unique among siblings and stable. Use data IDs, not array index (causes bugs when reordering/deleting). Without keys: performance issues, wrong state preservation. Changing key forces component remount - useful for resetting state. Keys only needed in arrays/iterators.",
      "exampleTranslation": "key ช่วย React ระบุ list items สำหรับ efficient updates ต้อง unique ระหว่าง siblings และ stable ใช้ data IDs ไม่ใช่ array index (ทำให้เกิด bugs เมื่อ reordering/deleting) ไม่มี keys: performance issues, state preservation ผิด เปลี่ยน key บังคับ component remount - มีประโยชน์สำหรับ resetting state Keys ต้องการเฉพาะใน arrays/iterators"
    },
    {
      "vocab": "What are Server Components in React 19?",
      "pronunciation": "// Server Components: render on server, zero client JS\n// File naming convention:\n// - Component.tsx (default: server in App Router)\n// - Component.client.tsx or 'use client'\n\n// Server Component (default in Next.js App Router)\nasync function ProductList() {\n  // Can use async/await directly\n  const products = await db.query('SELECT * FROM products');\n  \n  // Can access server-only resources\n  const secret = process.env.API_SECRET;\n\n  return (\n    <ul>\n      {products.map(p => (\n        <li key={p.id}>{p.name}</li>\n      ))}\n    </ul>\n  );\n}\n\n// Client Component\n'use client';  // Mark as client component\n\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;\n}\n\n// Mixing: Server can import Client, not vice versa\nasync function Page() {\n  const data = await fetchData();  // Server\n  return (\n    <div>\n      <h1>{data.title}</h1>        {/* Server */}\n      <Counter />                   {/* Client */}\n      <Comments data={data.comments} />  {/* Pass data to client */}\n    </div>\n  );\n}\n\n// Benefits:\n// - Zero client bundle for server components\n// - Direct database/filesystem access\n// - Automatic code splitting\n// - Streaming & progressive rendering",
      "meaning": "Server Components ใน React 19 คืออะไร?",
      "example": "Server Components render on server with zero client JavaScript. Can use async/await, access databases, secrets directly. 'use client' marks client components (need interactivity, hooks, browser APIs). Server imports client, not vice versa. Benefits: smaller bundles, direct data access, better performance. Used in Next.js App Router by default.",
      "exampleTranslation": "Server Components render บน server ด้วย client JavaScript เป็นศูนย์ ใช้ async/await, เข้าถึง databases, secrets ได้โดยตรง 'use client' mark client components (ต้องการ interactivity, hooks, browser APIs) Server import client ไม่ใช่กลับกัน ข้อดี: bundles เล็กลง, direct data access, performance ดีกว่า ใช้ใน Next.js App Router โดย default"
    },
    {
      "vocab": "What is the use() hook in React 19?",
      "pronunciation": "import { use, Suspense } from 'react';\n\n// use(): read resources (promises, context) during render\nasync function fetchUser(id) {\n  const res = await fetch(`/api/users/${id}`);\n  return res.json();\n}\n\nfunction UserProfile({ userPromise }) {\n  // use() unwraps the promise\n  const user = use(userPromise);  // Suspends until resolved\n  \n  return <div>{user.name}</div>;\n}\n\nfunction App() {\n  const userPromise = fetchUser(1);  // Start fetching\n  \n  return (\n    <Suspense fallback={<Loading />}>\n      <UserProfile userPromise={userPromise} />\n    </Suspense>\n  );\n}\n\n// use() with Context (can call conditionally!)\nfunction Component({ showTheme }) {\n  if (showTheme) {\n    const theme = use(ThemeContext);  // ✅ Conditional OK!\n    return <div className={theme}>...</div>;\n  }\n  return <div>No theme</div>;\n}\n\n// Unlike other hooks:\n// - Can be called conditionally\n// - Can be called in loops\n// - Only works with Suspense-compatible resources\n\n// use() vs useContext:\n// - use() can be conditional\n// - use() works with promises too\n// - useContext still valid for non-conditional",
      "meaning": "use() hook ใน React 19 คืออะไร?",
      "example": "use() reads resources during render - unwraps Promises and Context. Unlike other hooks, CAN be called conditionally or in loops. With Promises: suspends component until resolved, use with Suspense. Replaces some useEffect data fetching patterns. Simpler than useContext for conditional context reading. React 19 feature.",
      "exampleTranslation": "use() อ่าน resources ระหว่าง render - unwrap Promises และ Context ต่างจาก hooks อื่น สามารถเรียกแบบ conditional หรือใน loops ได้ กับ Promises: suspend component จนกว่าจะ resolved ใช้กับ Suspense แทนที่ useEffect data fetching patterns บางส่วน ง่ายกว่า useContext สำหรับ conditional context reading เป็น React 19 feature"
    },
    {
      "vocab": "What are Actions and useActionState in React 19?",
      "pronunciation": "import { useActionState } from 'react';\n\n// Action: async function for form submission\nasync function submitForm(prevState, formData) {\n  const name = formData.get('name');\n  \n  try {\n    await saveToDatabase({ name });\n    return { success: true, message: 'Saved!' };\n  } catch (error) {\n    return { success: false, message: error.message };\n  }\n}\n\nfunction Form() {\n  const [state, formAction, isPending] = useActionState(\n    submitForm,\n    { success: false, message: '' }  // Initial state\n  );\n\n  return (\n    <form action={formAction}>\n      <input name=\"name\" required />\n      <button disabled={isPending}>\n        {isPending ? 'Saving...' : 'Save'}\n      </button>\n      {state.message && (\n        <p className={state.success ? 'success' : 'error'}>\n          {state.message}\n        </p>\n      )}\n    </form>\n  );\n}\n\n// Works with Server Actions in Next.js\n// 'use server'\nasync function createPost(prevState, formData) {\n  // Runs on server\n}\n\n// Benefits:\n// - No manual state for loading/error\n// - Progressive enhancement (works without JS)\n// - Integrated with Suspense\n// - Automatic form reset on success",
      "meaning": "Actions และ useActionState ใน React 19 คืออะไร?",
      "example": "Actions are async functions handling form submissions. useActionState manages action state: [state, action, isPending]. Replaces manual useState for loading/error. Works with form action attribute. Supports Server Actions (Next.js). Benefits: simpler forms, progressive enhancement, automatic pending state. isPending for loading UI.",
      "exampleTranslation": "Actions คือ async functions ที่จัดการ form submissions useActionState จัดการ action state: [state, action, isPending] แทนที่ manual useState สำหรับ loading/error ใช้กับ form action attribute รองรับ Server Actions (Next.js) ข้อดี: forms ง่ายขึ้น, progressive enhancement, automatic pending state isPending สำหรับ loading UI"
    },
    {
      "vocab": "What is useOptimistic hook?",
      "pronunciation": "import { useOptimistic, useState } from 'react';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  \n  // Optimistic state for immediate UI update\n  const [optimisticTodos, addOptimistic] = useOptimistic(\n    todos,\n    (state, newTodo) => [...state, { ...newTodo, pending: true }]\n  );\n\n  async function addTodo(formData) {\n    const title = formData.get('title');\n    const newTodo = { id: Date.now(), title };\n    \n    // Update UI immediately\n    addOptimistic(newTodo);\n    \n    try {\n      // Actual server request\n      const saved = await saveTodo(newTodo);\n      setTodos(current => [...current, saved]);\n    } catch (error) {\n      // Optimistic update auto-reverts on error\n      console.error('Failed to save');\n    }\n  }\n\n  return (\n    <form action={addTodo}>\n      <input name=\"title\" />\n      <button>Add</button>\n      <ul>\n        {optimisticTodos.map(todo => (\n          <li key={todo.id} style={{ opacity: todo.pending ? 0.5 : 1 }}>\n            {todo.title}\n          </li>\n        ))}\n      </ul>\n    </form>\n  );\n}\n\n// Benefits:\n// - Instant UI feedback\n// - Automatic rollback on error\n// - Works with form actions\n// - Better perceived performance",
      "meaning": "useOptimistic hook คืออะไร?",
      "example": "useOptimistic enables optimistic UI updates - show result before server confirms. Returns [optimisticState, addOptimistic]. Update immediately with addOptimistic, then sync with server. Automatically reverts on error. Show pending state with flag. Great for: likes, adds, deletes - instant feedback. React 19 feature for better UX.",
      "exampleTranslation": "useOptimistic enable optimistic UI updates - แสดงผลก่อน server ยืนยัน Return [optimisticState, addOptimistic] Update ทันทีด้วย addOptimistic แล้ว sync กับ server Revert อัตโนมัติเมื่อ error แสดง pending state ด้วย flag ดีสำหรับ: likes, adds, deletes - instant feedback เป็น React 19 feature สำหรับ UX ที่ดีกว่า"
    },
    {
      "vocab": "What is useId hook?",
      "pronunciation": "import { useId } from 'react';\n\nfunction FormField({ label }) {\n  // Generate unique ID\n  const id = useId();\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input id={id} type=\"text\" />\n    </div>\n  );\n}\n\n// Multiple IDs from same hook\nfunction Form() {\n  const id = useId();\n\n  return (\n    <form>\n      <label htmlFor={`${id}-name`}>Name</label>\n      <input id={`${id}-name`} />\n      \n      <label htmlFor={`${id}-email`}>Email</label>\n      <input id={`${id}-email`} />\n    </form>\n  );\n}\n\n// Why not use random IDs?\n// - SSR: must match between server and client\n// - Hydration: random IDs cause mismatch errors\n// - useId generates stable IDs that work with SSR\n\n// Format: :r0:, :r1:, etc.\n// Unique per component instance\n\n// Use cases:\n// - Form labels and inputs\n// - ARIA attributes (aria-describedby)\n// - Any unique ID needs\n\n// NOT for:\n// - Keys in lists (use data IDs)\n// - CSS selectors (use classes)",
      "meaning": "useId hook คืออะไร?",
      "example": "useId generates unique IDs stable across server and client rendering. Essential for SSR - random IDs cause hydration mismatch. Use for: form label-input pairs, ARIA attributes. Generate multiple IDs with prefix: `${id}-name`. NOT for list keys (use data IDs). Format like :r0:, unique per component instance.",
      "exampleTranslation": "useId generate unique IDs ที่ stable ระหว่าง server และ client rendering จำเป็นสำหรับ SSR - random IDs ทำให้ hydration mismatch ใช้สำหรับ: form label-input pairs, ARIA attributes Generate multiple IDs ด้วย prefix: `${id}-name` ไม่ใช่สำหรับ list keys (ใช้ data IDs) Format เช่น :r0: unique ต่อ component instance"
    },
    {
      "vocab": "How to optimize React performance?",
      "pronunciation": "// 1. Avoid unnecessary re-renders\nconst MemoizedChild = React.memo(Child);\n\n// 2. Memoize expensive calculations\nconst sorted = useMemo(() => \n  items.sort((a, b) => a.name.localeCompare(b.name)),\n  [items]\n);\n\n// 3. Memoize callbacks for memoized children\nconst handleClick = useCallback(() => {\n  setCount(c => c + 1);\n}, []);\n\n// 4. Lazy load components\nconst HeavyComponent = lazy(() => import('./Heavy'));\n\n// 5. Virtualize long lists\nimport { FixedSizeList } from 'react-window';\n<FixedSizeList height={400} itemCount={10000} itemSize={35}>\n  {Row}\n</FixedSizeList>\n\n// 6. Debounce frequent updates\nconst debouncedSearch = useMemo(\n  () => debounce(setSearchTerm, 300),\n  []\n);\n\n// 7. Use transitions for non-urgent updates\nconst [isPending, startTransition] = useTransition();\nstartTransition(() => setFilteredItems(filtered));\n\n// 8. Split context to prevent over-rendering\n<UserContext.Provider value={user}>\n<ThemeContext.Provider value={theme}>  {/* Separate */}\n\n// 9. Move state down / lift content up\n// Put state in component that needs it\n\n// 10. Use React DevTools Profiler\n// Identify slow renders, wasted renders",
      "meaning": "วิธี optimize React performance ทำอย่างไร?",
      "example": "Key optimizations: 1) React.memo for pure components, 2) useMemo for expensive calculations, 3) useCallback for stable callbacks, 4) lazy loading, 5) virtualize long lists (react-window), 6) debounce frequent updates, 7) useTransition for non-urgent updates, 8) split contexts, 9) colocate state, 10) Profile first. Don't optimize prematurely.",
      "exampleTranslation": "Key optimizations: 1) React.memo สำหรับ pure components 2) useMemo สำหรับ expensive calculations 3) useCallback สำหรับ stable callbacks 4) lazy loading 5) virtualize long lists (react-window) 6) debounce frequent updates 7) useTransition สำหรับ non-urgent updates 8) split contexts 9) colocate state 10) Profile ก่อน อย่า optimize ก่อนเวลา"
    },
    {
      "vocab": "What are common React patterns?",
      "pronunciation": "// 1. Container/Presentational\nfunction UserListContainer() {\n  const [users, setUsers] = useState([]);\n  useEffect(() => { fetchUsers().then(setUsers); }, []);\n  return <UserList users={users} />;  // Presentational\n}\n\nfunction UserList({ users }) {\n  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;\n}\n\n// 2. Compound Components\nfunction Tabs({ children }) {\n  const [active, setActive] = useState(0);\n  return (\n    <TabsContext.Provider value={{ active, setActive }}>\n      {children}\n    </TabsContext.Provider>\n  );\n}\nTabs.Tab = function Tab({ index, children }) {...};\nTabs.Panel = function Panel({ index, children }) {...};\n\n<Tabs>\n  <Tabs.Tab index={0}>Tab 1</Tabs.Tab>\n  <Tabs.Panel index={0}>Content 1</Tabs.Panel>\n</Tabs>\n\n// 3. Render Props\n<Mouse render={({ x, y }) => <Cat x={x} y={y} />} />\n\n// 4. Custom Hook\nfunction useForm(initial) {\n  const [values, setValues] = useState(initial);\n  const handleChange = e => setValues(...);\n  return { values, handleChange, reset: () => setValues(initial) };\n}\n\n// 5. Composition over inheritance\n<Card>\n  <CardHeader>Title</CardHeader>\n  <CardBody>Content</CardBody>\n</Card>",
      "meaning": "React patterns ที่ใช้บ่อยมีอะไรบ้าง?",
      "example": "Common patterns: 1) Container/Presentational - separate data fetching from UI, 2) Compound Components - related components share state via context, 3) Render Props - share logic via render function, 4) Custom Hooks - extract reusable stateful logic, 5) Composition - use children and slots over inheritance. Choose pattern based on use case.",
      "exampleTranslation": "Patterns ที่ใช้บ่อย: 1) Container/Presentational - แยก data fetching จาก UI 2) Compound Components - related components share state ผ่าน context 3) Render Props - share logic ผ่าน render function 4) Custom Hooks - extract reusable stateful logic 5) Composition - ใช้ children และ slots แทน inheritance เลือก pattern ตาม use case"
    },
    {
      "vocab": "How to handle forms in React?",
      "pronunciation": "import { useState } from 'react';\n\n// Controlled form\nfunction ControlledForm() {\n  const [form, setForm] = useState({ name: '', email: '' });\n  const [errors, setErrors] = useState({});\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setForm(prev => ({ ...prev, [name]: value }));\n  };\n\n  const validate = () => {\n    const newErrors = {};\n    if (!form.name) newErrors.name = 'Name required';\n    if (!form.email.includes('@')) newErrors.email = 'Invalid email';\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (validate()) {\n      console.log('Submit:', form);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"name\"\n        value={form.name}\n        onChange={handleChange}\n      />\n      {errors.name && <span>{errors.name}</span>}\n      \n      <input\n        name=\"email\"\n        value={form.email}\n        onChange={handleChange}\n      />\n      {errors.email && <span>{errors.email}</span>}\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// Libraries for complex forms:\n// - React Hook Form (minimal re-renders)\n// - Formik (full-featured)\n// - Zod / Yup for validation schemas",
      "meaning": "วิธีจัดการ forms ใน React ทำอย่างไร?",
      "example": "Controlled forms: state for each field, onChange updates state. handleSubmit with e.preventDefault(). Validation: check values, set errors state, display error messages. For complex forms use libraries: React Hook Form (performant, minimal re-renders), Formik (feature-rich). Zod/Yup for schema validation. Use name attribute for dynamic handling.",
      "exampleTranslation": "Controlled forms: state สำหรับแต่ละ field, onChange update state handleSubmit กับ e.preventDefault() Validation: check values, set errors state, แสดง error messages สำหรับ complex forms ใช้ libraries: React Hook Form (performant, minimal re-renders), Formik (feature-rich) Zod/Yup สำหรับ schema validation ใช้ name attribute สำหรับ dynamic handling"
    },
    {
      "vocab": "What is React Strict Mode?",
      "pronunciation": "import { StrictMode } from 'react';\n\n// Wrap app in StrictMode\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n\n// StrictMode does (development only):\n\n// 1. Double-invokes functions to find impure renders\n// - Renders components twice\n// - Runs effects twice (setup + cleanup + setup)\n// - Runs reducers and initializers twice\n\n// This catches:\nfunction Bad() {\n  items.push(newItem);  // ❌ Mutation during render\n  return <List items={items} />;\n}\n\nfunction Good() {\n  const newItems = [...items, newItem];  // ✅ Pure\n  return <List items={newItems} />;\n}\n\n// 2. Warns about deprecated APIs\n// - Legacy string refs\n// - findDOMNode\n// - Legacy context API\n\n// 3. Warns about side effects in render\n// Helps find bugs before they cause problems\n\n// In production:\n// - StrictMode has NO effect\n// - No performance impact\n// - No double rendering\n\n// Can wrap parts of app\n<StrictMode>\n  <NewFeature />  {/* Strict checks */}\n</StrictMode>\n<LegacyComponent />  {/* No strict checks */}",
      "meaning": "React Strict Mode คืออะไร?",
      "example": "StrictMode is development tool that highlights potential problems. Double-invokes renders and effects to find impure code and side effects. Warns about deprecated APIs. NO effect in production - zero performance impact. Helps find: mutations during render, missing cleanup, unsafe lifecycles. Wrap entire app or specific parts.",
      "exampleTranslation": "StrictMode คือ development tool ที่ highlight potential problems Double-invoke renders และ effects เพื่อหา impure code และ side effects Warn เกี่ยวกับ deprecated APIs ไม่มีผลใน production - zero performance impact ช่วยหา: mutations ระหว่าง render, missing cleanup, unsafe lifecycles Wrap ทั้ง app หรือ specific parts"
    },
    {
      "vocab": "How to test React components?",
      "pronunciation": "// Testing Library: test behavior, not implementation\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\n// Component test\ntest('renders greeting', () => {\n  render(<Greeting name=\"John\" />);\n  expect(screen.getByText('Hello, John!')).toBeInTheDocument();\n});\n\n// User interaction\ntest('increments counter', async () => {\n  const user = userEvent.setup();\n  render(<Counter />);\n  \n  await user.click(screen.getByRole('button', { name: /increment/i }));\n  \n  expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});\n\n// Async operations\ntest('loads user data', async () => {\n  render(<UserProfile userId=\"1\" />);\n  \n  expect(screen.getByText('Loading...')).toBeInTheDocument();\n  \n  await waitFor(() => {\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n  });\n});\n\n// Form testing\ntest('submits form', async () => {\n  const handleSubmit = jest.fn();\n  const user = userEvent.setup();\n  render(<Form onSubmit={handleSubmit} />);\n  \n  await user.type(screen.getByLabelText('Name'), 'John');\n  await user.click(screen.getByRole('button', { name: /submit/i }));\n  \n  expect(handleSubmit).toHaveBeenCalledWith({ name: 'John' });\n});\n\n// Queries priority:\n// 1. getByRole (accessibility)\n// 2. getByLabelText (forms)\n// 3. getByText (content)\n// 4. getByTestId (last resort)",
      "meaning": "วิธี test React components ทำอย่างไร?",
      "example": "Use React Testing Library - test user behavior, not implementation. render() mounts component. screen.getBy*/findBy*/queryBy* for queries. userEvent for realistic interactions. waitFor for async. Query priority: getByRole (best), getByLabelText, getByText, getByTestId (avoid). Test what users see and do, not internal state.",
      "exampleTranslation": "ใช้ React Testing Library - test user behavior ไม่ใช่ implementation render() mount component screen.getBy*/findBy*/queryBy* สำหรับ queries userEvent สำหรับ realistic interactions waitFor สำหรับ async Query priority: getByRole (ดีที่สุด), getByLabelText, getByText, getByTestId (หลีกเลี่ยง) Test สิ่งที่ users เห็นและทำ ไม่ใช่ internal state"
    },
    {
      "vocab": "What are common React mistakes to avoid?",
      "pronunciation": "// 1. Mutating state directly\nconst [items, setItems] = useState([1, 2, 3]);\nitems.push(4);  // ❌ Mutation\nsetItems([...items, 4]);  // ✅ New array\n\n// 2. Missing dependencies in useEffect\nuseEffect(() => {\n  fetchData(userId);  // userId used but not in deps\n}, []);  // ❌ Stale closure\nuseEffect(() => {\n  fetchData(userId);\n}, [userId]);  // ✅\n\n// 3. Creating objects/functions in render\n<Child style={{ color: 'red' }} />  // ❌ New object every render\nconst style = useMemo(() => ({ color: 'red' }), []);  // ✅\n\n// 4. Using index as key\n{items.map((item, i) => <Item key={i} />)}  // ❌\n{items.map(item => <Item key={item.id} />)}  // ✅\n\n// 5. Not cleaning up effects\nuseEffect(() => {\n  const sub = subscribe();\n  // return () => sub.unsubscribe();  // ❌ Missing cleanup\n  return () => sub.unsubscribe();  // ✅\n}, []);\n\n// 6. State for derived data\nconst [items, setItems] = useState([]);\nconst [count, setCount] = useState(0);  // ❌ Derived\nconst count = items.length;  // ✅ Calculate from state\n\n// 7. Fetching in useEffect without cleanup\nuseEffect(() => {\n  let cancelled = false;\n  fetchData().then(data => {\n    if (!cancelled) setData(data);  // ✅ Prevent update after unmount\n  });\n  return () => { cancelled = true; };\n}, []);",
      "meaning": "React mistakes ที่ควรหลีกเลี่ยงมีอะไรบ้าง?",
      "example": "Common mistakes: 1) Mutating state directly - always create new references, 2) Missing effect dependencies - causes stale closures, 3) Creating objects/functions in render - breaks memoization, 4) Index as key - causes bugs on reorder, 5) Missing cleanup - memory leaks, 6) State for derived data - just calculate it, 7) No race condition handling in fetches.",
      "exampleTranslation": "Mistakes ที่พบบ่อย: 1) Mutate state โดยตรง - สร้าง references ใหม่เสมอ 2) ขาด effect dependencies - ทำให้ stale closures 3) สร้าง objects/functions ใน render - break memoization 4) Index เป็น key - ทำให้ bugs ตอน reorder 5) ไม่มี cleanup - memory leaks 6) State สำหรับ derived data - แค่คำนวณมัน 7) ไม่มี race condition handling ใน fetches"
    }
  ]
}
