{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "React Concepts",
    "description": "Core React concepts including hooks, state management, performance optimization, patterns, and React 19 features",
    "category": "Programming",
    "tags": ["react", "javascript", "frontend", "hooks", "concepts"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is React and the Virtual DOM?",
      "pronunciation": "",
      "meaning": "React และ Virtual DOM คืออะไร?",
      "example": "React is a JavaScript library for building user interfaces with components. Virtual DOM is an in-memory representation of Real DOM. When state changes, React creates new Virtual DOM, diffs with old one (reconciliation), and only updates changed parts in Real DOM. This makes updates efficient without full page re-renders.",
      "exampleTranslation": "React คือ JavaScript library สำหรับสร้าง user interfaces ด้วย components Virtual DOM คือ in-memory representation ของ Real DOM เมื่อ state เปลี่ยน React สร้าง Virtual DOM ใหม่ diff กับอันเก่า (reconciliation) และ update เฉพาะส่วนที่เปลี่ยนใน Real DOM ทำให้ updates มีประสิทธิภาพ ไม่ต้อง re-render ทั้งหน้า"
    },
    {
      "vocab": "What is JSX?",
      "pronunciation": "className, htmlFor, onClick",
      "meaning": "JSX คืออะไร?",
      "example": "JSX is syntax extension that looks like HTML in JavaScript. Compiles to React.createElement() calls. Use {} for JavaScript expressions. Differences from HTML: className (not class), htmlFor (not for), camelCase events (onClick). Styles as objects. Must return single element - use Fragment (<></>) for multiple.",
      "exampleTranslation": "JSX คือ syntax extension ที่ดูเหมือน HTML ใน JavaScript Compile เป็น React.createElement() calls ใช้ {} สำหรับ JavaScript expressions ต่างจาก HTML: className (ไม่ใช่ class), htmlFor (ไม่ใช่ for), camelCase events (onClick) Styles เป็น objects ต้อง return element เดียว ใช้ Fragment (<></>) สำหรับหลายตัว"
    },
    {
      "vocab": "What are Components in React?",
      "pronunciation": "function Welcome({ name })",
      "meaning": "Components ใน React คืออะไร?",
      "example": "Components are reusable UI building blocks. Function components are recommended (simpler, hooks support). Class components still work but legacy. Must start with capital letter. Return JSX or null. Should be pure - same props = same output. Use composition with children prop for flexible layouts.",
      "exampleTranslation": "Components คือ reusable UI building blocks Function components แนะนำ (ง่ายกว่า รองรับ hooks) Class components ยังใช้ได้แต่เป็น legacy ต้องขึ้นต้นด้วยตัวพิมพ์ใหญ่ Return JSX หรือ null ควรเป็น pure - props เดียวกัน = output เดียวกัน ใช้ composition ด้วย children prop สำหรับ layouts ที่ยืดหยุ่น"
    },
    {
      "vocab": "What are Props?",
      "pronunciation": "{ name, age = 0, ...rest }",
      "meaning": "Props คืออะไร?",
      "example": "Props are read-only data passed from parent to child component. Destructure in function parameters. Can pass strings, numbers, booleans, objects, functions, JSX. Default values with = in destructuring. Spread operator for passing multiple props. children is special prop for nested content. Never mutate props.",
      "exampleTranslation": "Props คือ read-only data ที่ส่งจาก parent ไปยัง child component Destructure ใน function parameters ส่ง strings, numbers, booleans, objects, functions, JSX ได้ Default values ด้วย = ใน destructuring Spread operator สำหรับส่งหลาย props children เป็น special prop สำหรับ nested content ห้าม mutate props"
    },
    {
      "vocab": "What is useState hook?",
      "pronunciation": "const [state, setState] = useState(initial)",
      "meaning": "useState hook คืออะไร?",
      "example": "useState adds state to function components. Returns [value, setter]. Setter triggers re-render. Use functional update (prev => new) when new state depends on old - avoids stale closure issues. For objects/arrays, create new reference (spread) since React uses shallow comparison. Lazy initializer for expensive computations.",
      "exampleTranslation": "useState เพิ่ม state ให้ function components Return [value, setter] Setter trigger re-render ใช้ functional update (prev => new) เมื่อ state ใหม่ขึ้นกับอันเก่า หลีกเลี่ยง stale closure issues สำหรับ objects/arrays สร้าง reference ใหม่ (spread) เพราะ React ใช้ shallow comparison Lazy initializer สำหรับ expensive computations"
    },
    {
      "vocab": "What is useEffect hook?",
      "pronunciation": "useEffect(() => {}, [deps])",
      "meaning": "useEffect hook คืออะไร?",
      "example": "useEffect handles side effects: data fetching, subscriptions, DOM manipulation. Runs after render. Dependency array controls when it runs: [] once on mount, [deps] when deps change, omit for every render. Return cleanup function for subscriptions/timers. Cleanup runs before next effect and on unmount.",
      "exampleTranslation": "useEffect จัดการ side effects: data fetching, subscriptions, DOM manipulation รันหลัง render Dependency array ควบคุมว่ารันเมื่อไหร่: [] ครั้งเดียวตอน mount, [deps] เมื่อ deps เปลี่ยน, ไม่ใส่สำหรับทุก render Return cleanup function สำหรับ subscriptions/timers Cleanup รันก่อน effect ถัดไปและตอน unmount"
    },
    {
      "vocab": "What is useContext hook?",
      "pronunciation": "createContext, Provider, useContext",
      "meaning": "useContext hook คืออะไร?",
      "example": "useContext provides way to pass data through component tree without prop drilling. Create context with createContext(), provide value with Provider, consume with useContext(). Good for: themes, user auth, locale. Create custom hook (useTheme) for better DX. Context changes trigger re-render in all consumers.",
      "exampleTranslation": "useContext ให้วิธีส่ง data ผ่าน component tree โดยไม่ต้อง prop drilling สร้าง context ด้วย createContext() ให้ value ด้วย Provider ใช้ด้วย useContext() ดีสำหรับ: themes, user auth, locale สร้าง custom hook (useTheme) สำหรับ DX ที่ดีกว่า Context เปลี่ยน trigger re-render ใน consumers ทั้งหมด"
    },
    {
      "vocab": "What is useReducer hook?",
      "pronunciation": "const [state, dispatch] = useReducer(reducer, initial)",
      "meaning": "useReducer hook คืออะไร?",
      "example": "useReducer manages complex state with reducer pattern. reducer(state, action) returns new state. dispatch(action) triggers state update. Better than useState for: complex logic, multiple sub-values, state depending on previous state. Reducer is pure function - easy to test. Often used with useContext for global state.",
      "exampleTranslation": "useReducer จัดการ complex state ด้วย reducer pattern reducer(state, action) return state ใหม่ dispatch(action) trigger state update ดีกว่า useState สำหรับ: complex logic, multiple sub-values, state ที่ขึ้นกับ previous state Reducer เป็น pure function test ง่าย มักใช้กับ useContext สำหรับ global state"
    },
    {
      "vocab": "What is useMemo hook?",
      "pronunciation": "useMemo(() => compute, [deps])",
      "meaning": "useMemo hook คืออะไร?",
      "example": "useMemo memoizes computed values - recalculates only when dependencies change. Use for: expensive calculations, maintaining referential equality for object/array props. Returns cached value between renders. Don't overuse - memoization has memory/comparison cost. Profile first to identify real performance issues.",
      "exampleTranslation": "useMemo memoize computed values - คำนวณใหม่เฉพาะเมื่อ dependencies เปลี่ยน ใช้สำหรับ: expensive calculations, รักษา referential equality สำหรับ object/array props Return cached value ระหว่าง renders อย่าใช้มากเกินไป memoization มี memory/comparison cost Profile ก่อนเพื่อระบุ performance issues จริง"
    },
    {
      "vocab": "What is useCallback hook?",
      "pronunciation": "useCallback(fn, [deps])",
      "meaning": "useCallback hook คืออะไร?",
      "example": "useCallback memoizes functions - returns same reference if dependencies unchanged. Use when passing callbacks to memoized children (React.memo) to prevent unnecessary re-renders. Also useful as dependency for useEffect. Equivalent to useMemo(() => fn, deps). Don't wrap every function - only when referential equality matters.",
      "exampleTranslation": "useCallback memoize functions - return reference เดิมถ้า dependencies ไม่เปลี่ยน ใช้เมื่อส่ง callbacks ให้ memoized children (React.memo) เพื่อป้องกัน re-renders ที่ไม่จำเป็น ยังมีประโยชน์เป็น dependency สำหรับ useEffect เทียบเท่า useMemo(() => fn, deps) อย่า wrap ทุก function เฉพาะเมื่อ referential equality สำคัญ"
    },
    {
      "vocab": "What is useRef hook?",
      "pronunciation": "const ref = useRef(initial)",
      "meaning": "useRef hook คืออะไร?",
      "example": "useRef creates mutable container that persists across renders. Two main uses: 1) DOM references via ref attribute - access DOM methods like focus(), 2) Mutable values that don't trigger re-render - store interval IDs, previous values. Unlike state, changing .current doesn't cause re-render.",
      "exampleTranslation": "useRef สร้าง mutable container ที่คงอยู่ข้าม renders การใช้งานหลัก 2 อย่าง: 1) DOM references ผ่าน ref attribute เข้าถึง DOM methods เช่น focus() 2) Mutable values ที่ไม่ trigger re-render เก็บ interval IDs, previous values ต่างจาก state การเปลี่ยน .current ไม่ทำให้ re-render"
    },
    {
      "vocab": "What are Custom Hooks?",
      "pronunciation": "function useLocalStorage(key, initial)",
      "meaning": "Custom Hooks คืออะไร?",
      "example": "Custom hooks extract reusable stateful logic. Name must start with 'use'. Can use other hooks inside. Share logic, not state - each component using hook gets own state. Common patterns: useLocalStorage, useFetch, useToggle, useDebounce. Great for abstracting complex logic and making components cleaner.",
      "exampleTranslation": "Custom hooks extract reusable stateful logic ชื่อต้องขึ้นต้นด้วย 'use' ใช้ hooks อื่นข้างในได้ Share logic ไม่ใช่ state แต่ละ component ที่ใช้ hook ได้ state ของตัวเอง Patterns ที่พบบ่อย: useLocalStorage, useFetch, useToggle, useDebounce ดีสำหรับ abstracting complex logic และทำ components สะอาดขึ้น"
    },
    {
      "vocab": "What are the Rules of Hooks?",
      "pronunciation": "",
      "meaning": "Rules of Hooks คืออะไร?",
      "example": "Two rules: 1) Only call hooks at top level - not in conditions, loops, or nested functions. 2) Only call from React functions - components or custom hooks. React tracks hooks by call order - must be same every render. Use eslint-plugin-react-hooks to catch violations.",
      "exampleTranslation": "สองกฎ: 1) เรียก hooks ที่ top level เท่านั้น ไม่ใช่ใน conditions, loops หรือ nested functions 2) เรียกจาก React functions เท่านั้น components หรือ custom hooks React track hooks ด้วย call order ต้องเหมือนกันทุก render ใช้ eslint-plugin-react-hooks เพื่อจับ violations"
    },
    {
      "vocab": "What is React.memo?",
      "pronunciation": "const Memoized = memo(Component)",
      "meaning": "React.memo คืออะไร?",
      "example": "React.memo is HOC that memoizes component - skips re-render if props unchanged (shallow comparison). Wrap functional components that render same output for same props. Use when: component renders often with same props, expensive render. Custom comparison function for deep comparison. Don't overuse - adds overhead.",
      "exampleTranslation": "React.memo คือ HOC ที่ memoize component ข้าม re-render ถ้า props ไม่เปลี่ยน (shallow comparison) Wrap functional components ที่ render output เดิมสำหรับ props เดิม ใช้เมื่อ: component render บ่อยกับ props เดิม, render แพง Custom comparison function สำหรับ deep comparison อย่าใช้มากเกินไป เพิ่ม overhead"
    },
    {
      "vocab": "What are Controlled vs Uncontrolled Components?",
      "pronunciation": "value + onChange vs ref + defaultValue",
      "meaning": "Controlled vs Uncontrolled Components คืออะไร?",
      "example": "Controlled: React state is source of truth. value + onChange make React control input. Enables instant validation, formatting. Uncontrolled: DOM is source of truth. Use ref to read value. defaultValue for initial. Simpler but less control. File inputs always uncontrolled. Prefer controlled for most cases.",
      "exampleTranslation": "Controlled: React state เป็น source of truth value + onChange ทำให้ React control input Enable instant validation, formatting Uncontrolled: DOM เป็น source of truth ใช้ ref เพื่ออ่านค่า defaultValue สำหรับค่าเริ่มต้น ง่ายกว่าแต่ control น้อยกว่า File inputs เป็น uncontrolled เสมอ ใช้ controlled สำหรับกรณีส่วนใหญ่"
    },
    {
      "vocab": "What are Error Boundaries?",
      "pronunciation": "getDerivedStateFromError, componentDidCatch",
      "meaning": "Error Boundaries คืออะไร?",
      "example": "Error Boundaries are class components that catch JavaScript errors in child component tree. Use getDerivedStateFromError for fallback UI, componentDidCatch for logging. Don't catch: event handlers, async code, SSR, self errors. Must be class component (no hooks equivalent yet). Wrap sections of app for granular error handling.",
      "exampleTranslation": "Error Boundaries คือ class components ที่ catch JavaScript errors ใน child component tree ใช้ getDerivedStateFromError สำหรับ fallback UI, componentDidCatch สำหรับ logging ไม่ catch: event handlers, async code, SSR, self errors ต้องเป็น class component ยังไม่มี hooks equivalent Wrap sections ของ app สำหรับ granular error handling"
    },
    {
      "vocab": "What are Portals?",
      "pronunciation": "createPortal(children, domNode)",
      "meaning": "Portals คืออะไร?",
      "example": "Portals render children into DOM node outside parent hierarchy. Use createPortal(children, domNode). Child is still part of React tree - events bubble up, context works. Useful for modals, tooltips, dropdowns - avoids CSS overflow:hidden and z-index issues. HTML needs target container element.",
      "exampleTranslation": "Portals render children เข้าไปใน DOM node นอก parent hierarchy ใช้ createPortal(children, domNode) Child ยังเป็นส่วนของ React tree events bubble up, context ใช้งานได้ มีประโยชน์สำหรับ modals, tooltips, dropdowns หลีกเลี่ยงปัญหา CSS overflow:hidden และ z-index HTML ต้องมี target container element"
    },
    {
      "vocab": "What is Suspense and lazy loading?",
      "pronunciation": "lazy(() => import()), <Suspense>",
      "meaning": "Suspense และ lazy loading คืออะไร?",
      "example": "lazy() enables code-splitting - component code loads on demand. Suspense shows fallback while lazy component loads. Use for route-based splitting, heavy components. Nested Suspense for granular loading states. Also works with data fetching libraries (React Query, SWR). Reduces initial bundle size.",
      "exampleTranslation": "lazy() enable code-splitting component code โหลดตามต้องการ Suspense แสดง fallback ขณะ lazy component โหลด ใช้สำหรับ route-based splitting, heavy components Nested Suspense สำหรับ granular loading states ยังใช้กับ data fetching libraries (React Query, SWR) ลด initial bundle size"
    },
    {
      "vocab": "What is useTransition hook?",
      "pronunciation": "const [isPending, startTransition] = useTransition()",
      "meaning": "useTransition hook คืออะไร?",
      "example": "useTransition marks state updates as non-urgent (transitions). Returns [isPending, startTransition]. Wrap slow updates in startTransition - keeps UI responsive. React can interrupt transition for urgent updates. isPending shows loading state. Use for: filtering large lists, tab switching, heavy renders. React 18 concurrent feature.",
      "exampleTranslation": "useTransition mark state updates ว่า non-urgent (transitions) Return [isPending, startTransition] Wrap slow updates ใน startTransition ให้ UI responsive React สามารถ interrupt transition สำหรับ urgent updates isPending แสดง loading state ใช้สำหรับ: filtering large lists, tab switching, heavy renders React 18 concurrent feature"
    },
    {
      "vocab": "What is useDeferredValue hook?",
      "pronunciation": "const deferred = useDeferredValue(value)",
      "meaning": "useDeferredValue hook คืออะไร?",
      "example": "useDeferredValue creates deferred version of a value that 'lags behind'. During urgent updates, returns old value - prevents expensive re-renders. Compare current vs deferred to show stale indicator. Simpler than useTransition when deferring props. Both are concurrent features for keeping UI responsive.",
      "exampleTranslation": "useDeferredValue สร้าง deferred version ของค่าที่ 'lags behind' ระหว่าง urgent updates return ค่าเก่า ป้องกัน expensive re-renders เปรียบเทียบ current vs deferred เพื่อแสดง stale indicator ง่ายกว่า useTransition เมื่อ deferring props ทั้งคู่เป็น concurrent features สำหรับให้ UI responsive"
    },
    {
      "vocab": "What is forwardRef?",
      "pronunciation": "forwardRef((props, ref) => ...)",
      "meaning": "forwardRef คืออะไร?",
      "example": "forwardRef allows passing ref through component to child DOM element. Wrap component with forwardRef((props, ref) => ...). Use when building reusable input components, focus management. useImperativeHandle customizes the ref value - expose specific methods instead of raw DOM.",
      "exampleTranslation": "forwardRef อนุญาตให้ส่ง ref ผ่าน component ไปยัง child DOM element Wrap component ด้วย forwardRef((props, ref) => ...) ใช้เมื่อสร้าง reusable input components, focus management useImperativeHandle customize ref value expose specific methods แทน raw DOM"
    },
    {
      "vocab": "What are Higher-Order Components (HOC)?",
      "pronunciation": "function withLoading(WrappedComponent)",
      "meaning": "Higher-Order Components (HOC) คืออะไร?",
      "example": "HOC is function that takes component and returns enhanced component. Pattern for reusing component logic: loading states, auth, theming. Convention: withXxx naming. Pass through unrelated props. Modern alternative: custom hooks often simpler. HOCs still useful for: wrapping with providers, cross-cutting concerns.",
      "exampleTranslation": "HOC คือ function ที่รับ component และ return enhanced component Pattern สำหรับ reuse component logic: loading states, auth, theming Convention: withXxx naming ส่งต่อ unrelated props Alternative สมัยใหม่: custom hooks มักง่ายกว่า HOCs ยังมีประโยชน์สำหรับ: wrapping with providers, cross-cutting concerns"
    },
    {
      "vocab": "What is the key prop and why is it important?",
      "pronunciation": "key={item.id}",
      "meaning": "key prop คืออะไรและทำไมสำคัญ?",
      "example": "key helps React identify list items for efficient updates. Must be unique among siblings and stable. Use data IDs, not array index (causes bugs when reordering/deleting). Without keys: performance issues, wrong state preservation. Changing key forces component remount - useful for resetting state.",
      "exampleTranslation": "key ช่วย React ระบุ list items สำหรับ efficient updates ต้อง unique ระหว่าง siblings และ stable ใช้ data IDs ไม่ใช่ array index (ทำให้เกิด bugs เมื่อ reordering/deleting) ไม่มี keys: performance issues, state preservation ผิด เปลี่ยน key บังคับ component remount มีประโยชน์สำหรับ resetting state"
    },
    {
      "vocab": "What are Server Components in React 19?",
      "pronunciation": "'use client' directive",
      "meaning": "Server Components ใน React 19 คืออะไร?",
      "example": "Server Components render on server with zero client JavaScript. Can use async/await, access databases, secrets directly. 'use client' marks client components (need interactivity, hooks, browser APIs). Server imports client, not vice versa. Benefits: smaller bundles, direct data access, better performance.",
      "exampleTranslation": "Server Components render บน server ด้วย client JavaScript เป็นศูนย์ ใช้ async/await, เข้าถึง databases, secrets ได้โดยตรง 'use client' mark client components (ต้องการ interactivity, hooks, browser APIs) Server import client ไม่ใช่กลับกัน ข้อดี: bundles เล็กลง, direct data access, performance ดีกว่า"
    },
    {
      "vocab": "What is the use() hook in React 19?",
      "pronunciation": "const data = use(promise)",
      "meaning": "use() hook ใน React 19 คืออะไร?",
      "example": "use() reads resources during render - unwraps Promises and Context. Unlike other hooks, CAN be called conditionally or in loops. With Promises: suspends component until resolved, use with Suspense. Simpler than useContext for conditional context reading. React 19 feature.",
      "exampleTranslation": "use() อ่าน resources ระหว่าง render unwrap Promises และ Context ต่างจาก hooks อื่น สามารถเรียกแบบ conditional หรือใน loops ได้ กับ Promises: suspend component จนกว่าจะ resolved ใช้กับ Suspense ง่ายกว่า useContext สำหรับ conditional context reading เป็น React 19 feature"
    },
    {
      "vocab": "What are Actions and useActionState in React 19?",
      "pronunciation": "const [state, action, pending] = useActionState(fn, init)",
      "meaning": "Actions และ useActionState ใน React 19 คืออะไร?",
      "example": "Actions are async functions handling form submissions. useActionState manages action state: [state, action, isPending]. Replaces manual useState for loading/error. Works with form action attribute. Supports Server Actions (Next.js). Benefits: simpler forms, progressive enhancement, automatic pending state.",
      "exampleTranslation": "Actions คือ async functions ที่จัดการ form submissions useActionState จัดการ action state: [state, action, isPending] แทนที่ manual useState สำหรับ loading/error ใช้กับ form action attribute รองรับ Server Actions (Next.js) ข้อดี: forms ง่ายขึ้น, progressive enhancement, automatic pending state"
    },
    {
      "vocab": "What is useOptimistic hook?",
      "pronunciation": "const [optimistic, addOptimistic] = useOptimistic(state, fn)",
      "meaning": "useOptimistic hook คืออะไร?",
      "example": "useOptimistic enables optimistic UI updates - show result before server confirms. Returns [optimisticState, addOptimistic]. Update immediately with addOptimistic, then sync with server. Automatically reverts on error. Great for: likes, adds, deletes - instant feedback. React 19 feature.",
      "exampleTranslation": "useOptimistic enable optimistic UI updates แสดงผลก่อน server ยืนยัน Return [optimisticState, addOptimistic] Update ทันทีด้วย addOptimistic แล้ว sync กับ server Revert อัตโนมัติเมื่อ error ดีสำหรับ: likes, adds, deletes instant feedback เป็น React 19 feature"
    },
    {
      "vocab": "What is useId hook?",
      "pronunciation": "const id = useId()",
      "meaning": "useId hook คืออะไร?",
      "example": "useId generates unique IDs stable across server and client rendering. Essential for SSR - random IDs cause hydration mismatch. Use for: form label-input pairs, ARIA attributes. Generate multiple IDs with prefix: `${id}-name`. NOT for list keys (use data IDs).",
      "exampleTranslation": "useId generate unique IDs ที่ stable ระหว่าง server และ client rendering จำเป็นสำหรับ SSR random IDs ทำให้ hydration mismatch ใช้สำหรับ: form label-input pairs, ARIA attributes Generate multiple IDs ด้วย prefix: `${id}-name` ไม่ใช่สำหรับ list keys (ใช้ data IDs)"
    },
    {
      "vocab": "How to optimize React performance?",
      "pronunciation": "memo, useMemo, useCallback, lazy",
      "meaning": "วิธี optimize React performance ทำอย่างไร?",
      "example": "Key optimizations: 1) React.memo for pure components, 2) useMemo for expensive calculations, 3) useCallback for stable callbacks, 4) lazy loading, 5) virtualize long lists (react-window), 6) debounce frequent updates, 7) useTransition for non-urgent updates, 8) split contexts. Profile first before optimizing.",
      "exampleTranslation": "Key optimizations: 1) React.memo สำหรับ pure components 2) useMemo สำหรับ expensive calculations 3) useCallback สำหรับ stable callbacks 4) lazy loading 5) virtualize long lists (react-window) 6) debounce frequent updates 7) useTransition สำหรับ non-urgent updates 8) split contexts Profile ก่อนก่อน optimize"
    },
    {
      "vocab": "What are common React patterns?",
      "pronunciation": "",
      "meaning": "React patterns ที่ใช้บ่อยมีอะไรบ้าง?",
      "example": "Common patterns: 1) Container/Presentational - separate data fetching from UI, 2) Compound Components - related components share state via context, 3) Render Props - share logic via render function, 4) Custom Hooks - extract reusable stateful logic, 5) Composition - use children and slots over inheritance.",
      "exampleTranslation": "Patterns ที่ใช้บ่อย: 1) Container/Presentational แยก data fetching จาก UI 2) Compound Components related components share state ผ่าน context 3) Render Props share logic ผ่าน render function 4) Custom Hooks extract reusable stateful logic 5) Composition ใช้ children และ slots แทน inheritance"
    },
    {
      "vocab": "How to handle forms in React?",
      "pronunciation": "value={state} onChange={handleChange}",
      "meaning": "วิธีจัดการ forms ใน React ทำอย่างไร?",
      "example": "Controlled forms: state for each field, onChange updates state. handleSubmit with e.preventDefault(). Validation: check values, set errors state. For complex forms use libraries: React Hook Form (performant), Formik (feature-rich). Zod/Yup for schema validation.",
      "exampleTranslation": "Controlled forms: state สำหรับแต่ละ field, onChange update state handleSubmit กับ e.preventDefault() Validation: check values, set errors state สำหรับ complex forms ใช้ libraries: React Hook Form (performant), Formik (feature-rich) Zod/Yup สำหรับ schema validation"
    },
    {
      "vocab": "What is React Strict Mode?",
      "pronunciation": "<StrictMode>",
      "meaning": "React Strict Mode คืออะไร?",
      "example": "StrictMode is development tool that highlights potential problems. Double-invokes renders and effects to find impure code and side effects. Warns about deprecated APIs. NO effect in production - zero performance impact. Helps find: mutations during render, missing cleanup, unsafe lifecycles.",
      "exampleTranslation": "StrictMode คือ development tool ที่ highlight potential problems Double-invoke renders และ effects เพื่อหา impure code และ side effects Warn เกี่ยวกับ deprecated APIs ไม่มีผลใน production zero performance impact ช่วยหา: mutations ระหว่าง render, missing cleanup, unsafe lifecycles"
    },
    {
      "vocab": "How to test React components?",
      "pronunciation": "render, screen, userEvent",
      "meaning": "วิธี test React components ทำอย่างไร?",
      "example": "Use React Testing Library - test user behavior, not implementation. render() mounts component. screen.getBy*/findBy*/queryBy* for queries. userEvent for realistic interactions. waitFor for async. Query priority: getByRole (best), getByLabelText, getByText. Test what users see and do.",
      "exampleTranslation": "ใช้ React Testing Library test user behavior ไม่ใช่ implementation render() mount component screen.getBy*/findBy*/queryBy* สำหรับ queries userEvent สำหรับ realistic interactions waitFor สำหรับ async Query priority: getByRole (ดีที่สุด), getByLabelText, getByText Test สิ่งที่ users เห็นและทำ"
    },
    {
      "vocab": "What are common React mistakes to avoid?",
      "pronunciation": "",
      "meaning": "React mistakes ที่ควรหลีกเลี่ยงมีอะไรบ้าง?",
      "example": "Common mistakes: 1) Mutating state directly - always create new references, 2) Missing effect dependencies - causes stale closures, 3) Creating objects/functions in render - breaks memoization, 4) Index as key - causes bugs on reorder, 5) Missing cleanup - memory leaks, 6) State for derived data - just calculate it.",
      "exampleTranslation": "Mistakes ที่พบบ่อย: 1) Mutate state โดยตรง สร้าง references ใหม่เสมอ 2) ขาด effect dependencies ทำให้ stale closures 3) สร้าง objects/functions ใน render break memoization 4) Index เป็น key ทำให้ bugs ตอน reorder 5) ไม่มี cleanup memory leaks 6) State สำหรับ derived data แค่คำนวณมัน"
    }
  ]
}
