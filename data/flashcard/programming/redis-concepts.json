{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "Redis Concepts",
    "description": "Core Redis concepts including data structures, caching patterns, persistence, clustering, and common use cases",
    "category": "Database",
    "tags": [
      "redis",
      "cache",
      "database",
      "concepts"
    ],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is Redis and when to use it?",
      "pronunciation": "# Redis = Remote Dictionary Server\n# In-memory data structure store\n# Use cases:",
      "meaning": "Redis คืออะไรและใช้เมื่อไหร่?",
      "example": "Redis is an in-memory data structure store used as database, cache, and message broker. Single-threaded with async I/O, extremely fast (100K+ ops/sec). Supports persistence to disk. Use for caching, sessions, real-time features, queues, and anywhere low-latency data access is critical.",
      "exampleTranslation": "Redis คือ in-memory data structure store ใช้เป็น database, cache และ message broker Single-threaded กับ async I/O เร็วมาก (100K+ ops/sec) รองรับ persistence ลง disk ใช้สำหรับ caching, sessions, real-time features, queues และที่ใดก็ตามที่ต้องการ low-latency data access"
    },
    {
      "vocab": "What are the main data types in Redis?",
      "pronunciation": "# String - binary-safe, max 512MB\nSET key \"value\"\nGET key",
      "meaning": "Redis มี data types หลักอะไรบ้าง?",
      "example": "Redis has 5 main types: String (binary-safe text/numbers), List (ordered, duplicates allowed), Set (unique unordered), Sorted Set (unique with scores for ranking), Hash (object with fields). Also: Streams (log), Bitmaps, HyperLogLog, Geospatial. Each optimized for specific operations.",
      "exampleTranslation": "Redis มี 5 types หลัก: String (binary-safe text/numbers), List (เรียงลำดับ มี duplicates ได้), Set (unique ไม่เรียง), Sorted Set (unique มี scores สำหรับ ranking), Hash (object มี fields) นอกจากนี้: Streams (log), Bitmaps, HyperLogLog, Geospatial แต่ละตัว optimize สำหรับ operations เฉพาะ"
    },
    {
      "vocab": "What are String commands in Redis?",
      "pronunciation": "# Basic\nSET key \"value\"           # set value\nGET key                   # get value",
      "meaning": "Redis มี String commands อะไรบ้าง?",
      "example": "SET/GET for basic operations. SET with EX/PX for expiration, NX for create-only, XX for update-only. INCR/DECR for atomic counters. MSET/MGET for batch operations. Strings can store any binary data up to 512MB. SETNX useful for distributed locks. All operations are atomic.",
      "exampleTranslation": "SET/GET สำหรับ operations พื้นฐาน SET กับ EX/PX สำหรับ expiration, NX สำหรับ create-only, XX สำหรับ update-only INCR/DECR สำหรับ atomic counters MSET/MGET สำหรับ batch operations Strings เก็บ binary data ใดก็ได้ถึง 512MB SETNX มีประโยชน์สำหรับ distributed locks ทุก operations เป็น atomic"
    },
    {
      "vocab": "What are List commands in Redis?",
      "pronunciation": "# Push/Pop\nLPUSH mylist \"a\" \"b\"      # push left: [b, a]\nRPUSH mylist \"c\"          # push right: [b, a, c]",
      "meaning": "Redis มี List commands อะไรบ้าง?",
      "example": "Lists are linked lists - fast push/pop at ends O(1), slow random access O(N). LPUSH/RPUSH add elements, LPOP/RPOP remove. BLPOP/BRPOP block if empty - perfect for queues. LRANGE gets ranges. LTRIM caps list size. RPOPLPUSH for reliable queue patterns. Good for queues, timelines, latest items.",
      "exampleTranslation": "Lists เป็น linked lists - push/pop ที่ปลายเร็ว O(1), random access ช้า O(N) LPUSH/RPUSH เพิ่ม elements, LPOP/RPOP ลบ BLPOP/BRPOP block ถ้าว่าง - เหมาะสำหรับ queues LRANGE ดึง ranges LTRIM จำกัด list size RPOPLPUSH สำหรับ reliable queue patterns ดีสำหรับ queues, timelines, latest items"
    },
    {
      "vocab": "What are Set commands in Redis?",
      "pronunciation": "# Add/Remove\nSADD myset \"a\" \"b\" \"c\"    # add members\nSREM myset \"a\"            # remove member",
      "meaning": "Redis มี Set commands อะไรบ้าง?",
      "example": "Sets store unique unordered elements. SADD adds (returns count of new), SREM removes. SISMEMBER checks O(1). Set operations SUNION/SINTER/SDIFF for combining sets. SRANDMEMBER for random sampling. Perfect for tags, unique counters, social relationships, and deduplication.",
      "exampleTranslation": "Sets เก็บ unique unordered elements SADD เพิ่ม (return จำนวนที่เพิ่มใหม่), SREM ลบ SISMEMBER check O(1) Set operations SUNION/SINTER/SDIFF สำหรับรวม sets SRANDMEMBER สำหรับ random sampling เหมาะสำหรับ tags, unique counters, social relationships และ deduplication"
    },
    {
      "vocab": "What are Sorted Set commands in Redis?",
      "pronunciation": "# Add with scores\nZADD leaderboard 100 \"player1\"\nZADD leaderboard 85 \"player2\" 90 \"player3\"",
      "meaning": "Redis มี Sorted Set commands อะไรบ้าง?",
      "example": "Sorted Sets combine Set uniqueness with scores for ordering. ZADD adds with score, ZINCRBY updates. ZRANGE/ZREVRANGE get by rank, ZRANGEBYSCORE by score range. ZRANK gets position. O(log N) for most operations. Perfect for leaderboards, priority queues, time-series by timestamp, rate limiting.",
      "exampleTranslation": "Sorted Sets รวม Set uniqueness กับ scores สำหรับการเรียงลำดับ ZADD เพิ่มพร้อม score, ZINCRBY อัพเดท ZRANGE/ZREVRANGE ดึงตาม rank, ZRANGEBYSCORE ตาม score range ZRANK ดึง position O(log N) สำหรับ operations ส่วนใหญ่ เหมาะสำหรับ leaderboards, priority queues, time-series ตาม timestamp, rate limiting"
    },
    {
      "vocab": "What are Hash commands in Redis?",
      "pronunciation": "# Set fields\nHSET user:1 name \"John\" age 30\nHSETNX user:1 name \"John\"    # only if not exists",
      "meaning": "Redis มี Hash commands อะไรบ้าง?",
      "example": "Hashes store field-value pairs under a key - like objects. HSET sets fields, HGET retrieves. HGETALL gets entire hash. HINCRBY for field-level counters. More memory-efficient than separate keys for objects. Perfect for user profiles, sessions, product details, and any structured data.",
      "exampleTranslation": "Hashes เก็บ field-value pairs ภายใต้ key - เหมือน objects HSET set fields, HGET ดึง HGETALL ดึงทั้ง hash HINCRBY สำหรับ field-level counters ประหยัด memory กว่า keys แยกสำหรับ objects เหมาะสำหรับ user profiles, sessions, product details และ structured data ใดๆ"
    },
    {
      "vocab": "What is key expiration (TTL) in Redis?",
      "pronunciation": "# Set expiration on new key\nSET session:123 \"data\" EX 3600    # 1 hour in seconds\nSET session:123 \"data\" PX 60000   # 1 minute in milliseconds",
      "meaning": "Key expiration (TTL) ใน Redis คืออะไร?",
      "example": "TTL (Time To Live) automatically deletes keys after specified time. Set with EX/PX in SET command or EXPIRE after. TTL returns remaining seconds. Redis uses lazy deletion (on access) plus active expiration (background sampling). Essential for caching, sessions, rate limiting, and temporary data.",
      "exampleTranslation": "TTL (Time To Live) ลบ keys อัตโนมัติหลังเวลาที่กำหนด Set ด้วย EX/PX ใน SET command หรือ EXPIRE หลังจาก TTL return วินาทีที่เหลือ Redis ใช้ lazy deletion (เมื่อเข้าถึง) บวก active expiration (background sampling) จำเป็นสำหรับ caching, sessions, rate limiting และ temporary data"
    },
    {
      "vocab": "What is Redis Pub/Sub?",
      "pronunciation": "# Publisher\nPUBLISH news \"Breaking news!\"\nPUBLISH chat:room1 \"Hello everyone\"",
      "meaning": "Redis Pub/Sub คืออะไร?",
      "example": "Pub/Sub enables publish-subscribe messaging. Publishers send to channels, subscribers receive in real-time. PSUBSCRIBE allows pattern matching. Messages are fire-and-forget - not persisted, offline subscribers miss them. Good for real-time notifications, chat, live updates. For reliability, use Redis Streams instead.",
      "exampleTranslation": "Pub/Sub เปิดให้ publish-subscribe messaging Publishers ส่งไปยัง channels, subscribers รับแบบ real-time PSUBSCRIBE อนุญาต pattern matching Messages เป็น fire-and-forget - ไม่ persist, offline subscribers พลาดมัน ดีสำหรับ real-time notifications, chat, live updates สำหรับ reliability ใช้ Redis Streams แทน"
    },
    {
      "vocab": "What are Redis Streams?",
      "pronunciation": "# Add to stream\nXADD mystream * field1 value1 field2 value2\n# Returns ID like \"1234567890123-0\"",
      "meaning": "Redis Streams คืออะไร?",
      "example": "Streams are append-only log data structure. Each entry has auto-generated ID (timestamp-sequence). Supports consumer groups for distributed processing with acknowledgment. Unlike Pub/Sub, messages persist and can be replayed. Perfect for event sourcing, message queues, activity feeds, and log aggregation.",
      "exampleTranslation": "Streams คือ append-only log data structure แต่ละ entry มี auto-generated ID (timestamp-sequence) รองรับ consumer groups สำหรับ distributed processing พร้อม acknowledgment ไม่เหมือน Pub/Sub messages persist และ replay ได้ เหมาะสำหรับ event sourcing, message queues, activity feeds และ log aggregation"
    },
    {
      "vocab": "What are Redis transactions?",
      "pronunciation": "# Basic transaction\nMULTI                        # start transaction\nSET key1 \"value1\"",
      "meaning": "Redis transactions คืออะไร?",
      "example": "MULTI/EXEC queues commands and executes atomically. WATCH enables optimistic locking - transaction fails if watched key changed. No rollback: if one command fails, others still execute. For true atomicity with logic, use Lua scripts. Transactions isolate commands from other clients.",
      "exampleTranslation": "MULTI/EXEC queue commands และ execute แบบ atomic WATCH เปิดให้ optimistic locking - transaction fail ถ้า watched key เปลี่ยน ไม่มี rollback: ถ้า command หนึ่ง fail ตัวอื่นยัง execute สำหรับ atomicity จริงพร้อม logic ใช้ Lua scripts Transactions แยก commands จาก clients อื่น"
    },
    {
      "vocab": "What is Lua scripting in Redis?",
      "pronunciation": "# Execute Lua script\nEVAL \"return redis.call('GET', KEYS[1])\" 1 mykey\n# Script with logic",
      "meaning": "Lua scripting ใน Redis คืออะไร?",
      "example": "Lua scripts run atomically on Redis server. EVAL executes script with KEYS and ARGV arrays. Scripts can contain logic, loops, conditionals impossible in transactions. SCRIPT LOAD caches script, EVALSHA runs by hash (faster). Use for: atomic operations, complex logic, reducing round trips. Scripts block other commands while running.",
      "exampleTranslation": "Lua scripts รันแบบ atomic บน Redis server EVAL execute script ด้วย KEYS และ ARGV arrays Scripts มี logic, loops, conditionals ที่ทำไม่ได้ใน transactions SCRIPT LOAD cache script, EVALSHA รันด้วย hash (เร็วกว่า) ใช้สำหรับ: atomic operations, complex logic, ลด round trips Scripts block commands อื่นขณะรัน"
    },
    {
      "vocab": "What is Redis persistence (RDB vs AOF)?",
      "pronunciation": "# RDB - Point-in-time snapshots\n# redis.conf:\nsave 900 1        # snapshot if 1 change in 900 sec",
      "meaning": "Redis persistence (RDB vs AOF) คืออะไร?",
      "example": "RDB creates point-in-time snapshots at intervals. Fast restart, compact files, but may lose recent data. AOF logs every write operation - better durability but larger files. Use both: RDB for backups, AOF for durability. Redis 7+ supports hybrid: RDB snapshot with AOF for changes since snapshot.",
      "exampleTranslation": "RDB สร้าง point-in-time snapshots ตาม intervals Restart เร็ว files กะทัดรัด แต่อาจสูญเสีย data ล่าสุด AOF log ทุก write operation - durability ดีกว่าแต่ files ใหญ่กว่า ใช้ทั้งคู่: RDB สำหรับ backups, AOF สำหรับ durability Redis 7+ รองรับ hybrid: RDB snapshot กับ AOF สำหรับ changes หลัง snapshot"
    },
    {
      "vocab": "What is Redis replication?",
      "pronunciation": "# On replica server\nREPLICAOF master-ip 6379     # connect to master\nREPLICAOF NO ONE             # stop replication, become master",
      "meaning": "Redis replication คืออะไร?",
      "example": "Replication creates exact copies of master on replica servers. Replicas are read-only by default. Replication is asynchronous - replicas may lag slightly. Use for read scaling, high availability, and backups. WAIT command can force synchronous replication for critical writes.",
      "exampleTranslation": "Replication สร้าง copies ที่เหมือนกันของ master บน replica servers Replicas เป็น read-only โดย default Replication เป็น asynchronous - replicas อาจล่าช้าเล็กน้อย ใช้สำหรับ read scaling, high availability และ backups WAIT command บังคับ synchronous replication สำหรับ critical writes ได้"
    },
    {
      "vocab": "What is Redis Cluster?",
      "pronunciation": "# Cluster uses hash slots (16384 total)\n# Each node handles a range of slots\n# Key -> slot: CRC16(key) mod 16384",
      "meaning": "Redis Cluster คืออะไร?",
      "example": "Redis Cluster provides automatic sharding across multiple nodes. Data distributed using hash slots (16384 total). Each master handles subset of slots with optional replicas. Hash tags {} force related keys to same slot. Multi-key operations only work on same slot. Provides horizontal scaling and high availability.",
      "exampleTranslation": "Redis Cluster ให้ automatic sharding ข้าม nodes หลายตัว Data กระจายโดยใช้ hash slots (16384 รวม) แต่ละ master จัดการ subset ของ slots พร้อม replicas ที่เลือกได้ Hash tags {} บังคับ related keys ไปที่ slot เดียวกัน Multi-key operations ทำงานบน slot เดียวกันเท่านั้น ให้ horizontal scaling และ high availability"
    },
    {
      "vocab": "What is Redis Sentinel?",
      "pronunciation": "# Sentinel monitors master and replicas\n# Provides automatic failover\n# sentinel.conf",
      "meaning": "Redis Sentinel คืออะไร?",
      "example": "Sentinel provides high availability for non-clustered Redis. Monitors master and replicas, performs automatic failover if master fails. Multiple sentinels form quorum for reliability. Clients connect to sentinel to discover current master. Good for simpler setups without sharding needs.",
      "exampleTranslation": "Sentinel ให้ high availability สำหรับ Redis ที่ไม่ใช่ cluster Monitor master และ replicas ทำ automatic failover ถ้า master fail หลาย sentinels สร้าง quorum สำหรับ reliability Clients connect กับ sentinel เพื่อค้นหา current master ดีสำหรับ setups ที่ง่ายกว่าโดยไม่ต้อง sharding"
    },
    {
      "vocab": "What is the Cache-Aside pattern?",
      "pronunciation": "# Read pattern:\n# 1. Check cache\n# 2. If miss, read from database",
      "meaning": "Cache-Aside pattern คืออะไร?",
      "example": "Cache-Aside (Lazy Loading): application manages cache. On read: check cache, if miss load from DB and cache it. On write: update DB then invalidate cache (preferred) or update both. Simple and flexible. Downsides: first request always slow, cache may become stale if invalidation fails.",
      "exampleTranslation": "Cache-Aside (Lazy Loading): application จัดการ cache เมื่ออ่าน: check cache ถ้า miss load จาก DB และ cache มัน เมื่อเขียน: update DB แล้ว invalidate cache (แนะนำ) หรือ update ทั้งคู่ ง่ายและยืดหยุ่น ข้อเสีย: request แรก slow เสมอ cache อาจ stale ถ้า invalidation fail"
    },
    {
      "vocab": "What is Write-Through and Write-Behind caching?",
      "pronunciation": "# Write-Through:\n# Write to cache and DB synchronously\ndef save_user(user_id, data):",
      "meaning": "Write-Through และ Write-Behind caching คืออะไร?",
      "example": "Write-Through: write to cache and DB synchronously. Data always consistent but slower writes. Write-Behind: write to cache immediately, async sync to DB. Very fast writes but complex and risk of data loss if cache fails before sync. Choose based on consistency vs performance needs.",
      "exampleTranslation": "Write-Through: เขียนไปยัง cache และ DB พร้อมกัน Data consistent เสมอแต่เขียนช้ากว่า Write-Behind: เขียนไปยัง cache ทันที async sync ไปยัง DB เขียนเร็วมากแต่ซับซ้อนและเสี่ยงสูญเสีย data ถ้า cache fail ก่อน sync เลือกตาม consistency vs performance needs"
    },
    {
      "vocab": "What is cache stampede and how to prevent it?",
      "pronunciation": "# Problem: Many requests hit expired key simultaneously\n# All go to database, causing overload\n# Solution 1: Locking",
      "meaning": "Cache stampede คืออะไรและป้องกันอย่างไร?",
      "example": "Cache stampede occurs when many requests hit an expired key simultaneously, all querying the database. Solutions: 1) Locking - only one request refreshes, others wait. 2) Probabilistic early refresh - refresh before expiration based on probability. 3) Never expire with background refresh. Critical for high-traffic systems.",
      "exampleTranslation": "Cache stampede เกิดเมื่อหลาย requests hit expired key พร้อมกัน ทั้งหมด query database Solutions: 1) Locking - แค่ request เดียว refresh ที่เหลือรอ 2) Probabilistic early refresh - refresh ก่อน expiration ตาม probability 3) ไม่ expire กับ background refresh สำคัญสำหรับ high-traffic systems"
    },
    {
      "vocab": "What is distributed locking with Redis?",
      "pronunciation": "# Simple lock (single Redis)\nSET lock:resource value NX EX 30\n# NX = only if not exists",
      "meaning": "Distributed locking กับ Redis คืออะไร?",
      "example": "Use SET with NX (not exists) and EX (expiration) for simple locks. Always use unique value and verify before release. Lua script ensures atomic release. For multiple Redis instances, use Redlock algorithm (acquire on majority). Essential for preventing race conditions in distributed systems.",
      "exampleTranslation": "ใช้ SET กับ NX (not exists) และ EX (expiration) สำหรับ locks ง่ายๆ ใช้ unique value เสมอและ verify ก่อน release Lua script รับประกัน atomic release สำหรับหลาย Redis instances ใช้ Redlock algorithm (acquire บน majority) จำเป็นสำหรับป้องกัน race conditions ใน distributed systems"
    },
    {
      "vocab": "What is rate limiting with Redis?",
      "pronunciation": "# Fixed window counter\ndef is_allowed(user_id, limit=100, window=60):\n    key = f\"ratelimit:{user_id}:{int(time.time() / window)}\"",
      "meaning": "Rate limiting กับ Redis คืออะไร?",
      "example": "Fixed window: simple counter per time window, but allows burst at window edges. Sliding window (Sorted Set): tracks exact timestamps, more accurate but more memory. Token bucket: allows controlled bursting. Use pipelines or Lua for atomicity. Redis perfect for rate limiting due to speed and atomic operations.",
      "exampleTranslation": "Fixed window: counter ง่ายต่อ time window แต่อนุญาต burst ที่ขอบ window Sliding window (Sorted Set): track timestamps ที่แน่นอน แม่นยำกว่าแต่ใช้ memory มากกว่า Token bucket: อนุญาต controlled bursting ใช้ pipelines หรือ Lua สำหรับ atomicity Redis เหมาะสำหรับ rate limiting เพราะความเร็วและ atomic operations"
    },
    {
      "vocab": "What is Redis memory management?",
      "pronunciation": "# Check memory usage\nINFO memory\nMEMORY USAGE key        # memory for specific key",
      "meaning": "Redis memory management คืออะไร?",
      "example": "Set maxmemory to limit Redis memory usage. Eviction policies determine what to remove when full: LRU (least recently used), LFU (least frequently used), TTL-based, or random. allkeys-lru common for caches. Optimize with: hashes for small objects, short keys, TTLs. Monitor with INFO memory.",
      "exampleTranslation": "Set maxmemory เพื่อจำกัด Redis memory usage Eviction policies กำหนดว่าจะลบอะไรเมื่อเต็ม: LRU (least recently used), LFU (least frequently used), TTL-based หรือ random allkeys-lru ใช้บ่อยสำหรับ caches Optimize ด้วย: hashes สำหรับ small objects, keys สั้น, TTLs Monitor ด้วย INFO memory"
    },
    {
      "vocab": "What are Redis pipelining and batching?",
      "pronunciation": "# Without pipeline - one round trip per command\nredis.set(\"key1\", \"value1\")  # RTT\nredis.set(\"key2\", \"value2\")  # RTT",
      "meaning": "Redis pipelining และ batching คืออะไร?",
      "example": "Pipelining sends multiple commands in single network round trip without waiting for replies. Dramatically reduces latency when executing many commands. Commands execute in order but not atomically unless combined with MULTI/EXEC. Can improve throughput 5-10x. Essential for bulk operations.",
      "exampleTranslation": "Pipelining ส่งหลาย commands ใน single network round trip โดยไม่รอ replies ลด latency ได้มากเมื่อ execute หลาย commands Commands execute ตามลำดับแต่ไม่ atomic ยกเว้นรวมกับ MULTI/EXEC สามารถปรับปรุง throughput 5-10x จำเป็นสำหรับ bulk operations"
    },
    {
      "vocab": "What are Redis best practices?",
      "pronunciation": "# Key naming convention\nuser:123:profile           # object:id:field\nsession:abc123             # type:identifier",
      "meaning": "Redis best practices มีอะไรบ้าง?",
      "example": "Naming: use colons for hierarchy (user:123:profile). Keep values small (< 100KB). Use appropriate data types (Hash for objects, not JSON strings). Always set TTL for cache data. Avoid blocking commands (use SCAN instead of KEYS). Monitor with SLOWLOG. Use connection pooling in applications.",
      "exampleTranslation": "Naming: ใช้ colons สำหรับ hierarchy (user:123:profile) เก็บค่าให้เล็ก (< 100KB) ใช้ data types ที่เหมาะสม (Hash สำหรับ objects ไม่ใช่ JSON strings) Set TTL สำหรับ cache data เสมอ หลีกเลี่ยง blocking commands (ใช้ SCAN แทน KEYS) Monitor ด้วย SLOWLOG ใช้ connection pooling ใน applications"
    },
    {
      "vocab": "What is SCAN vs KEYS?",
      "pronunciation": "# KEYS - blocks Redis, avoid in production!\nKEYS user:*              # returns all matching keys\nKEYS *                   # NEVER do this!",
      "meaning": "SCAN vs KEYS ต่างกันอย่างไร?",
      "example": "KEYS blocks Redis while scanning entire keyspace - never use in production. SCAN is cursor-based, non-blocking, returns results incrementally. Use COUNT to hint batch size. May return duplicates or empty results in some iterations. Type-specific variants: SSCAN, HSCAN, ZSCAN. Always prefer SCAN for pattern matching.",
      "exampleTranslation": "KEYS block Redis ขณะ scan ทั้ง keyspace - ห้ามใช้ใน production SCAN เป็น cursor-based, non-blocking, return results แบบ incremental ใช้ COUNT เพื่อ hint batch size อาจ return duplicates หรือ empty results ในบาง iterations Type-specific variants: SSCAN, HSCAN, ZSCAN ใช้ SCAN สำหรับ pattern matching เสมอ"
    },
    {
      "vocab": "What is HyperLogLog?",
      "pronunciation": "# Count unique items with constant memory (~12KB)\nPFADD visitors \"user1\" \"user2\" \"user3\"\nPFADD visitors \"user1\" \"user4\"  # duplicate ignored",
      "meaning": "HyperLogLog คืออะไร?",
      "example": "HyperLogLog counts unique elements with constant memory (~12KB) regardless of cardinality. Standard error ~0.81%. PFADD adds elements, PFCOUNT returns approximate count, PFMERGE combines. Cannot retrieve actual elements. Perfect for unique visitor counts, event counting - anywhere exact count isn't required.",
      "exampleTranslation": "HyperLogLog นับ unique elements ด้วย constant memory (~12KB) ไม่ว่า cardinality จะเท่าไหร่ Standard error ~0.81% PFADD เพิ่ม elements, PFCOUNT return approximate count, PFMERGE รวม ดึง actual elements ไม่ได้ เหมาะสำหรับนับ unique visitors, event counting - ที่ไหนก็ตามที่ไม่ต้องการ exact count"
    },
    {
      "vocab": "What are Bitmaps in Redis?",
      "pronunciation": "# Set/Get individual bits\nSETBIT daily:active:2024-01-15 123 1   # user 123 active\nGETBIT daily:active:2024-01-15 123     # returns 1",
      "meaning": "Bitmaps ใน Redis คืออะไร?",
      "example": "Bitmaps are strings treated as bit arrays. SETBIT/GETBIT for individual bits. BITCOUNT counts set bits. BITOP performs AND/OR/XOR/NOT across bitmaps. Very memory efficient for per-user boolean flags (1M users = 125KB). Use for daily active users, feature flags, online status tracking.",
      "exampleTranslation": "Bitmaps คือ strings ที่ treat เป็น bit arrays SETBIT/GETBIT สำหรับ bits แต่ละตัว BITCOUNT นับ set bits BITOP ทำ AND/OR/XOR/NOT ข้าม bitmaps ประหยัด memory มากสำหรับ per-user boolean flags (1M users = 125KB) ใช้สำหรับ daily active users, feature flags, online status tracking"
    },
    {
      "vocab": "What is Geospatial indexing in Redis?",
      "pronunciation": "# Add locations (longitude, latitude, name)\nGEOADD stores -122.4194 37.7749 \"San Francisco\"\nGEOADD stores -73.9857 40.7484 \"New York\"",
      "meaning": "Geospatial indexing ใน Redis คืออะไร?",
      "example": "Redis Geo stores coordinates using Sorted Sets with geohash scores. GEOADD adds locations, GEODIST calculates distance, GEORADIUS/GEOSEARCH finds points within radius. Supports units (m, km, mi, ft). Good for store locators, nearby search, location-based features. Internally uses Sorted Set, so all ZSET commands work.",
      "exampleTranslation": "Redis Geo เก็บ coordinates โดยใช้ Sorted Sets กับ geohash scores GEOADD เพิ่ม locations, GEODIST คำนวณระยะทาง, GEORADIUS/GEOSEARCH หาจุดภายใน radius รองรับ units (m, km, mi, ft) ดีสำหรับ store locators, nearby search, location-based features ใช้ Sorted Set ภายใน ดังนั้น ZSET commands ทั้งหมดใช้ได้"
    },
    {
      "vocab": "What is Redis JSON (RedisJSON)?",
      "pronunciation": "# RedisJSON module - native JSON support\n# Set JSON document\nJSON.SET user:1 $ '{\"name\":\"John\",\"age\":30,\"email\":\"john@example.com\"}'",
      "meaning": "Redis JSON (RedisJSON) คืออะไร?",
      "example": "RedisJSON is a module for native JSON document storage. Supports JSONPath for queries, nested structures, in-place updates. JSON.SET stores, JSON.GET retrieves with path selection. Better than storing JSON strings: partial updates, atomic operations on nested data, array operations. Requires RedisJSON module.",
      "exampleTranslation": "RedisJSON คือ module สำหรับ native JSON document storage รองรับ JSONPath สำหรับ queries, nested structures, in-place updates JSON.SET เก็บ, JSON.GET ดึงด้วย path selection ดีกว่าเก็บ JSON strings: partial updates, atomic operations บน nested data, array operations ต้องมี RedisJSON module"
    },
    {
      "vocab": "What is the difference between Redis and Memcached?",
      "pronunciation": "# Redis advantages:\n# - Multiple data structures (not just strings)\n# - Persistence (RDB, AOF)",
      "meaning": "Redis และ Memcached ต่างกันอย่างไร?",
      "example": "Redis: rich data structures, persistence, replication, pub/sub, Lua scripting, single-threaded. Memcached: simple key-value, multi-threaded, no persistence, lower memory overhead. Choose Redis for complex needs (data structures, persistence, pub/sub). Choose Memcached for simple high-throughput string caching.",
      "exampleTranslation": "Redis: rich data structures, persistence, replication, pub/sub, Lua scripting, single-threaded Memcached: simple key-value, multi-threaded, ไม่มี persistence, memory overhead ต่ำกว่า เลือก Redis สำหรับ needs ที่ซับซ้อน (data structures, persistence, pub/sub) เลือก Memcached สำหรับ simple high-throughput string caching"
    },
    {
      "vocab": "What is Redis connection management?",
      "pronunciation": "# Check connected clients\nCLIENT LIST\nINFO clients",
      "meaning": "Redis connection management คืออะไร?",
      "example": "Use connection pooling in applications - don't create connection per request. Set appropriate pool size based on concurrency needs. Configure timeouts for reliability. Monitor with CLIENT LIST and INFO clients. Set client names for debugging. Handle connection errors with retry logic. Close idle connections.",
      "exampleTranslation": "ใช้ connection pooling ใน applications - อย่าสร้าง connection ต่อ request Set pool size ที่เหมาะสมตาม concurrency needs Configure timeouts สำหรับ reliability Monitor ด้วย CLIENT LIST และ INFO clients Set client names สำหรับ debugging Handle connection errors ด้วย retry logic ปิด idle connections"
    },
    {
      "vocab": "What is UNLINK vs DEL?",
      "pronunciation": "# DEL - synchronous deletion\nDEL key1 key2 key3\n# Blocks Redis until deletion complete",
      "meaning": "UNLINK vs DEL ต่างกันอย่างไร?",
      "example": "DEL deletes synchronously - blocks Redis until complete. UNLINK (Redis 4.0+) deletes asynchronously - returns immediately, actual deletion in background. Use UNLINK for large keys to avoid blocking. Both free memory eventually. FLUSHDB/FLUSHALL also support ASYNC option.",
      "exampleTranslation": "DEL ลบแบบ synchronous - block Redis จนกว่าจะเสร็จ UNLINK (Redis 4.0+) ลบแบบ asynchronous - return ทันที การลบจริงทำใน background ใช้ UNLINK สำหรับ large keys เพื่อหลีกเลี่ยง blocking ทั้งคู่ free memory ในที่สุด FLUSHDB/FLUSHALL ก็รองรับ ASYNC option"
    },
    {
      "vocab": "What are common Redis security practices?",
      "pronunciation": "# Set password\n# redis.conf: requirepass your_strong_password\nAUTH your_strong_password",
      "meaning": "Redis security practices มีอะไรบ้าง?",
      "example": "Set strong password (requirepass). Rename/disable dangerous commands (FLUSHALL, CONFIG, KEYS). Bind to specific interfaces, never 0.0.0.0 in production. Use ACLs (Redis 6+) for user permissions. Enable TLS for encryption. Use firewall rules, keep Redis in private network. Never expose directly to internet.",
      "exampleTranslation": "Set password ที่แข็งแรง (requirepass) Rename/disable dangerous commands (FLUSHALL, CONFIG, KEYS) Bind กับ specific interfaces ไม่ใช่ 0.0.0.0 ใน production ใช้ ACLs (Redis 6+) สำหรับ user permissions Enable TLS สำหรับ encryption ใช้ firewall rules เก็บ Redis ใน private network ห้าม expose ตรงไปยัง internet"
    }
  ]
}