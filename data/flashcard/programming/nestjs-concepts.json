{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "NestJS Concepts",
    "description": "Core NestJS concepts including modules, controllers, providers, dependency injection, guards, pipes, interceptors, and advanced patterns",
    "category": "Programming",
    "tags": ["nestjs", "nodejs", "typescript", "backend", "framework"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is NestJS and why use it?",
      "pronunciation": "",
      "meaning": "NestJS คืออะไรและทำไมต้องใช้?",
      "example": "NestJS is a progressive Node.js framework for building scalable server-side applications. Built with TypeScript, uses decorators and dependency injection (inspired by Angular). Provides structure and best practices out of the box. Supports REST, GraphQL, WebSockets, Microservices. Great for enterprise applications needing maintainability and testability.",
      "exampleTranslation": "NestJS คือ progressive Node.js framework สำหรับสร้าง scalable server-side applications สร้างด้วย TypeScript ใช้ decorators และ dependency injection (inspired by Angular) ให้ structure และ best practices ตั้งแต่แรก รองรับ REST, GraphQL, WebSockets, Microservices ดีสำหรับ enterprise applications ที่ต้องการ maintainability และ testability"
    },
    {
      "vocab": "What are Modules in NestJS?",
      "pronunciation": "@Module({ imports, controllers, providers, exports })",
      "meaning": "Modules ใน NestJS คืออะไร?",
      "example": "Modules organize application into cohesive blocks. Each module encapsulates related controllers, providers, and imports. @Module decorator defines: imports (other modules), controllers, providers, exports. Root AppModule imports all feature modules. Modules provide encapsulation and clear boundaries. Generate with 'nest g module name'.",
      "exampleTranslation": "Modules จัดระเบียบ application เป็น blocks ที่เกี่ยวข้องกัน แต่ละ module encapsulates controllers, providers และ imports ที่เกี่ยวข้อง @Module decorator กำหนด: imports (modules อื่น), controllers, providers, exports Root AppModule import feature modules ทั้งหมด Modules ให้ encapsulation และ boundaries ที่ชัดเจน Generate ด้วย 'nest g module name'"
    },
    {
      "vocab": "What are Controllers in NestJS?",
      "pronunciation": "@Controller('users') + @Get, @Post, @Put, @Delete",
      "meaning": "Controllers ใน NestJS คืออะไร?",
      "example": "Controllers handle incoming requests and return responses. @Controller('prefix') defines route prefix. HTTP method decorators: @Get, @Post, @Put, @Delete, @Patch. Parameter decorators: @Param, @Body, @Query, @Headers, @Req, @Res. Controllers should be thin - delegate logic to services. Generate with 'nest g controller name'.",
      "exampleTranslation": "Controllers จัดการ incoming requests และ return responses @Controller('prefix') กำหนด route prefix HTTP method decorators: @Get, @Post, @Put, @Delete, @Patch Parameter decorators: @Param, @Body, @Query, @Headers, @Req, @Res Controllers ควรบางเบา - delegate logic ให้ services Generate ด้วย 'nest g controller name'"
    },
    {
      "vocab": "What are Providers and Services?",
      "pronunciation": "@Injectable()",
      "meaning": "Providers และ Services คืออะไร?",
      "example": "Providers are classes marked with @Injectable() that can be injected via dependency injection. Services are the most common provider type - contain business logic. Register in module's providers array. Export to make available to other modules. Other provider types: repositories, factories, helpers. Separation of concerns: controllers handle HTTP, services handle logic.",
      "exampleTranslation": "Providers คือ classes ที่ mark ด้วย @Injectable() ที่ inject ผ่าน dependency injection ได้ Services เป็น provider type ที่พบบ่อยที่สุด - contain business logic Register ใน providers array ของ module Export เพื่อให้ modules อื่นใช้ได้ Provider types อื่น: repositories, factories, helpers Separation of concerns: controllers handle HTTP, services handle logic"
    },
    {
      "vocab": "How does Dependency Injection work in NestJS?",
      "pronunciation": "constructor(private service: Service) {}",
      "meaning": "Dependency Injection ทำงานอย่างไรใน NestJS?",
      "example": "DI lets NestJS manage class instantiation and dependencies. Declare dependencies in constructor - NestJS injects automatically. Providers must be registered in module. Scopes: DEFAULT (singleton), REQUEST (per request), TRANSIENT (per injection). Benefits: loose coupling, testability (easy mocking), maintainability. Use @Inject() for custom tokens.",
      "exampleTranslation": "DI ให้ NestJS จัดการ class instantiation และ dependencies Declare dependencies ใน constructor - NestJS inject อัตโนมัติ Providers ต้อง register ใน module Scopes: DEFAULT (singleton), REQUEST (per request), TRANSIENT (per injection) ข้อดี: loose coupling, testability (mock ง่าย), maintainability ใช้ @Inject() สำหรับ custom tokens"
    },
    {
      "vocab": "What is the request lifecycle in NestJS?",
      "pronunciation": "Middleware → Guards → Interceptors → Pipes → Handler",
      "meaning": "Request lifecycle ใน NestJS เป็นอย่างไร?",
      "example": "Request flows: Middleware → Guards → Interceptors (pre) → Pipes → Handler → Interceptors (post) → Exception Filters → Response. Each layer has specific responsibility. Guards handle auth, Pipes validate, Interceptors transform. Any layer can short-circuit request. Exception filters catch errors. Understanding lifecycle helps debug and optimize.",
      "exampleTranslation": "Request ไหลผ่าน: Middleware → Guards → Interceptors (pre) → Pipes → Handler → Interceptors (post) → Exception Filters → Response แต่ละ layer มีหน้าที่เฉพาะ Guards handle auth, Pipes validate, Interceptors transform Layer ใดก็ short-circuit request ได้ Exception filters catch errors เข้าใจ lifecycle ช่วย debug และ optimize"
    },
    {
      "vocab": "What are Pipes in NestJS?",
      "pronunciation": "ValidationPipe, ParseIntPipe",
      "meaning": "Pipes ใน NestJS คืออะไร?",
      "example": "Pipes transform and validate input data before reaching handler. Built-in: ValidationPipe, ParseIntPipe, ParseBoolPipe, ParseUUIDPipe, ParseArrayPipe. Apply to parameter, method, controller, or globally. ValidationPipe uses class-validator decorators. Options: whitelist (remove unknown), transform (auto-convert types). Custom pipes implement PipeTransform.",
      "exampleTranslation": "Pipes transform และ validate input data ก่อนถึง handler Built-in: ValidationPipe, ParseIntPipe, ParseBoolPipe, ParseUUIDPipe, ParseArrayPipe Apply กับ parameter, method, controller หรือ globally ValidationPipe ใช้ class-validator decorators Options: whitelist (remove unknown), transform (auto-convert types) Custom pipes implement PipeTransform"
    },
    {
      "vocab": "How to validate DTOs with class-validator?",
      "pronunciation": "@IsString, @IsEmail, @IsInt, @Min, @Max",
      "meaning": "วิธี validate DTOs ด้วย class-validator ทำอย่างไร?",
      "example": "Install class-validator and class-transformer. Add validation decorators to DTO properties: @IsString, @IsEmail, @IsInt, @Min, @Max, @IsOptional, @IsNotEmpty. Use @ValidateNested + @Type for nested objects. Enable ValidationPipe globally. whitelist removes unknown properties, transform auto-converts types. Custom messages: @IsEmail({}, {message: 'Invalid email'}).",
      "exampleTranslation": "Install class-validator และ class-transformer เพิ่ม validation decorators ให้ DTO properties: @IsString, @IsEmail, @IsInt, @Min, @Max, @IsOptional, @IsNotEmpty ใช้ @ValidateNested + @Type สำหรับ nested objects Enable ValidationPipe globally whitelist remove unknown properties, transform auto-convert types Custom messages: @IsEmail({}, {message: 'Invalid email'})"
    },
    {
      "vocab": "What are Guards in NestJS?",
      "pronunciation": "@UseGuards(AuthGuard) + CanActivate",
      "meaning": "Guards ใน NestJS คืออะไร?",
      "example": "Guards determine if request should proceed (authorization). Implement CanActivate interface with canActivate() method. Return true to proceed, false or throw exception to deny. ExecutionContext provides request details. Apply with @UseGuards() on method, controller, or globally. Common use: authentication, role-based access, rate limiting.",
      "exampleTranslation": "Guards กำหนดว่า request ควรดำเนินต่อหรือไม่ (authorization) Implement CanActivate interface ด้วย canActivate() method Return true เพื่อดำเนินต่อ false หรือ throw exception เพื่อ deny ExecutionContext ให้รายละเอียด request Apply ด้วย @UseGuards() บน method, controller หรือ globally ใช้บ่อย: authentication, role-based access, rate limiting"
    },
    {
      "vocab": "How to implement role-based authorization?",
      "pronunciation": "@Roles(Role.Admin) + SetMetadata + Reflector",
      "meaning": "วิธี implement role-based authorization ทำอย่างไร?",
      "example": "Create @Roles() decorator using SetMetadata to attach roles to routes. Create RolesGuard that uses Reflector to read metadata. Guard checks if user has required role. Apply AuthGuard first (sets user), then RolesGuard. Use @Roles(Role.Admin) on routes. Register guards globally or per-controller. Order matters: auth before roles.",
      "exampleTranslation": "สร้าง @Roles() decorator โดยใช้ SetMetadata เพื่อ attach roles ให้ routes สร้าง RolesGuard ที่ใช้ Reflector อ่าน metadata Guard check ว่า user มี required role หรือไม่ Apply AuthGuard ก่อน (sets user) แล้ว RolesGuard ใช้ @Roles(Role.Admin) บน routes Register guards globally หรือ per-controller ลำดับสำคัญ: auth ก่อน roles"
    },
    {
      "vocab": "What are Interceptors in NestJS?",
      "pronunciation": "@UseInterceptors() + NestInterceptor",
      "meaning": "Interceptors ใน NestJS คืออะไร?",
      "example": "Interceptors add extra logic before/after route handler. Implement NestInterceptor with intercept() method. next.handle() calls the handler, returns Observable. Use RxJS operators: map (transform), tap (side effects), catchError, timeout. Use cases: logging, response transformation, caching, timeout handling. Apply per-route, controller, or globally.",
      "exampleTranslation": "Interceptors เพิ่ม logic ก่อน/หลัง route handler Implement NestInterceptor ด้วย intercept() method next.handle() เรียก handler return Observable ใช้ RxJS operators: map (transform), tap (side effects), catchError, timeout Use cases: logging, response transformation, caching, timeout handling Apply per-route, controller หรือ globally"
    },
    {
      "vocab": "What are Exception Filters?",
      "pronunciation": "@Catch(HttpException) + ExceptionFilter",
      "meaning": "Exception Filters คืออะไร?",
      "example": "Exception filters handle thrown exceptions and format error responses. @Catch(ExceptionType) specifies which exceptions to handle. @Catch() with no argument catches all. ArgumentsHost provides access to request/response. Built-in exceptions: BadRequestException, UnauthorizedException, NotFoundException, etc. Apply globally to ensure consistent error format across app.",
      "exampleTranslation": "Exception filters จัดการ thrown exceptions และ format error responses @Catch(ExceptionType) ระบุว่า catch exceptions ไหน @Catch() โดยไม่มี argument catch ทั้งหมด ArgumentsHost ให้เข้าถึง request/response Built-in exceptions: BadRequestException, UnauthorizedException, NotFoundException เป็นต้น Apply globally เพื่อให้ error format consistent ทั่ว app"
    },
    {
      "vocab": "What is Middleware in NestJS?",
      "pronunciation": "NestMiddleware + configure(consumer)",
      "meaning": "Middleware ใน NestJS คืออะไร?",
      "example": "Middleware executes before route handler, similar to Express. Implement NestMiddleware or use function. Has access to req, res, next. Configure in module's configure() method using MiddlewareConsumer. Can apply to specific routes, exclude routes, chain multiple. Use for: logging, CORS, compression, body parsing. Runs before guards/interceptors.",
      "exampleTranslation": "Middleware execute ก่อน route handler คล้าย Express Implement NestMiddleware หรือใช้ function เข้าถึง req, res, next ได้ Configure ใน configure() method ของ module โดยใช้ MiddlewareConsumer Apply กับ routes เฉพาะ exclude routes chain หลายตัวได้ ใช้สำหรับ: logging, CORS, compression, body parsing รันก่อน guards/interceptors"
    },
    {
      "vocab": "How to create Custom Decorators?",
      "pronunciation": "createParamDecorator, SetMetadata, applyDecorators",
      "meaning": "วิธีสร้าง Custom Decorators ทำอย่างไร?",
      "example": "createParamDecorator creates parameter decorators to extract request data. SetMetadata attaches metadata for guards/interceptors. applyDecorators combines multiple decorators into one. ExecutionContext provides access to request. Use Reflector in guards to read metadata. Custom decorators reduce boilerplate and improve readability.",
      "exampleTranslation": "createParamDecorator สร้าง parameter decorators เพื่อ extract request data SetMetadata attach metadata สำหรับ guards/interceptors applyDecorators รวมหลาย decorators เป็นหนึ่งเดียว ExecutionContext ให้เข้าถึง request ใช้ Reflector ใน guards เพื่ออ่าน metadata Custom decorators ลด boilerplate และปรับปรุง readability"
    },
    {
      "vocab": "How to configure NestJS application?",
      "pronunciation": "ConfigModule.forRoot({ isGlobal: true })",
      "meaning": "วิธี configure NestJS application ทำอย่างไร?",
      "example": "Use @nestjs/config for configuration management. ConfigModule.forRoot() loads .env files. Set isGlobal: true for app-wide access. Use validationSchema with Joi to validate env vars. ConfigService.get() retrieves values. registerAs() creates namespaced configs. Supports multiple env files and custom config loaders.",
      "exampleTranslation": "ใช้ @nestjs/config สำหรับ configuration management ConfigModule.forRoot() load .env files Set isGlobal: true สำหรับ access ทั่ว app ใช้ validationSchema กับ Joi เพื่อ validate env vars ConfigService.get() ดึงค่า registerAs() สร้าง namespaced configs รองรับหลาย env files และ custom config loaders"
    },
    {
      "vocab": "How to integrate TypeORM with NestJS?",
      "pronunciation": "TypeOrmModule.forRoot() + @InjectRepository",
      "meaning": "วิธี integrate TypeORM กับ NestJS ทำอย่างไร?",
      "example": "Install @nestjs/typeorm and typeorm. TypeOrmModule.forRoot() in AppModule configures connection. Define entities with @Entity, @Column, @PrimaryGeneratedColumn. TypeOrmModule.forFeature([Entity]) in feature modules. Inject Repository<Entity> in services. synchronize: true auto-creates tables (dev only). Use migrations in production.",
      "exampleTranslation": "Install @nestjs/typeorm และ typeorm TypeOrmModule.forRoot() ใน AppModule configure connection กำหนด entities ด้วย @Entity, @Column, @PrimaryGeneratedColumn TypeOrmModule.forFeature([Entity]) ใน feature modules Inject Repository<Entity> ใน services synchronize: true สร้าง tables อัตโนมัติ (dev only) ใช้ migrations ใน production"
    },
    {
      "vocab": "How to integrate Prisma with NestJS?",
      "pronunciation": "PrismaService extends PrismaClient",
      "meaning": "วิธี integrate Prisma กับ NestJS ทำอย่างไร?",
      "example": "Install prisma and @prisma/client. Define schema in prisma/schema.prisma. Run 'npx prisma generate' after schema changes. Create PrismaService extending PrismaClient with lifecycle hooks. Register as provider in module. Inject and use in services. Prisma provides type-safe database access with auto-completion.",
      "exampleTranslation": "Install prisma และ @prisma/client กำหนด schema ใน prisma/schema.prisma รัน 'npx prisma generate' หลังเปลี่ยน schema สร้าง PrismaService extend PrismaClient พร้อม lifecycle hooks Register เป็น provider ใน module Inject และใช้ใน services Prisma ให้ type-safe database access พร้อม auto-completion"
    },
    {
      "vocab": "How to implement JWT Authentication?",
      "pronunciation": "JwtModule + PassportStrategy + AuthGuard('jwt')",
      "meaning": "วิธี implement JWT Authentication ทำอย่างไร?",
      "example": "Install @nestjs/jwt, @nestjs/passport, passport-jwt. Configure JwtModule with secret and expiration. Create JwtStrategy extending PassportStrategy to validate tokens. AuthService.login() generates token with JwtService.sign(). JwtAuthGuard extends AuthGuard('jwt'). Apply guard to protected routes. Token payload available via request.user.",
      "exampleTranslation": "Install @nestjs/jwt, @nestjs/passport, passport-jwt Configure JwtModule ด้วย secret และ expiration สร้าง JwtStrategy extend PassportStrategy เพื่อ validate tokens AuthService.login() generate token ด้วย JwtService.sign() JwtAuthGuard extends AuthGuard('jwt') Apply guard กับ protected routes Token payload available ผ่าน request.user"
    },
    {
      "vocab": "What are Custom Providers?",
      "pronunciation": "useClass, useValue, useFactory, useExisting",
      "meaning": "Custom Providers คืออะไร?",
      "example": "Custom providers give fine control over instantiation. useClass: specify class to instantiate. useValue: provide static value. useFactory: async factory function with dependencies (inject array). useExisting: alias to existing provider. Use cases: configuration values, async initialization, conditional providers (mock vs real), third-party integrations.",
      "exampleTranslation": "Custom providers ให้ control ละเอียดเหนือ instantiation useClass: ระบุ class ที่จะ instantiate useValue: ให้ static value useFactory: async factory function พร้อม dependencies (inject array) useExisting: alias ไปยัง provider ที่มีอยู่ Use cases: configuration values, async initialization, conditional providers (mock vs real), third-party integrations"
    },
    {
      "vocab": "What are Dynamic Modules?",
      "pronunciation": "static forRoot(): DynamicModule",
      "meaning": "Dynamic Modules คืออะไร?",
      "example": "Dynamic modules are configured at import time via static methods. forRoot() for sync configuration, forRootAsync() for async (e.g., from ConfigService). Return DynamicModule object with providers, exports, imports. Pattern used by ConfigModule, TypeOrmModule, etc. Enables reusable, configurable modules.",
      "exampleTranslation": "Dynamic modules ถูก configure ตอน import ผ่าน static methods forRoot() สำหรับ sync configuration, forRootAsync() สำหรับ async (เช่น จาก ConfigService) Return DynamicModule object พร้อม providers, exports, imports Pattern ที่ใช้โดย ConfigModule, TypeOrmModule เป็นต้น Enable reusable, configurable modules"
    },
    {
      "vocab": "How to test in NestJS?",
      "pronunciation": "Test.createTestingModule() + jest",
      "meaning": "วิธี test ใน NestJS ทำอย่างไร?",
      "example": "Use @nestjs/testing with Jest. Test.createTestingModule() creates isolated module for testing. Mock dependencies with useFactory or useValue. Unit tests: test services/controllers in isolation. E2E tests: test full HTTP request flow with supertest. DI makes mocking easy - replace real services with mocks.",
      "exampleTranslation": "ใช้ @nestjs/testing กับ Jest Test.createTestingModule() สร้าง isolated module สำหรับ testing Mock dependencies ด้วย useFactory หรือ useValue Unit tests: test services/controllers แบบ isolated E2E tests: test full HTTP request flow ด้วย supertest DI ทำให้ mocking ง่าย - แทนที่ real services ด้วย mocks"
    },
    {
      "vocab": "How to implement file upload?",
      "pronunciation": "FileInterceptor + @UploadedFile()",
      "meaning": "วิธี implement file upload ทำอย่างไร?",
      "example": "Use FileInterceptor from @nestjs/platform-express (wraps multer). @UploadedFile() extracts file, @UploadedFiles() for multiple. Configure storage (memory or disk), fileFilter for validation, limits for size. FilesInterceptor for multiple files with max count. FileFieldsInterceptor for different field names.",
      "exampleTranslation": "ใช้ FileInterceptor จาก @nestjs/platform-express (wraps multer) @UploadedFile() extract file, @UploadedFiles() สำหรับหลายไฟล์ Configure storage (memory หรือ disk), fileFilter สำหรับ validation, limits สำหรับ size FilesInterceptor สำหรับหลายไฟล์พร้อม max count FileFieldsInterceptor สำหรับ field names ต่างกัน"
    },
    {
      "vocab": "How to implement caching?",
      "pronunciation": "CacheModule + @CacheTTL() + CacheInterceptor",
      "meaning": "วิธี implement caching ทำอย่างไร?",
      "example": "Use @nestjs/cache-manager. CacheModule.register() with TTL and max items. CacheInterceptor auto-caches GET responses. @CacheTTL() and @CacheKey() customize behavior. Inject CACHE_MANAGER for manual control: get, set, del. Use Redis for distributed caching. Invalidate cache on data changes.",
      "exampleTranslation": "ใช้ @nestjs/cache-manager CacheModule.register() กับ TTL และ max items CacheInterceptor auto-cache GET responses @CacheTTL() และ @CacheKey() customize behavior Inject CACHE_MANAGER สำหรับ manual control: get, set, del ใช้ Redis สำหรับ distributed caching Invalidate cache เมื่อ data เปลี่ยน"
    },
    {
      "vocab": "How to implement WebSockets?",
      "pronunciation": "@WebSocketGateway() + @SubscribeMessage()",
      "meaning": "วิธี implement WebSockets ทำอย่างไร?",
      "example": "Use @nestjs/websockets with socket.io. @WebSocketGateway() creates gateway with options (cors, namespace). @WebSocketServer() injects Server instance. @SubscribeMessage('event') handles client messages. Lifecycle hooks: OnGatewayConnection, OnGatewayDisconnect. Use rooms for group messaging. Guards and Pipes work with gateways too.",
      "exampleTranslation": "ใช้ @nestjs/websockets กับ socket.io @WebSocketGateway() สร้าง gateway พร้อม options (cors, namespace) @WebSocketServer() inject Server instance @SubscribeMessage('event') handle client messages Lifecycle hooks: OnGatewayConnection, OnGatewayDisconnect ใช้ rooms สำหรับ group messaging Guards และ Pipes ใช้กับ gateways ได้เช่นกัน"
    },
    {
      "vocab": "How to implement GraphQL?",
      "pronunciation": "GraphQLModule + @Resolver + @Query + @Mutation",
      "meaning": "วิธี implement GraphQL ทำอย่างไร?",
      "example": "Use @nestjs/graphql with Apollo. Code-first approach: define types with @ObjectType, @Field decorators. Schema auto-generated. Resolvers use @Resolver, @Query, @Mutation, @Args. Schema-first: write .graphql files, generate types. GraphQL Playground for testing. Guards, Pipes, Interceptors work with GraphQL.",
      "exampleTranslation": "ใช้ @nestjs/graphql กับ Apollo Code-first approach: define types ด้วย @ObjectType, @Field decorators Schema auto-generated Resolvers ใช้ @Resolver, @Query, @Mutation, @Args Schema-first: เขียน .graphql files, generate types GraphQL Playground สำหรับ testing Guards, Pipes, Interceptors ใช้กับ GraphQL ได้"
    },
    {
      "vocab": "How to generate Swagger/OpenAPI documentation?",
      "pronunciation": "SwaggerModule + DocumentBuilder + @ApiProperty",
      "meaning": "วิธี generate Swagger/OpenAPI documentation ทำอย่างไร?",
      "example": "Use @nestjs/swagger. Configure with DocumentBuilder (title, version, auth). SwaggerModule.setup() creates /api docs endpoint. Decorate DTOs with @ApiProperty for request/response schemas. Decorate controllers with @ApiTags, @ApiOperation, @ApiResponse. Add @ApiBearerAuth for auth. Auto-generates interactive API documentation.",
      "exampleTranslation": "ใช้ @nestjs/swagger Configure ด้วย DocumentBuilder (title, version, auth) SwaggerModule.setup() สร้าง /api docs endpoint Decorate DTOs ด้วย @ApiProperty สำหรับ request/response schemas Decorate controllers ด้วย @ApiTags, @ApiOperation, @ApiResponse เพิ่ม @ApiBearerAuth สำหรับ auth Auto-generate interactive API documentation"
    },
    {
      "vocab": "What are Lifecycle Hooks?",
      "pronunciation": "OnModuleInit, OnApplicationBootstrap, OnModuleDestroy",
      "meaning": "Lifecycle Hooks คืออะไร?",
      "example": "Lifecycle hooks let you run code at specific points. OnModuleInit: after dependencies resolved (connect to DB). OnApplicationBootstrap: after all modules ready. OnModuleDestroy: during shutdown. OnApplicationShutdown: final cleanup. Enable with app.enableShutdownHooks(). Use for: database connections, cleanup, graceful shutdown.",
      "exampleTranslation": "Lifecycle hooks ให้รัน code ที่ specific points OnModuleInit: หลัง dependencies resolved (connect to DB) OnApplicationBootstrap: หลัง modules ทั้งหมดพร้อม OnModuleDestroy: ระหว่าง shutdown OnApplicationShutdown: final cleanup Enable ด้วย app.enableShutdownHooks() ใช้สำหรับ: database connections, cleanup, graceful shutdown"
    },
    {
      "vocab": "How to implement rate limiting?",
      "pronunciation": "ThrottlerModule + @Throttle() + @SkipThrottle()",
      "meaning": "วิธี implement rate limiting ทำอย่างไร?",
      "example": "Use @nestjs/throttler. Configure with ttl (time window) and limit (max requests). Apply ThrottlerGuard globally or per-route. @Throttle() overrides defaults, @SkipThrottle() bypasses. Multiple limits possible (short, medium, long). Use Redis storage for distributed systems. Returns 429 Too Many Requests when exceeded.",
      "exampleTranslation": "ใช้ @nestjs/throttler Configure ด้วย ttl (time window) และ limit (max requests) Apply ThrottlerGuard globally หรือ per-route @Throttle() override defaults, @SkipThrottle() bypasses Multiple limits ได้ (short, medium, long) ใช้ Redis storage สำหรับ distributed systems Return 429 Too Many Requests เมื่อเกิน"
    },
    {
      "vocab": "How to implement queues and background jobs?",
      "pronunciation": "BullModule + @Processor() + @Process()",
      "meaning": "วิธี implement queues และ background jobs ทำอย่างไร?",
      "example": "Use @nestjs/bull with Redis. Register queues in BullModule. Producer: @InjectQueue() then queue.add() to create jobs. Consumer: @Processor() class with @Process() methods. Options: delay, attempts, backoff, priority. Event handlers: @OnQueueActive, @OnQueueCompleted, @OnQueueFailed. Great for emails, notifications, heavy processing.",
      "exampleTranslation": "ใช้ @nestjs/bull กับ Redis Register queues ใน BullModule Producer: @InjectQueue() แล้ว queue.add() เพื่อสร้าง jobs Consumer: @Processor() class กับ @Process() methods Options: delay, attempts, backoff, priority Event handlers: @OnQueueActive, @OnQueueCompleted, @OnQueueFailed ดีสำหรับ emails, notifications, heavy processing"
    },
    {
      "vocab": "How to implement events and event-driven architecture?",
      "pronunciation": "EventEmitterModule + EventEmitter2.emit() + @OnEvent()",
      "meaning": "วิธี implement events และ event-driven architecture ทำอย่างไร?",
      "example": "Use @nestjs/event-emitter. EventEmitter2.emit() publishes events. @OnEvent('event.name') decorates listener methods. Supports wildcards (user.*), async listeners, multiple listeners per event. Decouples services - publishers don't know about subscribers. Great for: notifications, audit logs, side effects, CQRS.",
      "exampleTranslation": "ใช้ @nestjs/event-emitter EventEmitter2.emit() publish events @OnEvent('event.name') decorate listener methods รองรับ wildcards (user.*), async listeners, multiple listeners ต่อ event Decouple services - publishers ไม่รู้จัก subscribers ดีสำหรับ: notifications, audit logs, side effects, CQRS"
    },
    {
      "vocab": "How to handle circular dependencies?",
      "pronunciation": "forwardRef(() => Service)",
      "meaning": "วิธีจัดการ circular dependencies ทำอย่างไร?",
      "example": "Circular dependency: A needs B, B needs A. Solution 1: forwardRef() in both module imports and service injections - tells NestJS to resolve later. Solution 2: Refactor to extract shared service. Solution 3: ModuleRef for lazy resolution. Best practice: avoid circulars - use events or shared modules instead.",
      "exampleTranslation": "Circular dependency: A ต้องการ B, B ต้องการ A Solution 1: forwardRef() ทั้งใน module imports และ service injections - บอก NestJS ให้ resolve ทีหลัง Solution 2: Refactor เพื่อ extract shared service Solution 3: ModuleRef สำหรับ lazy resolution Best practice: หลีกเลี่ยง circulars - ใช้ events หรือ shared modules แทน"
    },
    {
      "vocab": "How to implement health checks?",
      "pronunciation": "TerminusModule + HealthCheckService",
      "meaning": "วิธี implement health checks ทำอย่างไร?",
      "example": "Use @nestjs/terminus for health checks. HealthCheckService.check() runs multiple indicators. Built-in: HttpHealthIndicator, TypeOrmHealthIndicator, MemoryHealthIndicator, DiskHealthIndicator. Create /health endpoint for orchestrators (Kubernetes). Separate liveness (app running) and readiness (dependencies ready) checks.",
      "exampleTranslation": "ใช้ @nestjs/terminus สำหรับ health checks HealthCheckService.check() รัน indicators หลายตัว Built-in: HttpHealthIndicator, TypeOrmHealthIndicator, MemoryHealthIndicator, DiskHealthIndicator สร้าง /health endpoint สำหรับ orchestrators (Kubernetes) แยก liveness (app running) และ readiness (dependencies ready) checks"
    },
    {
      "vocab": "What is serialization and how to use ClassSerializerInterceptor?",
      "pronunciation": "@Exclude(), @Expose(), @Transform()",
      "meaning": "Serialization และการใช้ ClassSerializerInterceptor คืออะไร?",
      "example": "Serialization transforms objects before sending response. Use class-transformer decorators: @Exclude (hide), @Expose (show/rename), @Transform (modify value), @Type (nested objects). ClassSerializerInterceptor applies transformations. Must return class instance, not plain object. Use groups for conditional fields (admin-only).",
      "exampleTranslation": "Serialization transform objects ก่อนส่ง response ใช้ class-transformer decorators: @Exclude (ซ่อน), @Expose (แสดง/rename), @Transform (modify value), @Type (nested objects) ClassSerializerInterceptor apply transformations ต้อง return class instance ไม่ใช่ plain object ใช้ groups สำหรับ conditional fields (admin-only)"
    },
    {
      "vocab": "How to implement API versioning?",
      "pronunciation": "app.enableVersioning() + @Version('1')",
      "meaning": "วิธี implement API versioning ทำอย่างไร?",
      "example": "Enable with app.enableVersioning(). Types: URI (/v1/), HEADER (X-API-Version), MEDIA_TYPE (Accept header). Set version on controller or route with @Version(). VERSION_NEUTRAL works for all versions. Separate controllers per version for major changes. Mix versions within same controller for minor differences.",
      "exampleTranslation": "Enable ด้วย app.enableVersioning() Types: URI (/v1/), HEADER (X-API-Version), MEDIA_TYPE (Accept header) Set version บน controller หรือ route ด้วย @Version() VERSION_NEUTRAL ใช้กับทุก versions แยก controllers ต่อ version สำหรับ major changes Mix versions ใน controller เดียวสำหรับ minor differences"
    },
    {
      "vocab": "What are best practices for NestJS applications?",
      "pronunciation": "",
      "meaning": "Best practices สำหรับ NestJS applications มีอะไรบ้าง?",
      "example": "Structure: feature modules in modules/ folder, shared code in common/. Keep controllers thin - delegate to services. Use DTOs with validation. Global pipes, filters, interceptors for consistency. Environment-based config. Repository pattern for data access. Write tests. Document with Swagger. Security: CORS, Helmet, rate limiting.",
      "exampleTranslation": "Structure: feature modules ใน modules/ folder, shared code ใน common/ Keep controllers บางเบา - delegate ให้ services ใช้ DTOs พร้อม validation Global pipes, filters, interceptors สำหรับ consistency Environment-based config Repository pattern สำหรับ data access เขียน tests Document ด้วย Swagger Security: CORS, Helmet, rate limiting"
    },
    {
      "vocab": "How to implement microservices in NestJS?",
      "pronunciation": "@MessagePattern() + @EventPattern() + ClientProxy",
      "meaning": "วิธี implement microservices ใน NestJS ทำอย่างไร?",
      "example": "Use @nestjs/microservices. Transports: TCP, Redis, MQTT, NATS, RabbitMQ, Kafka, gRPC. Server: @MessagePattern for request-response, @EventPattern for events. Client: ClientProxy.send() for request-response, emit() for events. Hybrid app: combine HTTP and microservice in same app. Great for distributed systems.",
      "exampleTranslation": "ใช้ @nestjs/microservices Transports: TCP, Redis, MQTT, NATS, RabbitMQ, Kafka, gRPC Server: @MessagePattern สำหรับ request-response, @EventPattern สำหรับ events Client: ClientProxy.send() สำหรับ request-response, emit() สำหรับ events Hybrid app: รวม HTTP และ microservice ใน app เดียว ดีสำหรับ distributed systems"
    },
    {
      "vocab": "What is CQRS pattern in NestJS?",
      "pronunciation": "CommandBus + QueryBus + EventBus",
      "meaning": "CQRS pattern ใน NestJS คืออะไร?",
      "example": "CQRS separates reads (Queries) from writes (Commands). Commands: change state, handled by CommandHandler. Queries: read data, handled by QueryHandler. Events: notify about changes, handled by EventsHandler. Use CommandBus/QueryBus to dispatch. Benefits: separate read/write models, scalability, clear intent. Use for complex domains.",
      "exampleTranslation": "CQRS แยก reads (Queries) จาก writes (Commands) Commands: เปลี่ยน state จัดการโดย CommandHandler Queries: อ่าน data จัดการโดย QueryHandler Events: notify เกี่ยวกับ changes จัดการโดย EventsHandler ใช้ CommandBus/QueryBus เพื่อ dispatch ข้อดี: แยก read/write models, scalability, clear intent ใช้สำหรับ complex domains"
    }
  ]
}
