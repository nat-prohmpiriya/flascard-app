{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "NestJS Concepts",
    "description": "Core NestJS concepts including modules, controllers, providers, dependency injection, guards, pipes, interceptors, and advanced patterns",
    "category": "Programming",
    "tags": ["nestjs", "nodejs", "typescript", "backend", "framework"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What is NestJS and why use it?",
      "pronunciation": "// NestJS: Progressive Node.js framework\n// Built with TypeScript, inspired by Angular\n\n// Key features:\n// - Modular architecture\n// - Dependency Injection (DI)\n// - Decorators-based\n// - Built-in support for:\n//   - REST APIs\n//   - GraphQL\n//   - WebSockets\n//   - Microservices\n\n// Create new project\nnpx @nestjs/cli new my-app\n\n// Project structure\nsrc/\n├── app.module.ts      // Root module\n├── app.controller.ts  // Basic controller\n├── app.service.ts     // Basic service\n└── main.ts            // Entry point\n\n// main.ts\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n}\nbootstrap();",
      "meaning": "NestJS คืออะไรและทำไมต้องใช้?",
      "example": "NestJS is a progressive Node.js framework for building scalable server-side applications. Built with TypeScript, uses decorators and dependency injection (inspired by Angular). Provides structure and best practices out of the box. Supports REST, GraphQL, WebSockets, Microservices. Great for enterprise applications needing maintainability and testability.",
      "exampleTranslation": "NestJS คือ progressive Node.js framework สำหรับสร้าง scalable server-side applications สร้างด้วย TypeScript ใช้ decorators และ dependency injection (inspired by Angular) ให้ structure และ best practices ตั้งแต่แรก รองรับ REST, GraphQL, WebSockets, Microservices ดีสำหรับ enterprise applications ที่ต้องการ maintainability และ testability"
    },
    {
      "vocab": "What are Modules in NestJS?",
      "pronunciation": "// Module: organizes related code\nimport { Module } from '@nestjs/common';\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\n\n@Module({\n  imports: [],        // other modules to import\n  controllers: [UsersController],  // request handlers\n  providers: [UsersService],       // services, repositories\n  exports: [UsersService]          // expose to other modules\n})\nexport class UsersModule {}\n\n// Root module (AppModule)\n@Module({\n  imports: [\n    UsersModule,\n    ProductsModule,\n    ConfigModule.forRoot(),  // dynamic module\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n\n// Generate module\nnest g module users\n\n// Feature module pattern\n// - Each feature has its own module\n// - Encapsulates related functionality\n// - Only exports what's needed",
      "meaning": "Modules ใน NestJS คืออะไร?",
      "example": "Modules organize application into cohesive blocks. Each module encapsulates related controllers, providers, and imports. @Module decorator defines: imports (other modules), controllers, providers, exports. Root AppModule imports all feature modules. Modules provide encapsulation and clear boundaries. Generate with 'nest g module name'.",
      "exampleTranslation": "Modules จัดระเบียบ application เป็น blocks ที่เกี่ยวข้องกัน แต่ละ module encapsulates controllers, providers และ imports ที่เกี่ยวข้อง @Module decorator กำหนด: imports (modules อื่น), controllers, providers, exports Root AppModule import feature modules ทั้งหมด Modules ให้ encapsulation และ boundaries ที่ชัดเจน Generate ด้วย 'nest g module name'"
    },
    {
      "vocab": "What are Controllers in NestJS?",
      "pronunciation": "import { Controller, Get, Post, Put, Delete, Param, Body, Query, HttpCode, Header } from '@nestjs/common';\nimport { CreateUserDto } from './dto/create-user.dto';\n\n@Controller('users')  // route prefix: /users\nexport class UsersController {\n  constructor(private usersService: UsersService) {}\n\n  @Get()  // GET /users\n  findAll(@Query('limit') limit: number) {\n    return this.usersService.findAll(limit);\n  }\n\n  @Get(':id')  // GET /users/:id\n  findOne(@Param('id') id: string) {\n    return this.usersService.findOne(id);\n  }\n\n  @Post()  // POST /users\n  @HttpCode(201)\n  create(@Body() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n\n  @Put(':id')  // PUT /users/:id\n  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {\n    return this.usersService.update(id, updateUserDto);\n  }\n\n  @Delete(':id')  // DELETE /users/:id\n  remove(@Param('id') id: string) {\n    return this.usersService.remove(id);\n  }\n}\n\n// nest g controller users",
      "meaning": "Controllers ใน NestJS คืออะไร?",
      "example": "Controllers handle incoming requests and return responses. @Controller('prefix') defines route prefix. HTTP method decorators: @Get, @Post, @Put, @Delete, @Patch. Parameter decorators: @Param, @Body, @Query, @Headers, @Req, @Res. Controllers should be thin - delegate logic to services. Generate with 'nest g controller name'.",
      "exampleTranslation": "Controllers จัดการ incoming requests และ return responses @Controller('prefix') กำหนด route prefix HTTP method decorators: @Get, @Post, @Put, @Delete, @Patch Parameter decorators: @Param, @Body, @Query, @Headers, @Req, @Res Controllers ควรบางเบา - delegate logic ให้ services Generate ด้วย 'nest g controller name'"
    },
    {
      "vocab": "What are Providers and Services?",
      "pronunciation": "import { Injectable } from '@nestjs/common';\n\n// Service: business logic\n@Injectable()  // marks class for DI\nexport class UsersService {\n  private users: User[] = [];\n\n  findAll(): User[] {\n    return this.users;\n  }\n\n  findOne(id: string): User {\n    return this.users.find(user => user.id === id);\n  }\n\n  create(createUserDto: CreateUserDto): User {\n    const user = { id: uuid(), ...createUserDto };\n    this.users.push(user);\n    return user;\n  }\n}\n\n// Register in module\n@Module({\n  providers: [UsersService],  // available within module\n  exports: [UsersService],    // available to other modules\n})\nexport class UsersModule {}\n\n// Types of providers:\n// - Services (business logic)\n// - Repositories (data access)\n// - Factories (complex creation)\n// - Helpers (utilities)\n\n// nest g service users",
      "meaning": "Providers และ Services คืออะไร?",
      "example": "Providers are classes marked with @Injectable() that can be injected via dependency injection. Services are the most common provider type - contain business logic. Register in module's providers array. Export to make available to other modules. Other provider types: repositories, factories, helpers. Separation of concerns: controllers handle HTTP, services handle logic.",
      "exampleTranslation": "Providers คือ classes ที่ mark ด้วย @Injectable() ที่ inject ผ่าน dependency injection ได้ Services เป็น provider type ที่พบบ่อยที่สุด - contain business logic Register ใน providers array ของ module Export เพื่อให้ modules อื่นใช้ได้ Provider types อื่น: repositories, factories, helpers Separation of concerns: controllers handle HTTP, services handle logic"
    },
    {
      "vocab": "How does Dependency Injection work in NestJS?",
      "pronunciation": "// Constructor injection (most common)\n@Controller('users')\nexport class UsersController {\n  constructor(\n    private usersService: UsersService,\n    private logger: LoggerService,\n  ) {}\n}\n\n// NestJS automatically:\n// 1. Sees UsersService in constructor\n// 2. Looks up UsersService in providers\n// 3. Creates instance (or reuses singleton)\n// 4. Injects into controller\n\n// Property injection (less common)\n@Controller('users')\nexport class UsersController {\n  @Inject(UsersService)\n  private usersService: UsersService;\n}\n\n// Custom provider token\nconst CONFIG = Symbol('CONFIG');\n\n@Module({\n  providers: [\n    {\n      provide: CONFIG,\n      useValue: { apiKey: 'xxx' },\n    },\n  ],\n})\nexport class AppModule {}\n\n// Inject with token\nconstructor(@Inject(CONFIG) private config: ConfigType) {}\n\n// Provider scopes\n@Injectable({ scope: Scope.DEFAULT })    // Singleton (default)\n@Injectable({ scope: Scope.REQUEST })    // New instance per request\n@Injectable({ scope: Scope.TRANSIENT })  // New instance each injection",
      "meaning": "Dependency Injection ทำงานอย่างไรใน NestJS?",
      "example": "DI lets NestJS manage class instantiation and dependencies. Declare dependencies in constructor - NestJS injects automatically. Providers must be registered in module. Scopes: DEFAULT (singleton), REQUEST (per request), TRANSIENT (per injection). Benefits: loose coupling, testability (easy mocking), maintainability. Use @Inject() for custom tokens.",
      "exampleTranslation": "DI ให้ NestJS จัดการ class instantiation และ dependencies Declare dependencies ใน constructor - NestJS inject อัตโนมัติ Providers ต้อง register ใน module Scopes: DEFAULT (singleton), REQUEST (per request), TRANSIENT (per injection) ข้อดี: loose coupling, testability (mock ง่าย), maintainability ใช้ @Inject() สำหรับ custom tokens"
    },
    {
      "vocab": "What is the request lifecycle in NestJS?",
      "pronunciation": "// Request flows through these layers (in order):\n\n// 1. Middleware\n//    ↓\n// 2. Guards (authentication/authorization)\n//    ↓\n// 3. Interceptors (pre-processing)\n//    ↓\n// 4. Pipes (validation/transformation)\n//    ↓\n// 5. Route Handler (controller method)\n//    ↓\n// 6. Interceptors (post-processing)\n//    ↓\n// 7. Exception Filters (if error)\n//    ↓\n// 8. Response\n\n// Example flow:\n// Request: POST /users {name: \"john\"}\n\n// 1. LoggerMiddleware logs request\n// 2. AuthGuard checks JWT token\n// 3. LoggingInterceptor starts timer\n// 4. ValidationPipe validates DTO\n// 5. UsersController.create() executes\n// 6. LoggingInterceptor logs duration\n// 7. (If error) HttpExceptionFilter formats error\n// 8. Response sent to client\n\n// Each layer can:\n// - Short-circuit the request\n// - Transform data\n// - Add metadata\n// - Handle errors",
      "meaning": "Request lifecycle ใน NestJS เป็นอย่างไร?",
      "example": "Request flows: Middleware → Guards → Interceptors (pre) → Pipes → Handler → Interceptors (post) → Exception Filters → Response. Each layer has specific responsibility. Guards handle auth, Pipes validate, Interceptors transform. Any layer can short-circuit request. Exception filters catch errors. Understanding lifecycle helps debug and optimize.",
      "exampleTranslation": "Request ไหลผ่าน: Middleware → Guards → Interceptors (pre) → Pipes → Handler → Interceptors (post) → Exception Filters → Response แต่ละ layer มีหน้าที่เฉพาะ Guards handle auth, Pipes validate, Interceptors transform Layer ใดก็ short-circuit request ได้ Exception filters catch errors เข้าใจ lifecycle ช่วย debug และ optimize"
    },
    {
      "vocab": "What are Pipes in NestJS?",
      "pronunciation": "import { PipeTransform, Injectable, BadRequestException } from '@nestjs/common';\n\n// Built-in pipes\nimport { ValidationPipe, ParseIntPipe, ParseBoolPipe, ParseUUIDPipe } from '@nestjs/common';\n\n@Controller('users')\nexport class UsersController {\n  // ParseIntPipe: convert string to number\n  @Get(':id')\n  findOne(@Param('id', ParseIntPipe) id: number) {\n    return this.usersService.findOne(id);\n  }\n\n  // ValidationPipe: validate DTO\n  @Post()\n  create(@Body(ValidationPipe) createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n}\n\n// Global validation pipe\n// main.ts\napp.useGlobalPipes(new ValidationPipe({\n  whitelist: true,        // strip unknown properties\n  forbidNonWhitelisted: true,  // throw on unknown\n  transform: true,        // auto-transform types\n}));\n\n// Custom pipe\n@Injectable()\nexport class ParseDatePipe implements PipeTransform {\n  transform(value: string): Date {\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n      throw new BadRequestException('Invalid date format');\n    }\n    return date;\n  }\n}",
      "meaning": "Pipes ใน NestJS คืออะไร?",
      "example": "Pipes transform and validate input data before reaching handler. Built-in: ValidationPipe, ParseIntPipe, ParseBoolPipe, ParseUUIDPipe, ParseArrayPipe. Apply to parameter, method, controller, or globally. ValidationPipe uses class-validator decorators. Options: whitelist (remove unknown), transform (auto-convert types). Custom pipes implement PipeTransform.",
      "exampleTranslation": "Pipes transform และ validate input data ก่อนถึง handler Built-in: ValidationPipe, ParseIntPipe, ParseBoolPipe, ParseUUIDPipe, ParseArrayPipe Apply กับ parameter, method, controller หรือ globally ValidationPipe ใช้ class-validator decorators Options: whitelist (remove unknown), transform (auto-convert types) Custom pipes implement PipeTransform"
    },
    {
      "vocab": "How to validate DTOs with class-validator?",
      "pronunciation": "// Install: npm i class-validator class-transformer\n\nimport { IsString, IsEmail, IsInt, Min, Max, IsOptional, IsNotEmpty, MinLength, IsEnum, ValidateNested } from 'class-validator';\nimport { Type } from 'class-transformer';\n\nexport class CreateUserDto {\n  @IsString()\n  @IsNotEmpty()\n  @MinLength(2)\n  name: string;\n\n  @IsEmail()\n  email: string;\n\n  @IsInt()\n  @Min(0)\n  @Max(120)\n  age: number;\n\n  @IsOptional()\n  @IsString()\n  bio?: string;\n\n  @IsEnum(Role)\n  role: Role;\n\n  // Nested object validation\n  @ValidateNested()\n  @Type(() => AddressDto)\n  address: AddressDto;\n\n  // Array validation\n  @ValidateNested({ each: true })\n  @Type(() => PhoneDto)\n  phones: PhoneDto[];\n}\n\n// Enable globally in main.ts\napp.useGlobalPipes(new ValidationPipe({\n  whitelist: true,\n  transform: true,\n  forbidNonWhitelisted: true,\n}));\n\n// Common decorators:\n// @IsString, @IsNumber, @IsBoolean, @IsArray\n// @IsDate, @IsUUID, @IsUrl, @Matches(regex)\n// @ArrayMinSize, @ArrayMaxSize, @ArrayUnique",
      "meaning": "วิธี validate DTOs ด้วย class-validator ทำอย่างไร?",
      "example": "Install class-validator and class-transformer. Add validation decorators to DTO properties: @IsString, @IsEmail, @IsInt, @Min, @Max, @IsOptional, @IsNotEmpty. Use @ValidateNested + @Type for nested objects. Enable ValidationPipe globally. whitelist removes unknown properties, transform auto-converts types. Custom messages: @IsEmail({}, {message: 'Invalid email'}).",
      "exampleTranslation": "Install class-validator และ class-transformer เพิ่ม validation decorators ให้ DTO properties: @IsString, @IsEmail, @IsInt, @Min, @Max, @IsOptional, @IsNotEmpty ใช้ @ValidateNested + @Type สำหรับ nested objects Enable ValidationPipe globally whitelist remove unknown properties, transform auto-convert types Custom messages: @IsEmail({}, {message: 'Invalid email'})"
    },
    {
      "vocab": "What are Guards in NestJS?",
      "pronunciation": "import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';\n\n// Guard: determines if request should proceed\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const request = context.switchToHttp().getRequest();\n    const token = request.headers.authorization?.split(' ')[1];\n    \n    if (!token) {\n      throw new UnauthorizedException('No token provided');\n    }\n    \n    try {\n      const user = await this.authService.validateToken(token);\n      request.user = user;  // attach user to request\n      return true;\n    } catch {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n}\n\n// Apply guard\n@Controller('users')\n@UseGuards(AuthGuard)  // all routes in controller\nexport class UsersController {\n  @Get('profile')\n  @UseGuards(AuthGuard)  // single route\n  getProfile() {}\n}\n\n// Global guard\n// main.ts\napp.useGlobalGuards(new AuthGuard());\n\n// Or via module (enables DI)\n@Module({\n  providers: [{ provide: APP_GUARD, useClass: AuthGuard }],\n})",
      "meaning": "Guards ใน NestJS คืออะไร?",
      "example": "Guards determine if request should proceed (authorization). Implement CanActivate interface with canActivate() method. Return true to proceed, false or throw exception to deny. ExecutionContext provides request details. Apply with @UseGuards() on method, controller, or globally. Common use: authentication, role-based access, rate limiting.",
      "exampleTranslation": "Guards กำหนดว่า request ควรดำเนินต่อหรือไม่ (authorization) Implement CanActivate interface ด้วย canActivate() method Return true เพื่อดำเนินต่อ false หรือ throw exception เพื่อ deny ExecutionContext ให้รายละเอียด request Apply ด้วย @UseGuards() บน method, controller หรือ globally ใช้บ่อย: authentication, role-based access, rate limiting"
    },
    {
      "vocab": "How to implement role-based authorization?",
      "pronunciation": "// roles.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);\n\n// roles.guard.ts\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(\n      ROLES_KEY,\n      [context.getHandler(), context.getClass()]\n    );\n    \n    if (!requiredRoles) {\n      return true;  // no roles required\n    }\n    \n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some(role => user.roles?.includes(role));\n  }\n}\n\n// Usage in controller\n@Controller('admin')\n@UseGuards(AuthGuard, RolesGuard)\nexport class AdminController {\n  @Get('dashboard')\n  @Roles(Role.Admin)  // only admins\n  getDashboard() {}\n\n  @Get('reports')\n  @Roles(Role.Admin, Role.Manager)  // admin or manager\n  getReports() {}\n}\n\n// Apply globally\n@Module({\n  providers: [\n    { provide: APP_GUARD, useClass: AuthGuard },\n    { provide: APP_GUARD, useClass: RolesGuard },\n  ],\n})",
      "meaning": "วิธี implement role-based authorization ทำอย่างไร?",
      "example": "Create @Roles() decorator using SetMetadata to attach roles to routes. Create RolesGuard that uses Reflector to read metadata. Guard checks if user has required role. Apply AuthGuard first (sets user), then RolesGuard. Use @Roles(Role.Admin) on routes. Register guards globally or per-controller. Order matters: auth before roles.",
      "exampleTranslation": "สร้าง @Roles() decorator โดยใช้ SetMetadata เพื่อ attach roles ให้ routes สร้าง RolesGuard ที่ใช้ Reflector อ่าน metadata Guard check ว่า user มี required role หรือไม่ Apply AuthGuard ก่อน (sets user) แล้ว RolesGuard ใช้ @Roles(Role.Admin) บน routes Register guards globally หรือ per-controller ลำดับสำคัญ: auth ก่อน roles"
    },
    {
      "vocab": "What are Interceptors in NestJS?",
      "pronunciation": "import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { map, tap } from 'rxjs/operators';\n\n// Interceptor: transform request/response, add logic\n@Injectable()\nexport class LoggingInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const now = Date.now();\n    console.log('Before...');\n    \n    return next\n      .handle()  // calls route handler\n      .pipe(\n        tap(() => console.log(`After... ${Date.now() - now}ms`)),\n      );\n  }\n}\n\n// Transform response\n@Injectable()\nexport class TransformInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next.handle().pipe(\n      map(data => ({\n        success: true,\n        data,\n        timestamp: new Date().toISOString(),\n      })),\n    );\n  }\n}\n\n// Apply interceptor\n@UseInterceptors(LoggingInterceptor)\n@Controller('users')\nexport class UsersController {}\n\n// Global\napp.useGlobalInterceptors(new TransformInterceptor());\n\n// Use cases: logging, caching, response mapping, timeout",
      "meaning": "Interceptors ใน NestJS คืออะไร?",
      "example": "Interceptors add extra logic before/after route handler. Implement NestInterceptor with intercept() method. next.handle() calls the handler, returns Observable. Use RxJS operators: map (transform), tap (side effects), catchError, timeout. Use cases: logging, response transformation, caching, timeout handling. Apply per-route, controller, or globally.",
      "exampleTranslation": "Interceptors เพิ่ม logic ก่อน/หลัง route handler Implement NestInterceptor ด้วย intercept() method next.handle() เรียก handler return Observable ใช้ RxJS operators: map (transform), tap (side effects), catchError, timeout Use cases: logging, response transformation, caching, timeout handling Apply per-route, controller หรือ globally"
    },
    {
      "vocab": "What are Exception Filters?",
      "pronunciation": "import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus } from '@nestjs/common';\n\n// Catch specific exception\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getRequest();\n    const status = exception.getStatus();\n\n    response.status(status).json({\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      message: exception.message,\n    });\n  }\n}\n\n// Catch all exceptions\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter {\n  catch(exception: unknown, host: ArgumentsHost) {\n    const status = exception instanceof HttpException\n      ? exception.getStatus()\n      : HttpStatus.INTERNAL_SERVER_ERROR;\n    \n    // log error, format response...\n  }\n}\n\n// Apply filter\n@UseFilters(HttpExceptionFilter)\n@Controller('users')\nexport class UsersController {}\n\n// Global\napp.useGlobalFilters(new AllExceptionsFilter());\n\n// Built-in exceptions\nthrow new BadRequestException('Invalid input');\nthrow new UnauthorizedException();\nthrow new NotFoundException('User not found');\nthrow new ForbiddenException();\nthrow new ConflictException();",
      "meaning": "Exception Filters คืออะไร?",
      "example": "Exception filters handle thrown exceptions and format error responses. @Catch(ExceptionType) specifies which exceptions to handle. @Catch() with no argument catches all. ArgumentsHost provides access to request/response. Built-in exceptions: BadRequestException, UnauthorizedException, NotFoundException, etc. Apply globally to ensure consistent error format across app.",
      "exampleTranslation": "Exception filters จัดการ thrown exceptions และ format error responses @Catch(ExceptionType) ระบุว่า catch exceptions ไหน @Catch() โดยไม่มี argument catch ทั้งหมด ArgumentsHost ให้เข้าถึง request/response Built-in exceptions: BadRequestException, UnauthorizedException, NotFoundException เป็นต้น Apply globally เพื่อให้ error format consistent ทั่ว app"
    },
    {
      "vocab": "What is Middleware in NestJS?",
      "pronunciation": "import { Injectable, NestMiddleware } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\n\n// Class middleware\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware {\n  use(req: Request, res: Response, next: NextFunction) {\n    console.log(`${req.method} ${req.url}`);\n    next();  // pass to next middleware/handler\n  }\n}\n\n// Function middleware\nexport function logger(req: Request, res: Response, next: NextFunction) {\n  console.log('Request...');\n  next();\n}\n\n// Apply in module\n@Module({...})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer\n      .apply(LoggerMiddleware, cors(), helmet())\n      .exclude(\n        { path: 'health', method: RequestMethod.GET },\n      )\n      .forRoutes(\n        { path: 'users', method: RequestMethod.ALL },\n        UsersController,  // or entire controller\n        '*',  // all routes\n      );\n  }\n}\n\n// Global middleware (Express-style)\n// main.ts\napp.use(cors());\napp.use(helmet());\napp.use(compression());\n\n// Middleware vs Interceptor:\n// Middleware: Express-compatible, runs first\n// Interceptor: NestJS-specific, can access ExecutionContext",
      "meaning": "Middleware ใน NestJS คืออะไร?",
      "example": "Middleware executes before route handler, similar to Express. Implement NestMiddleware or use function. Has access to req, res, next. Configure in module's configure() method using MiddlewareConsumer. Can apply to specific routes, exclude routes, chain multiple. Use for: logging, CORS, compression, body parsing. Runs before guards/interceptors.",
      "exampleTranslation": "Middleware execute ก่อน route handler คล้าย Express Implement NestMiddleware หรือใช้ function เข้าถึง req, res, next ได้ Configure ใน configure() method ของ module โดยใช้ MiddlewareConsumer Apply กับ routes เฉพาะ exclude routes chain หลายตัวได้ ใช้สำหรับ: logging, CORS, compression, body parsing รันก่อน guards/interceptors"
    },
    {
      "vocab": "How to create Custom Decorators?",
      "pronunciation": "import { createParamDecorator, ExecutionContext, SetMetadata, applyDecorators, UseGuards } from '@nestjs/common';\n\n// Parameter decorator: extract data from request\nexport const User = createParamDecorator(\n  (data: string, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    const user = request.user;\n    return data ? user?.[data] : user;  // @User() or @User('email')\n  },\n);\n\n// Usage\n@Get('profile')\ngetProfile(@User() user: UserEntity) {}\n\n@Get('email')\ngetEmail(@User('email') email: string) {}\n\n// Metadata decorator\nexport const Public = () => SetMetadata('isPublic', true);\n\n// Composed decorator: combine multiple decorators\nexport function Auth(...roles: Role[]) {\n  return applyDecorators(\n    SetMetadata('roles', roles),\n    UseGuards(AuthGuard, RolesGuard),\n    ApiBearerAuth(),  // Swagger\n  );\n}\n\n// Usage\n@Get('admin')\n@Auth(Role.Admin)\ngetAdminData() {}\n\n// Class decorator\nexport function Controller(prefix: string): ClassDecorator {\n  return (target: Function) => {\n    Reflect.defineMetadata('prefix', prefix, target);\n  };\n}",
      "meaning": "วิธีสร้าง Custom Decorators ทำอย่างไร?",
      "example": "createParamDecorator creates parameter decorators to extract request data. SetMetadata attaches metadata for guards/interceptors. applyDecorators combines multiple decorators into one. ExecutionContext provides access to request. Use Reflector in guards to read metadata. Custom decorators reduce boilerplate and improve readability.",
      "exampleTranslation": "createParamDecorator สร้าง parameter decorators เพื่อ extract request data SetMetadata attach metadata สำหรับ guards/interceptors applyDecorators รวมหลาย decorators เป็นหนึ่งเดียว ExecutionContext ให้เข้าถึง request ใช้ Reflector ใน guards เพื่ออ่าน metadata Custom decorators ลด boilerplate และปรับปรุง readability"
    },
    {
      "vocab": "How to configure NestJS application?",
      "pronunciation": "// Install: npm i @nestjs/config\n\n// app.module.ts\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true,           // available everywhere\n      envFilePath: ['.env.local', '.env'],\n      load: [databaseConfig],   // custom config files\n      validationSchema: Joi.object({  // validate env\n        NODE_ENV: Joi.string().valid('development', 'production'),\n        PORT: Joi.number().default(3000),\n      }),\n    }),\n  ],\n})\nexport class AppModule {}\n\n// Use ConfigService\n@Injectable()\nexport class AppService {\n  constructor(private configService: ConfigService) {}\n\n  getPort(): number {\n    return this.configService.get<number>('PORT');\n  }\n\n  getDatabaseUrl(): string {\n    return this.configService.get('DATABASE_URL');\n  }\n}\n\n// Custom config file\n// config/database.config.ts\nexport default registerAs('database', () => ({\n  host: process.env.DB_HOST,\n  port: parseInt(process.env.DB_PORT, 10) || 5432,\n}));\n\n// Access namespaced config\nthis.configService.get('database.host');",
      "meaning": "วิธี configure NestJS application ทำอย่างไร?",
      "example": "Use @nestjs/config for configuration management. ConfigModule.forRoot() loads .env files. Set isGlobal: true for app-wide access. Use validationSchema with Joi to validate env vars. ConfigService.get() retrieves values. registerAs() creates namespaced configs. Supports multiple env files and custom config loaders.",
      "exampleTranslation": "ใช้ @nestjs/config สำหรับ configuration management ConfigModule.forRoot() load .env files Set isGlobal: true สำหรับ access ทั่ว app ใช้ validationSchema กับ Joi เพื่อ validate env vars ConfigService.get() ดึงค่า registerAs() สร้าง namespaced configs รองรับหลาย env files และ custom config loaders"
    },
    {
      "vocab": "How to integrate TypeORM with NestJS?",
      "pronunciation": "// Install: npm i @nestjs/typeorm typeorm pg\n\n// app.module.ts\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      host: 'localhost',\n      port: 5432,\n      username: 'user',\n      password: 'password',\n      database: 'mydb',\n      entities: [User, Post],\n      synchronize: true,  // dev only!\n    }),\n  ],\n})\nexport class AppModule {}\n\n// Entity\nimport { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';\n\n@Entity()\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column({ unique: true })\n  email: string;\n\n  @OneToMany(() => Post, post => post.author)\n  posts: Post[];\n}\n\n// Feature module\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  providers: [UsersService],\n})\nexport class UsersModule {}\n\n// Service with repository\n@Injectable()\nexport class UsersService {\n  constructor(\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n  ) {}\n\n  findAll(): Promise<User[]> {\n    return this.usersRepository.find({ relations: ['posts'] });\n  }\n}",
      "meaning": "วิธี integrate TypeORM กับ NestJS ทำอย่างไร?",
      "example": "Install @nestjs/typeorm and typeorm. TypeOrmModule.forRoot() in AppModule configures connection. Define entities with @Entity, @Column, @PrimaryGeneratedColumn. TypeOrmModule.forFeature([Entity]) in feature modules. Inject Repository<Entity> in services. synchronize: true auto-creates tables (dev only). Use migrations in production.",
      "exampleTranslation": "Install @nestjs/typeorm และ typeorm TypeOrmModule.forRoot() ใน AppModule configure connection กำหนด entities ด้วย @Entity, @Column, @PrimaryGeneratedColumn TypeOrmModule.forFeature([Entity]) ใน feature modules Inject Repository<Entity> ใน services synchronize: true สร้าง tables อัตโนมัติ (dev only) ใช้ migrations ใน production"
    },
    {
      "vocab": "How to integrate Prisma with NestJS?",
      "pronunciation": "// Install: npm i prisma @prisma/client\n// npx prisma init\n\n// prisma/schema.prisma\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id    Int     @id @default(autoincrement())\n  email String  @unique\n  name  String?\n  posts Post[]\n}\n\nmodel Post {\n  id       Int    @id @default(autoincrement())\n  title    String\n  author   User   @relation(fields: [authorId], references: [id])\n  authorId Int\n}\n\n// Generate client: npx prisma generate\n// Migrate: npx prisma migrate dev\n\n// prisma.service.ts\nimport { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\nimport { PrismaClient } from '@prisma/client';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {\n  async onModuleInit() {\n    await this.$connect();\n  }\n\n  async onModuleDestroy() {\n    await this.$disconnect();\n  }\n}\n\n// Usage in service\n@Injectable()\nexport class UsersService {\n  constructor(private prisma: PrismaService) {}\n\n  findAll() {\n    return this.prisma.user.findMany({ include: { posts: true } });\n  }\n}",
      "meaning": "วิธี integrate Prisma กับ NestJS ทำอย่างไร?",
      "example": "Install prisma and @prisma/client. Define schema in prisma/schema.prisma. Run 'npx prisma generate' after schema changes. Create PrismaService extending PrismaClient with lifecycle hooks. Register as provider in module. Inject and use in services. Prisma provides type-safe database access with auto-completion.",
      "exampleTranslation": "Install prisma และ @prisma/client กำหนด schema ใน prisma/schema.prisma รัน 'npx prisma generate' หลังเปลี่ยน schema สร้าง PrismaService extend PrismaClient พร้อม lifecycle hooks Register เป็น provider ใน module Inject และใช้ใน services Prisma ให้ type-safe database access พร้อม auto-completion"
    },
    {
      "vocab": "How to implement JWT Authentication?",
      "pronunciation": "// Install: npm i @nestjs/jwt @nestjs/passport passport passport-jwt\n\n// auth.module.ts\n@Module({\n  imports: [\n    JwtModule.register({\n      secret: 'your-secret-key',\n      signOptions: { expiresIn: '1h' },\n    }),\n    PassportModule,\n  ],\n  providers: [AuthService, JwtStrategy],\n})\nexport class AuthModule {}\n\n// auth.service.ts\n@Injectable()\nexport class AuthService {\n  constructor(\n    private usersService: UsersService,\n    private jwtService: JwtService,\n  ) {}\n\n  async login(user: User) {\n    const payload = { sub: user.id, email: user.email };\n    return {\n      access_token: this.jwtService.sign(payload),\n    };\n  }\n}\n\n// jwt.strategy.ts\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      secretOrKey: 'your-secret-key',\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, email: payload.email };\n  }\n}\n\n// jwt-auth.guard.ts\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {}\n\n// Usage\n@UseGuards(JwtAuthGuard)\n@Get('profile')\ngetProfile(@Request() req) {\n  return req.user;\n}",
      "meaning": "วิธี implement JWT Authentication ทำอย่างไร?",
      "example": "Install @nestjs/jwt, @nestjs/passport, passport-jwt. Configure JwtModule with secret and expiration. Create JwtStrategy extending PassportStrategy to validate tokens. AuthService.login() generates token with JwtService.sign(). JwtAuthGuard extends AuthGuard('jwt'). Apply guard to protected routes. Token payload available via request.user.",
      "exampleTranslation": "Install @nestjs/jwt, @nestjs/passport, passport-jwt Configure JwtModule ด้วย secret และ expiration สร้าง JwtStrategy extend PassportStrategy เพื่อ validate tokens AuthService.login() generate token ด้วย JwtService.sign() JwtAuthGuard extends AuthGuard('jwt') Apply guard กับ protected routes Token payload available ผ่าน request.user"
    },
    {
      "vocab": "What are Custom Providers?",
      "pronunciation": "// Standard provider (shorthand)\n@Module({\n  providers: [UsersService],  // same as below\n})\n\n// Full provider syntax\n@Module({\n  providers: [\n    {\n      provide: UsersService,\n      useClass: UsersService,\n    },\n  ],\n})\n\n// Value provider\n{\n  provide: 'API_KEY',\n  useValue: 'my-api-key',\n}\n\n// Factory provider (async, with dependencies)\n{\n  provide: 'ASYNC_CONNECTION',\n  useFactory: async (configService: ConfigService) => {\n    const dbConfig = configService.get('database');\n    return createConnection(dbConfig);\n  },\n  inject: [ConfigService],\n}\n\n// Existing provider (alias)\n{\n  provide: 'AliasedService',\n  useExisting: UsersService,\n}\n\n// Class provider (substitute implementation)\n{\n  provide: UsersService,\n  useClass: process.env.NODE_ENV === 'test'\n    ? MockUsersService\n    : UsersService,\n}\n\n// Injection\nconstructor(\n  @Inject('API_KEY') private apiKey: string,\n  @Inject('ASYNC_CONNECTION') private connection: Connection,\n) {}",
      "meaning": "Custom Providers คืออะไร?",
      "example": "Custom providers give fine control over instantiation. useClass: specify class to instantiate. useValue: provide static value. useFactory: async factory function with dependencies (inject array). useExisting: alias to existing provider. Use cases: configuration values, async initialization, conditional providers (mock vs real), third-party integrations.",
      "exampleTranslation": "Custom providers ให้ control ละเอียดเหนือ instantiation useClass: ระบุ class ที่จะ instantiate useValue: ให้ static value useFactory: async factory function พร้อม dependencies (inject array) useExisting: alias ไปยัง provider ที่มีอยู่ Use cases: configuration values, async initialization, conditional providers (mock vs real), third-party integrations"
    },
    {
      "vocab": "What are Dynamic Modules?",
      "pronunciation": "// Dynamic module: configured at import time\n@Module({})\nexport class DatabaseModule {\n  static forRoot(options: DatabaseOptions): DynamicModule {\n    return {\n      module: DatabaseModule,\n      global: true,  // optional: make global\n      providers: [\n        {\n          provide: 'DATABASE_OPTIONS',\n          useValue: options,\n        },\n        DatabaseService,\n      ],\n      exports: [DatabaseService],\n    };\n  }\n\n  // Async configuration\n  static forRootAsync(options: DatabaseAsyncOptions): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: options.imports || [],\n      providers: [\n        {\n          provide: 'DATABASE_OPTIONS',\n          useFactory: options.useFactory,\n          inject: options.inject || [],\n        },\n        DatabaseService,\n      ],\n      exports: [DatabaseService],\n    };\n  }\n}\n\n// Usage\n@Module({\n  imports: [\n    DatabaseModule.forRoot({ host: 'localhost', port: 5432 }),\n    // or async\n    DatabaseModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: (config: ConfigService) => ({\n        host: config.get('DB_HOST'),\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n})\nexport class AppModule {}",
      "meaning": "Dynamic Modules คืออะไร?",
      "example": "Dynamic modules are configured at import time via static methods. forRoot() for sync configuration, forRootAsync() for async (e.g., from ConfigService). Return DynamicModule object with providers, exports, imports. Pattern used by ConfigModule, TypeOrmModule, etc. Enables reusable, configurable modules.",
      "exampleTranslation": "Dynamic modules ถูก configure ตอน import ผ่าน static methods forRoot() สำหรับ sync configuration, forRootAsync() สำหรับ async (เช่น จาก ConfigService) Return DynamicModule object พร้อม providers, exports, imports Pattern ที่ใช้โดย ConfigModule, TypeOrmModule เป็นต้น Enable reusable, configurable modules"
    },
    {
      "vocab": "How to test in NestJS?",
      "pronunciation": "// Unit test with Jest\nimport { Test, TestingModule } from '@nestjs/testing';\n\ndescribe('UsersService', () => {\n  let service: UsersService;\n  let repository: MockType<Repository<User>>;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        UsersService,\n        {\n          provide: getRepositoryToken(User),\n          useFactory: repositoryMockFactory,\n        },\n      ],\n    }).compile();\n\n    service = module.get<UsersService>(UsersService);\n    repository = module.get(getRepositoryToken(User));\n  });\n\n  it('should find all users', async () => {\n    const users = [{ id: 1, name: 'John' }];\n    repository.find.mockReturnValue(users);\n    \n    expect(await service.findAll()).toEqual(users);\n  });\n});\n\n// E2E test\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\n\ndescribe('UsersController (e2e)', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    const moduleFixture = await Test.createTestingModule({\n      imports: [AppModule],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    await app.init();\n  });\n\n  it('/users (GET)', () => {\n    return request(app.getHttpServer())\n      .get('/users')\n      .expect(200)\n      .expect([]);\n  });\n});",
      "meaning": "วิธี test ใน NestJS ทำอย่างไร?",
      "example": "Use @nestjs/testing with Jest. Test.createTestingModule() creates isolated module for testing. Mock dependencies with useFactory or useValue. Unit tests: test services/controllers in isolation. E2E tests: test full HTTP request flow with supertest. DI makes mocking easy - replace real services with mocks.",
      "exampleTranslation": "ใช้ @nestjs/testing กับ Jest Test.createTestingModule() สร้าง isolated module สำหรับ testing Mock dependencies ด้วย useFactory หรือ useValue Unit tests: test services/controllers แบบ isolated E2E tests: test full HTTP request flow ด้วย supertest DI ทำให้ mocking ง่าย - แทนที่ real services ด้วย mocks"
    },
    {
      "vocab": "How to implement file upload?",
      "pronunciation": "// Install: npm i @nestjs/platform-express multer\n// Types: npm i -D @types/multer\n\nimport { FileInterceptor, FilesInterceptor } from '@nestjs/platform-express';\nimport { diskStorage } from 'multer';\n\n@Controller('files')\nexport class FilesController {\n  // Single file\n  @Post('upload')\n  @UseInterceptors(FileInterceptor('file'))\n  uploadFile(@UploadedFile() file: Express.Multer.File) {\n    return {\n      filename: file.originalname,\n      size: file.size,\n      mimetype: file.mimetype,\n    };\n  }\n\n  // Multiple files\n  @Post('uploads')\n  @UseInterceptors(FilesInterceptor('files', 10))  // max 10\n  uploadFiles(@UploadedFiles() files: Express.Multer.File[]) {\n    return files.map(f => f.originalname);\n  }\n\n  // With storage configuration\n  @Post('upload-disk')\n  @UseInterceptors(FileInterceptor('file', {\n    storage: diskStorage({\n      destination: './uploads',\n      filename: (req, file, cb) => {\n        const uniqueName = `${Date.now()}-${file.originalname}`;\n        cb(null, uniqueName);\n      },\n    }),\n    fileFilter: (req, file, cb) => {\n      if (!file.mimetype.match(/image\\/(jpg|jpeg|png|gif)$/)) {\n        cb(new BadRequestException('Only images allowed'), false);\n      }\n      cb(null, true);\n    },\n    limits: { fileSize: 5 * 1024 * 1024 },  // 5MB\n  }))\n  uploadToDisk(@UploadedFile() file: Express.Multer.File) {}\n}",
      "meaning": "วิธี implement file upload ทำอย่างไร?",
      "example": "Use FileInterceptor from @nestjs/platform-express (wraps multer). @UploadedFile() extracts file, @UploadedFiles() for multiple. Configure storage (memory or disk), fileFilter for validation, limits for size. FilesInterceptor for multiple files with max count. FileFieldsInterceptor for different field names.",
      "exampleTranslation": "ใช้ FileInterceptor จาก @nestjs/platform-express (wraps multer) @UploadedFile() extract file, @UploadedFiles() สำหรับหลายไฟล์ Configure storage (memory หรือ disk), fileFilter สำหรับ validation, limits สำหรับ size FilesInterceptor สำหรับหลายไฟล์พร้อม max count FileFieldsInterceptor สำหรับ field names ต่างกัน"
    },
    {
      "vocab": "How to implement caching?",
      "pronunciation": "// Install: npm i @nestjs/cache-manager cache-manager\n// For Redis: npm i cache-manager-redis-store\n\nimport { CacheModule, CacheInterceptor, CacheTTL, CacheKey } from '@nestjs/cache-manager';\n\n// app.module.ts\n@Module({\n  imports: [\n    CacheModule.register({\n      ttl: 60,  // seconds\n      max: 100, // max items\n    }),\n    // Or with Redis\n    CacheModule.register({\n      store: redisStore,\n      host: 'localhost',\n      port: 6379,\n    }),\n  ],\n})\nexport class AppModule {}\n\n// Auto-cache responses\n@Controller('users')\n@UseInterceptors(CacheInterceptor)\nexport class UsersController {\n  @Get()\n  @CacheTTL(30)  // override TTL\n  @CacheKey('all-users')  // custom key\n  findAll() {\n    return this.usersService.findAll();\n  }\n}\n\n// Manual cache control\n@Injectable()\nexport class UsersService {\n  constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}\n\n  async findOne(id: string): Promise<User> {\n    const cached = await this.cacheManager.get(`user:${id}`);\n    if (cached) return cached;\n\n    const user = await this.usersRepo.findOne(id);\n    await this.cacheManager.set(`user:${id}`, user, 300);\n    return user;\n  }\n\n  async invalidate(id: string) {\n    await this.cacheManager.del(`user:${id}`);\n  }\n}",
      "meaning": "วิธี implement caching ทำอย่างไร?",
      "example": "Use @nestjs/cache-manager. CacheModule.register() with TTL and max items. CacheInterceptor auto-caches GET responses. @CacheTTL() and @CacheKey() customize behavior. Inject CACHE_MANAGER for manual control: get, set, del. Use Redis for distributed caching. Invalidate cache on data changes.",
      "exampleTranslation": "ใช้ @nestjs/cache-manager CacheModule.register() กับ TTL และ max items CacheInterceptor auto-cache GET responses @CacheTTL() และ @CacheKey() customize behavior Inject CACHE_MANAGER สำหรับ manual control: get, set, del ใช้ Redis สำหรับ distributed caching Invalidate cache เมื่อ data เปลี่ยน"
    },
    {
      "vocab": "How to implement WebSockets?",
      "pronunciation": "// Install: npm i @nestjs/websockets @nestjs/platform-socket.io\n\nimport { WebSocketGateway, WebSocketServer, SubscribeMessage, MessageBody, ConnectedSocket } from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\n\n@WebSocketGateway({\n  cors: { origin: '*' },\n  namespace: 'chat',\n})\nexport class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {\n  @WebSocketServer()\n  server: Server;\n\n  handleConnection(client: Socket) {\n    console.log(`Client connected: ${client.id}`);\n  }\n\n  handleDisconnect(client: Socket) {\n    console.log(`Client disconnected: ${client.id}`);\n  }\n\n  @SubscribeMessage('message')\n  handleMessage(\n    @MessageBody() data: { room: string; message: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    // Broadcast to room\n    this.server.to(data.room).emit('message', {\n      sender: client.id,\n      message: data.message,\n    });\n    return { event: 'message', data: 'Message sent' };\n  }\n\n  @SubscribeMessage('joinRoom')\n  handleJoinRoom(\n    @MessageBody() room: string,\n    @ConnectedSocket() client: Socket,\n  ) {\n    client.join(room);\n    return { event: 'joinedRoom', data: room };\n  }\n}\n\n// Register in module\n@Module({\n  providers: [ChatGateway],\n})",
      "meaning": "วิธี implement WebSockets ทำอย่างไร?",
      "example": "Use @nestjs/websockets with socket.io. @WebSocketGateway() creates gateway with options (cors, namespace). @WebSocketServer() injects Server instance. @SubscribeMessage('event') handles client messages. Lifecycle hooks: OnGatewayConnection, OnGatewayDisconnect. Use rooms for group messaging. Guards and Pipes work with gateways too.",
      "exampleTranslation": "ใช้ @nestjs/websockets กับ socket.io @WebSocketGateway() สร้าง gateway พร้อม options (cors, namespace) @WebSocketServer() inject Server instance @SubscribeMessage('event') handle client messages Lifecycle hooks: OnGatewayConnection, OnGatewayDisconnect ใช้ rooms สำหรับ group messaging Guards และ Pipes ใช้กับ gateways ได้เช่นกัน"
    },
    {
      "vocab": "How to implement GraphQL?",
      "pronunciation": "// Install: npm i @nestjs/graphql @nestjs/apollo @apollo/server graphql\n\n// app.module.ts\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      autoSchemaFile: 'schema.gql',  // code-first\n      playground: true,\n    }),\n  ],\n})\nexport class AppModule {}\n\n// user.model.ts (ObjectType)\nimport { ObjectType, Field, ID } from '@nestjs/graphql';\n\n@ObjectType()\nexport class User {\n  @Field(() => ID)\n  id: string;\n\n  @Field()\n  name: string;\n\n  @Field({ nullable: true })\n  email?: string;\n}\n\n// users.resolver.ts\nimport { Resolver, Query, Mutation, Args } from '@nestjs/graphql';\n\n@Resolver(() => User)\nexport class UsersResolver {\n  constructor(private usersService: UsersService) {}\n\n  @Query(() => [User])\n  users() {\n    return this.usersService.findAll();\n  }\n\n  @Query(() => User)\n  user(@Args('id') id: string) {\n    return this.usersService.findOne(id);\n  }\n\n  @Mutation(() => User)\n  createUser(@Args('input') input: CreateUserInput) {\n    return this.usersService.create(input);\n  }\n}",
      "meaning": "วิธี implement GraphQL ทำอย่างไร?",
      "example": "Use @nestjs/graphql with Apollo. Code-first approach: define types with @ObjectType, @Field decorators. Schema auto-generated. Resolvers use @Resolver, @Query, @Mutation, @Args. Schema-first: write .graphql files, generate types. GraphQL Playground for testing. Guards, Pipes, Interceptors work with GraphQL.",
      "exampleTranslation": "ใช้ @nestjs/graphql กับ Apollo Code-first approach: define types ด้วย @ObjectType, @Field decorators Schema auto-generated Resolvers ใช้ @Resolver, @Query, @Mutation, @Args Schema-first: เขียน .graphql files, generate types GraphQL Playground สำหรับ testing Guards, Pipes, Interceptors ใช้กับ GraphQL ได้"
    },
    {
      "vocab": "How to generate Swagger/OpenAPI documentation?",
      "pronunciation": "// Install: npm i @nestjs/swagger\n\n// main.ts\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  const config = new DocumentBuilder()\n    .setTitle('My API')\n    .setDescription('API description')\n    .setVersion('1.0')\n    .addBearerAuth()\n    .addTag('users')\n    .build();\n  \n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api', app, document);  // /api for docs\n  \n  await app.listen(3000);\n}\n\n// Decorate DTOs\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class CreateUserDto {\n  @ApiProperty({ example: 'John Doe', description: 'User name' })\n  name: string;\n\n  @ApiPropertyOptional()\n  bio?: string;\n}\n\n// Decorate controllers\nimport { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';\n\n@ApiTags('users')\n@Controller('users')\nexport class UsersController {\n  @Post()\n  @ApiOperation({ summary: 'Create user' })\n  @ApiResponse({ status: 201, description: 'User created', type: User })\n  @ApiResponse({ status: 400, description: 'Invalid input' })\n  @ApiBearerAuth()\n  create(@Body() dto: CreateUserDto) {}\n}",
      "meaning": "วิธี generate Swagger/OpenAPI documentation ทำอย่างไร?",
      "example": "Use @nestjs/swagger. Configure with DocumentBuilder (title, version, auth). SwaggerModule.setup() creates /api docs endpoint. Decorate DTOs with @ApiProperty for request/response schemas. Decorate controllers with @ApiTags, @ApiOperation, @ApiResponse. Add @ApiBearerAuth for auth. Auto-generates interactive API documentation.",
      "exampleTranslation": "ใช้ @nestjs/swagger Configure ด้วย DocumentBuilder (title, version, auth) SwaggerModule.setup() สร้าง /api docs endpoint Decorate DTOs ด้วย @ApiProperty สำหรับ request/response schemas Decorate controllers ด้วย @ApiTags, @ApiOperation, @ApiResponse เพิ่ม @ApiBearerAuth สำหรับ auth Auto-generate interactive API documentation"
    },
    {
      "vocab": "What are Lifecycle Hooks?",
      "pronunciation": "import { OnModuleInit, OnModuleDestroy, OnApplicationBootstrap, OnApplicationShutdown, BeforeApplicationShutdown } from '@nestjs/common';\n\n@Injectable()\nexport class AppService implements\n  OnModuleInit,\n  OnModuleDestroy,\n  OnApplicationBootstrap,\n  OnApplicationShutdown,\n  BeforeApplicationShutdown\n{\n  // Called once module's dependencies are resolved\n  async onModuleInit() {\n    console.log('Module initialized');\n    await this.connectToDatabase();\n  }\n\n  // Called after all modules initialized\n  onApplicationBootstrap() {\n    console.log('Application bootstrapped');\n  }\n\n  // Called before app starts shutting down\n  async beforeApplicationShutdown(signal?: string) {\n    console.log(`Shutting down due to ${signal}`);\n  }\n\n  // Called when app is shutting down\n  async onApplicationShutdown(signal?: string) {\n    console.log('Closing connections...');\n    await this.closeConnections();\n  }\n\n  // Called when module is being destroyed\n  async onModuleDestroy() {\n    console.log('Module destroyed');\n  }\n}\n\n// Enable shutdown hooks in main.ts\napp.enableShutdownHooks();\n\n// Order:\n// 1. onModuleInit (each module)\n// 2. onApplicationBootstrap (all modules ready)\n// 3. beforeApplicationShutdown\n// 4. onModuleDestroy\n// 5. onApplicationShutdown",
      "meaning": "Lifecycle Hooks คืออะไร?",
      "example": "Lifecycle hooks let you run code at specific points. OnModuleInit: after dependencies resolved (connect to DB). OnApplicationBootstrap: after all modules ready. OnModuleDestroy: during shutdown. OnApplicationShutdown: final cleanup. Enable with app.enableShutdownHooks(). Use for: database connections, cleanup, graceful shutdown.",
      "exampleTranslation": "Lifecycle hooks ให้รัน code ที่ specific points OnModuleInit: หลัง dependencies resolved (connect to DB) OnApplicationBootstrap: หลัง modules ทั้งหมดพร้อม OnModuleDestroy: ระหว่าง shutdown OnApplicationShutdown: final cleanup Enable ด้วย app.enableShutdownHooks() ใช้สำหรับ: database connections, cleanup, graceful shutdown"
    },
    {
      "vocab": "How to implement rate limiting?",
      "pronunciation": "// Install: npm i @nestjs/throttler\n\nimport { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';\n\n// app.module.ts\n@Module({\n  imports: [\n    ThrottlerModule.forRoot([{\n      ttl: 60000,   // time window in ms\n      limit: 10,    // max requests per ttl\n    }]),\n  ],\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: ThrottlerGuard,\n    },\n  ],\n})\nexport class AppModule {}\n\n// Override per route\n@Controller('auth')\nexport class AuthController {\n  @Post('login')\n  @Throttle({ default: { limit: 3, ttl: 60000 } })  // stricter\n  login() {}\n\n  @Get('status')\n  @SkipThrottle()  // no rate limit\n  status() {}\n}\n\n// Skip for controller\n@SkipThrottle()\n@Controller('health')\nexport class HealthController {}\n\n// Custom throttler storage (Redis for distributed)\nThrottlerModule.forRoot({\n  throttlers: [{ ttl: 60000, limit: 10 }],\n  storage: new ThrottlerStorageRedisService(redisClient),\n});\n\n// Multiple rate limits\nThrottlerModule.forRoot([\n  { name: 'short', ttl: 1000, limit: 3 },    // 3 per second\n  { name: 'medium', ttl: 10000, limit: 20 }, // 20 per 10 sec\n  { name: 'long', ttl: 60000, limit: 100 },  // 100 per minute\n]);",
      "meaning": "วิธี implement rate limiting ทำอย่างไร?",
      "example": "Use @nestjs/throttler. Configure with ttl (time window) and limit (max requests). Apply ThrottlerGuard globally or per-route. @Throttle() overrides defaults, @SkipThrottle() bypasses. Multiple limits possible (short, medium, long). Use Redis storage for distributed systems. Returns 429 Too Many Requests when exceeded.",
      "exampleTranslation": "ใช้ @nestjs/throttler Configure ด้วย ttl (time window) และ limit (max requests) Apply ThrottlerGuard globally หรือ per-route @Throttle() override defaults, @SkipThrottle() bypasses Multiple limits ได้ (short, medium, long) ใช้ Redis storage สำหรับ distributed systems Return 429 Too Many Requests เมื่อเกิน"
    },
    {
      "vocab": "How to implement queues and background jobs?",
      "pronunciation": "// Install: npm i @nestjs/bull bull\n// Redis required for Bull\n\nimport { BullModule, Process, Processor, InjectQueue } from '@nestjs/bull';\nimport { Queue, Job } from 'bull';\n\n// app.module.ts\n@Module({\n  imports: [\n    BullModule.forRoot({\n      redis: { host: 'localhost', port: 6379 },\n    }),\n    BullModule.registerQueue({ name: 'email' }),\n  ],\n})\nexport class AppModule {}\n\n// Producer: add jobs to queue\n@Injectable()\nexport class EmailService {\n  constructor(@InjectQueue('email') private emailQueue: Queue) {}\n\n  async sendWelcomeEmail(userId: string) {\n    await this.emailQueue.add('welcome', { userId }, {\n      delay: 5000,        // delay 5s\n      attempts: 3,        // retry 3 times\n      backoff: 5000,      // wait between retries\n      removeOnComplete: true,\n    });\n  }\n}\n\n// Consumer: process jobs\n@Processor('email')\nexport class EmailProcessor {\n  @Process('welcome')\n  async handleWelcome(job: Job<{ userId: string }>) {\n    console.log(`Sending welcome email to ${job.data.userId}`);\n    // send email...\n    return { sent: true };\n  }\n\n  @OnQueueActive()\n  onActive(job: Job) {\n    console.log(`Processing job ${job.id}`);\n  }\n\n  @OnQueueCompleted()\n  onComplete(job: Job, result: any) {\n    console.log(`Job ${job.id} completed`);\n  }\n\n  @OnQueueFailed()\n  onFailed(job: Job, error: Error) {\n    console.error(`Job ${job.id} failed: ${error.message}`);\n  }\n}",
      "meaning": "วิธี implement queues และ background jobs ทำอย่างไร?",
      "example": "Use @nestjs/bull with Redis. Register queues in BullModule. Producer: @InjectQueue() then queue.add() to create jobs. Consumer: @Processor() class with @Process() methods. Options: delay, attempts, backoff, priority. Event handlers: @OnQueueActive, @OnQueueCompleted, @OnQueueFailed. Great for emails, notifications, heavy processing.",
      "exampleTranslation": "ใช้ @nestjs/bull กับ Redis Register queues ใน BullModule Producer: @InjectQueue() แล้ว queue.add() เพื่อสร้าง jobs Consumer: @Processor() class กับ @Process() methods Options: delay, attempts, backoff, priority Event handlers: @OnQueueActive, @OnQueueCompleted, @OnQueueFailed ดีสำหรับ emails, notifications, heavy processing"
    },
    {
      "vocab": "How to implement events and event-driven architecture?",
      "pronunciation": "// Install: npm i @nestjs/event-emitter\n\nimport { EventEmitterModule, EventEmitter2, OnEvent } from '@nestjs/event-emitter';\n\n// app.module.ts\n@Module({\n  imports: [\n    EventEmitterModule.forRoot({\n      wildcard: true,           // user.* patterns\n      delimiter: '.',           // event.name.pattern\n      maxListeners: 10,\n      verboseMemoryLeak: true,\n    }),\n  ],\n})\nexport class AppModule {}\n\n// Define event\nexport class UserCreatedEvent {\n  constructor(\n    public readonly userId: string,\n    public readonly email: string,\n  ) {}\n}\n\n// Emit event\n@Injectable()\nexport class UsersService {\n  constructor(private eventEmitter: EventEmitter2) {}\n\n  async create(dto: CreateUserDto) {\n    const user = await this.usersRepo.save(dto);\n    \n    this.eventEmitter.emit(\n      'user.created',\n      new UserCreatedEvent(user.id, user.email),\n    );\n    \n    return user;\n  }\n}\n\n// Listen to events\n@Injectable()\nexport class NotificationsListener {\n  @OnEvent('user.created')\n  handleUserCreated(event: UserCreatedEvent) {\n    console.log(`Send welcome email to ${event.email}`);\n  }\n\n  @OnEvent('user.*')  // wildcard\n  handleAllUserEvents(event: any) {\n    console.log('User event:', event);\n  }\n\n  @OnEvent('user.created', { async: true })  // async listener\n  async handleAsync(event: UserCreatedEvent) {\n    await this.sendEmail(event.email);\n  }\n}",
      "meaning": "วิธี implement events และ event-driven architecture ทำอย่างไร?",
      "example": "Use @nestjs/event-emitter. EventEmitter2.emit() publishes events. @OnEvent('event.name') decorates listener methods. Supports wildcards (user.*), async listeners, multiple listeners per event. Decouples services - publishers don't know about subscribers. Great for: notifications, audit logs, side effects, CQRS.",
      "exampleTranslation": "ใช้ @nestjs/event-emitter EventEmitter2.emit() publish events @OnEvent('event.name') decorate listener methods รองรับ wildcards (user.*), async listeners, multiple listeners ต่อ event Decouple services - publishers ไม่รู้จัก subscribers ดีสำหรับ: notifications, audit logs, side effects, CQRS"
    },
    {
      "vocab": "How to handle circular dependencies?",
      "pronunciation": "// Problem: A depends on B, B depends on A\n// UsersService needs PostsService\n// PostsService needs UsersService\n\n// Solution 1: forwardRef()\nimport { forwardRef, Inject } from '@nestjs/common';\n\n// users.module.ts\n@Module({\n  imports: [forwardRef(() => PostsModule)],\n  providers: [UsersService],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n\n// posts.module.ts\n@Module({\n  imports: [forwardRef(() => UsersModule)],\n  providers: [PostsService],\n  exports: [PostsService],\n})\nexport class PostsModule {}\n\n// In services\n@Injectable()\nexport class UsersService {\n  constructor(\n    @Inject(forwardRef(() => PostsService))\n    private postsService: PostsService,\n  ) {}\n}\n\n// Solution 2: Refactor to avoid circular dependency\n// Create shared service or use events\n\n// Solution 3: ModuleRef for lazy loading\n@Injectable()\nexport class UsersService {\n  private postsService: PostsService;\n  \n  constructor(private moduleRef: ModuleRef) {}\n  \n  onModuleInit() {\n    this.postsService = this.moduleRef.get(PostsService);\n  }\n}\n\n// Best practice: Avoid circular dependencies\n// - Extract shared logic to separate module\n// - Use events for cross-module communication",
      "meaning": "วิธีจัดการ circular dependencies ทำอย่างไร?",
      "example": "Circular dependency: A needs B, B needs A. Solution 1: forwardRef() in both module imports and service injections - tells NestJS to resolve later. Solution 2: Refactor to extract shared service. Solution 3: ModuleRef for lazy resolution. Best practice: avoid circulars - use events or shared modules instead.",
      "exampleTranslation": "Circular dependency: A ต้องการ B, B ต้องการ A Solution 1: forwardRef() ทั้งใน module imports และ service injections - บอก NestJS ให้ resolve ทีหลัง Solution 2: Refactor เพื่อ extract shared service Solution 3: ModuleRef สำหรับ lazy resolution Best practice: หลีกเลี่ยง circulars - ใช้ events หรือ shared modules แทน"
    },
    {
      "vocab": "How to implement health checks?",
      "pronunciation": "// Install: npm i @nestjs/terminus\n\nimport { TerminusModule, HealthCheckService, HttpHealthIndicator, TypeOrmHealthIndicator, MemoryHealthIndicator, DiskHealthIndicator } from '@nestjs/terminus';\n\n// app.module.ts\n@Module({\n  imports: [TerminusModule],\n  controllers: [HealthController],\n})\nexport class AppModule {}\n\n// health.controller.ts\n@Controller('health')\nexport class HealthController {\n  constructor(\n    private health: HealthCheckService,\n    private http: HttpHealthIndicator,\n    private db: TypeOrmHealthIndicator,\n    private memory: MemoryHealthIndicator,\n    private disk: DiskHealthIndicator,\n  ) {}\n\n  @Get()\n  @HealthCheck()\n  check() {\n    return this.health.check([\n      // Check if external service is up\n      () => this.http.pingCheck('api', 'https://api.example.com'),\n      \n      // Database connection\n      () => this.db.pingCheck('database'),\n      \n      // Memory usage (heap < 150MB)\n      () => this.memory.checkHeap('memory_heap', 150 * 1024 * 1024),\n      \n      // Disk usage (< 90%)\n      () => this.disk.checkStorage('disk', {\n        path: '/',\n        thresholdPercent: 0.9,\n      }),\n    ]);\n  }\n\n  @Get('liveness')\n  liveness() {\n    return { status: 'ok' };  // simple check\n  }\n\n  @Get('readiness')\n  @HealthCheck()\n  readiness() {\n    return this.health.check([\n      () => this.db.pingCheck('database'),\n    ]);\n  }\n}",
      "meaning": "วิธี implement health checks ทำอย่างไร?",
      "example": "Use @nestjs/terminus for health checks. HealthCheckService.check() runs multiple indicators. Built-in: HttpHealthIndicator, TypeOrmHealthIndicator, MemoryHealthIndicator, DiskHealthIndicator. Create /health endpoint for orchestrators (Kubernetes). Separate liveness (app running) and readiness (dependencies ready) checks.",
      "exampleTranslation": "ใช้ @nestjs/terminus สำหรับ health checks HealthCheckService.check() รัน indicators หลายตัว Built-in: HttpHealthIndicator, TypeOrmHealthIndicator, MemoryHealthIndicator, DiskHealthIndicator สร้าง /health endpoint สำหรับ orchestrators (Kubernetes) แยก liveness (app running) และ readiness (dependencies ready) checks"
    },
    {
      "vocab": "What is serialization and how to use ClassSerializerInterceptor?",
      "pronunciation": "// Serialization: transform objects before sending response\nimport { Exclude, Expose, Transform, Type } from 'class-transformer';\n\nexport class UserEntity {\n  id: number;\n  name: string;\n  email: string;\n\n  @Exclude()  // never include in response\n  password: string;\n\n  @Expose({ name: 'fullName' })  // rename in response\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  @Transform(({ value }) => value.toISOString())  // transform value\n  createdAt: Date;\n\n  @Type(() => PostEntity)  // nested serialization\n  posts: PostEntity[];\n\n  @Expose({ groups: ['admin'] })  // conditional exposure\n  role: string;\n\n  constructor(partial: Partial<UserEntity>) {\n    Object.assign(this, partial);\n  }\n}\n\n// Enable globally\n// main.ts\napp.useGlobalInterceptors(new ClassSerializerInterceptor(app.get(Reflector)));\n\n// Controller\n@Controller('users')\nexport class UsersController {\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    const user = this.usersService.findOne(id);\n    return new UserEntity(user);  // must instantiate class\n  }\n\n  @Get('admin/:id')\n  @SerializeOptions({ groups: ['admin'] })  // include admin fields\n  findOneAdmin(@Param('id') id: string) {\n    return new UserEntity(this.usersService.findOne(id));\n  }\n}",
      "meaning": "Serialization และการใช้ ClassSerializerInterceptor คืออะไร?",
      "example": "Serialization transforms objects before sending response. Use class-transformer decorators: @Exclude (hide), @Expose (show/rename), @Transform (modify value), @Type (nested objects). ClassSerializerInterceptor applies transformations. Must return class instance, not plain object. Use groups for conditional fields (admin-only).",
      "exampleTranslation": "Serialization transform objects ก่อนส่ง response ใช้ class-transformer decorators: @Exclude (ซ่อน), @Expose (แสดง/rename), @Transform (modify value), @Type (nested objects) ClassSerializerInterceptor apply transformations ต้อง return class instance ไม่ใช่ plain object ใช้ groups สำหรับ conditional fields (admin-only)"
    },
    {
      "vocab": "How to implement API versioning?",
      "pronunciation": "// main.ts - Enable versioning\nimport { VersioningType } from '@nestjs/common';\n\nconst app = await NestFactory.create(AppModule);\n\n// URI versioning: /v1/users, /v2/users\napp.enableVersioning({\n  type: VersioningType.URI,\n  defaultVersion: '1',\n});\n\n// Header versioning: X-API-Version: 1\napp.enableVersioning({\n  type: VersioningType.HEADER,\n  header: 'X-API-Version',\n});\n\n// Media type versioning: Accept: application/json;v=1\napp.enableVersioning({\n  type: VersioningType.MEDIA_TYPE,\n  key: 'v=',\n});\n\n// Controller versioning\n@Controller({ path: 'users', version: '1' })\nexport class UsersControllerV1 {\n  @Get()\n  findAll() { return 'v1 users'; }\n}\n\n@Controller({ path: 'users', version: '2' })\nexport class UsersControllerV2 {\n  @Get()\n  findAll() { return 'v2 users with extra data'; }\n}\n\n// Route-level versioning\n@Controller('users')\nexport class UsersController {\n  @Get()\n  @Version('1')\n  findAllV1() { return 'v1'; }\n\n  @Get()\n  @Version('2')\n  findAllV2() { return 'v2'; }\n\n  @Get()\n  @Version(VERSION_NEUTRAL)  // works for all versions\n  findAllNeutral() {}\n}",
      "meaning": "วิธี implement API versioning ทำอย่างไร?",
      "example": "Enable with app.enableVersioning(). Types: URI (/v1/), HEADER (X-API-Version), MEDIA_TYPE (Accept header). Set version on controller or route with @Version(). VERSION_NEUTRAL works for all versions. Separate controllers per version for major changes. Mix versions within same controller for minor differences.",
      "exampleTranslation": "Enable ด้วย app.enableVersioning() Types: URI (/v1/), HEADER (X-API-Version), MEDIA_TYPE (Accept header) Set version บน controller หรือ route ด้วย @Version() VERSION_NEUTRAL ใช้กับทุก versions แยก controllers ต่อ version สำหรับ major changes Mix versions ใน controller เดียวสำหรับ minor differences"
    },
    {
      "vocab": "What are best practices for NestJS applications?",
      "pronunciation": "// Project structure\nsrc/\n├── common/          // shared utilities, guards, pipes\n├── config/          // configuration files\n├── modules/\n│   ├── users/\n│   │   ├── dto/\n│   │   ├── entities/\n│   │   ├── users.controller.ts\n│   │   ├── users.service.ts\n│   │   ├── users.module.ts\n│   │   └── users.repository.ts\n│   └── posts/\n├── app.module.ts\n└── main.ts\n\n// Best practices:\n\n// 1. Keep controllers thin\n@Get(':id')\nfindOne(@Param('id') id: string) {\n  return this.usersService.findOne(id);  // delegate to service\n}\n\n// 2. Use DTOs for input/output\n@Post()\ncreate(@Body() dto: CreateUserDto) {}  // validated input\n\n// 3. Global validation pipe\napp.useGlobalPipes(new ValidationPipe({ whitelist: true }));\n\n// 4. Consistent error handling\napp.useGlobalFilters(new AllExceptionsFilter());\n\n// 5. Use environment config\nConfigModule.forRoot({ isGlobal: true });\n\n// 6. Repository pattern for data access\n// 7. Write tests (unit + e2e)\n// 8. Use interceptors for response format\n// 9. Document API with Swagger\n// 10. Enable CORS, Helmet, rate limiting",
      "meaning": "Best practices สำหรับ NestJS applications มีอะไรบ้าง?",
      "example": "Structure: feature modules in modules/ folder, shared code in common/. Keep controllers thin - delegate to services. Use DTOs with validation. Global pipes, filters, interceptors for consistency. Environment-based config. Repository pattern for data access. Write tests. Document with Swagger. Security: CORS, Helmet, rate limiting.",
      "exampleTranslation": "Structure: feature modules ใน modules/ folder, shared code ใน common/ Keep controllers บางเบา - delegate ให้ services ใช้ DTOs พร้อม validation Global pipes, filters, interceptors สำหรับ consistency Environment-based config Repository pattern สำหรับ data access เขียน tests Document ด้วย Swagger Security: CORS, Helmet, rate limiting"
    },
    {
      "vocab": "How to implement microservices in NestJS?",
      "pronunciation": "// Install: npm i @nestjs/microservices\n\n// Microservice (server)\nimport { NestFactory } from '@nestjs/core';\nimport { Transport, MicroserviceOptions } from '@nestjs/microservices';\n\nasync function bootstrap() {\n  const app = await NestFactory.createMicroservice<MicroserviceOptions>(\n    AppModule,\n    {\n      transport: Transport.TCP,\n      options: { host: 'localhost', port: 3001 },\n    },\n  );\n  await app.listen();\n}\n\n// Or Redis transport\n{\n  transport: Transport.REDIS,\n  options: { host: 'localhost', port: 6379 },\n}\n\n// Message handler\n@Controller()\nexport class AppController {\n  @MessagePattern({ cmd: 'get_user' })\n  getUser(data: { id: string }) {\n    return this.usersService.findOne(data.id);\n  }\n\n  @EventPattern('user_created')\n  handleUserCreated(data: any) {\n    console.log('User created:', data);\n  }\n}\n\n// Client (consumer)\n@Module({\n  imports: [\n    ClientsModule.register([{\n      name: 'USER_SERVICE',\n      transport: Transport.TCP,\n      options: { host: 'localhost', port: 3001 },\n    }]),\n  ],\n})\nexport class AppModule {}\n\n@Injectable()\nexport class AppService {\n  constructor(@Inject('USER_SERVICE') private client: ClientProxy) {}\n\n  getUser(id: string) {\n    return this.client.send({ cmd: 'get_user' }, { id });\n  }\n\n  notifyUserCreated(user: any) {\n    this.client.emit('user_created', user);  // fire and forget\n  }\n}",
      "meaning": "วิธี implement microservices ใน NestJS ทำอย่างไร?",
      "example": "Use @nestjs/microservices. Transports: TCP, Redis, MQTT, NATS, RabbitMQ, Kafka, gRPC. Server: @MessagePattern for request-response, @EventPattern for events. Client: ClientProxy.send() for request-response, emit() for events. Hybrid app: combine HTTP and microservice in same app. Great for distributed systems.",
      "exampleTranslation": "ใช้ @nestjs/microservices Transports: TCP, Redis, MQTT, NATS, RabbitMQ, Kafka, gRPC Server: @MessagePattern สำหรับ request-response, @EventPattern สำหรับ events Client: ClientProxy.send() สำหรับ request-response, emit() สำหรับ events Hybrid app: รวม HTTP และ microservice ใน app เดียว ดีสำหรับ distributed systems"
    },
    {
      "vocab": "What is CQRS pattern in NestJS?",
      "pronunciation": "// Install: npm i @nestjs/cqrs\n\nimport { CommandHandler, ICommandHandler, QueryHandler, IQueryHandler, EventsHandler, IEventHandler } from '@nestjs/cqrs';\n\n// Command: intent to change state\nexport class CreateUserCommand {\n  constructor(\n    public readonly name: string,\n    public readonly email: string,\n  ) {}\n}\n\n@CommandHandler(CreateUserCommand)\nexport class CreateUserHandler implements ICommandHandler<CreateUserCommand> {\n  async execute(command: CreateUserCommand) {\n    const user = await this.usersRepo.create(command);\n    // Publish event\n    this.eventBus.publish(new UserCreatedEvent(user.id));\n    return user;\n  }\n}\n\n// Query: read data\nexport class GetUserQuery {\n  constructor(public readonly id: string) {}\n}\n\n@QueryHandler(GetUserQuery)\nexport class GetUserHandler implements IQueryHandler<GetUserQuery> {\n  async execute(query: GetUserQuery) {\n    return this.usersRepo.findOne(query.id);\n  }\n}\n\n// Event: something that happened\nexport class UserCreatedEvent {\n  constructor(public readonly userId: string) {}\n}\n\n@EventsHandler(UserCreatedEvent)\nexport class UserCreatedHandler implements IEventHandler<UserCreatedEvent> {\n  handle(event: UserCreatedEvent) {\n    console.log('User created:', event.userId);\n  }\n}\n\n// Controller using CQRS\n@Controller('users')\nexport class UsersController {\n  constructor(private commandBus: CommandBus, private queryBus: QueryBus) {}\n\n  @Post()\n  create(@Body() dto: CreateUserDto) {\n    return this.commandBus.execute(new CreateUserCommand(dto.name, dto.email));\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return this.queryBus.execute(new GetUserQuery(id));\n  }\n}",
      "meaning": "CQRS pattern ใน NestJS คืออะไร?",
      "example": "CQRS separates reads (Queries) from writes (Commands). Commands: change state, handled by CommandHandler. Queries: read data, handled by QueryHandler. Events: notify about changes, handled by EventsHandler. Use CommandBus/QueryBus to dispatch. Benefits: separate read/write models, scalability, clear intent. Use for complex domains.",
      "exampleTranslation": "CQRS แยก reads (Queries) จาก writes (Commands) Commands: เปลี่ยน state จัดการโดย CommandHandler Queries: อ่าน data จัดการโดย QueryHandler Events: notify เกี่ยวกับ changes จัดการโดย EventsHandler ใช้ CommandBus/QueryBus เพื่อ dispatch ข้อดี: แยก read/write models, scalability, clear intent ใช้สำหรับ complex domains"
    }
  ]
}
