{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "PostgreSQL Concepts",
    "description": "Core PostgreSQL concepts including SQL, indexes, transactions, performance tuning, and advanced features",
    "category": "Database",
    "tags": ["postgresql", "sql", "database", "concepts"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What are the main PostgreSQL data types?",
      "pronunciation": "-- Numeric\nINTEGER, BIGINT, SMALLINT\nNUMERIC(precision, scale), DECIMAL\nREAL, DOUBLE PRECISION\nSERIAL, BIGSERIAL  -- auto-increment\n\n-- Character\nCHAR(n), VARCHAR(n), TEXT\n\n-- Date/Time\nDATE, TIME, TIMESTAMP, TIMESTAMPTZ\nINTERVAL\n\n-- Boolean\nBOOLEAN  -- true, false, null\n\n-- Binary\nBYTEA\n\n-- JSON\nJSON, JSONB\n\n-- Arrays\nINTEGER[], TEXT[], etc.\n\n-- UUID\nUUID",
      "meaning": "PostgreSQL มี data types หลักอะไรบ้าง?",
      "example": "PostgreSQL has rich data types: Numeric (INTEGER, BIGINT, NUMERIC, SERIAL), Character (VARCHAR, TEXT), Date/Time (TIMESTAMP, TIMESTAMPTZ, INTERVAL), Boolean, Binary (BYTEA), JSON/JSONB, Arrays, UUID, and more. Use appropriate types for data integrity and performance. TIMESTAMPTZ stores timezone info.",
      "exampleTranslation": "PostgreSQL มี data types ที่หลากหลาย: Numeric (INTEGER, BIGINT, NUMERIC, SERIAL), Character (VARCHAR, TEXT), Date/Time (TIMESTAMP, TIMESTAMPTZ, INTERVAL), Boolean, Binary (BYTEA), JSON/JSONB, Arrays, UUID และอื่นๆ ใช้ types ที่เหมาะสมเพื่อ data integrity และ performance TIMESTAMPTZ เก็บ timezone info"
    },
    {
      "vocab": "What is the difference between CHAR, VARCHAR, and TEXT?",
      "pronunciation": "-- CHAR(n) - fixed length, padded with spaces\nCREATE TABLE t1 (code CHAR(5));\nINSERT INTO t1 VALUES ('AB');  -- stored as 'AB   '\n\n-- VARCHAR(n) - variable length with limit\nCREATE TABLE t2 (name VARCHAR(100));\nINSERT INTO t2 VALUES ('John');  -- stored as 'John'\n\n-- TEXT - unlimited length\nCREATE TABLE t3 (content TEXT);\nINSERT INTO t3 VALUES ('Very long text...');\n\n-- Performance is the same in PostgreSQL\n-- VARCHAR without (n) is same as TEXT",
      "meaning": "CHAR, VARCHAR และ TEXT ต่างกันอย่างไร?",
      "example": "CHAR(n) is fixed-length, padded with spaces - use for fixed codes like country codes. VARCHAR(n) is variable-length with max limit. TEXT has no length limit. In PostgreSQL, performance is identical for all three - the limit is only for validation. VARCHAR without length is same as TEXT.",
      "exampleTranslation": "CHAR(n) คือ fixed-length เติม spaces - ใช้สำหรับ codes ที่คงที่เช่น country codes VARCHAR(n) คือ variable-length มี max limit TEXT ไม่มี length limit ใน PostgreSQL performance เท่ากันทั้งสาม - limit มีไว้สำหรับ validation เท่านั้น VARCHAR ไม่มี length เหมือนกับ TEXT"
    },
    {
      "vocab": "What is SERIAL vs IDENTITY?",
      "pronunciation": "-- SERIAL (legacy approach)\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  name TEXT\n);\n-- Creates sequence: users_id_seq\n\n-- IDENTITY (SQL standard, PostgreSQL 10+)\nCREATE TABLE users (\n  id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\n  name TEXT\n);\n\n-- GENERATED BY DEFAULT allows manual insert\nCREATE TABLE users (\n  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n  name TEXT\n);\n\nINSERT INTO users (name) VALUES ('John');  -- id auto-generated\nINSERT INTO users (id, name) VALUES (100, 'Jane');  -- manual (BY DEFAULT only)",
      "meaning": "SERIAL และ IDENTITY ต่างกันอย่างไร?",
      "example": "SERIAL is PostgreSQL-specific shorthand that creates a sequence. IDENTITY is SQL standard (PostgreSQL 10+). GENERATED ALWAYS prevents manual ID insertion. GENERATED BY DEFAULT allows manual override. Prefer IDENTITY for new projects as it's SQL standard and more explicit about behavior.",
      "exampleTranslation": "SERIAL เป็น PostgreSQL-specific shorthand ที่สร้าง sequence IDENTITY เป็น SQL standard (PostgreSQL 10+) GENERATED ALWAYS ป้องกัน manual ID insertion GENERATED BY DEFAULT อนุญาตให้ override ด้วยตนเอง ใช้ IDENTITY สำหรับ projects ใหม่เพราะเป็น SQL standard และชัดเจนกว่าเรื่อง behavior"
    },
    {
      "vocab": "What are the types of JOINs in PostgreSQL?",
      "pronunciation": "-- INNER JOIN - matching rows only\nSELECT * FROM orders o\nINNER JOIN customers c ON o.customer_id = c.id;\n\n-- LEFT JOIN - all left + matching right\nSELECT * FROM customers c\nLEFT JOIN orders o ON c.id = o.customer_id;\n\n-- RIGHT JOIN - all right + matching left\nSELECT * FROM orders o\nRIGHT JOIN customers c ON o.customer_id = c.id;\n\n-- FULL OUTER JOIN - all from both\nSELECT * FROM customers c\nFULL OUTER JOIN orders o ON c.id = o.customer_id;\n\n-- CROSS JOIN - cartesian product\nSELECT * FROM colors CROSS JOIN sizes;\n\n-- LATERAL JOIN - subquery can reference outer\nSELECT * FROM customers c,\nLATERAL (SELECT * FROM orders WHERE customer_id = c.id LIMIT 3) o;",
      "meaning": "PostgreSQL มี JOINs ประเภทอะไรบ้าง?",
      "example": "INNER JOIN returns only matching rows. LEFT JOIN returns all left table rows plus matches. RIGHT JOIN returns all right rows plus matches. FULL OUTER JOIN returns all rows from both. CROSS JOIN creates cartesian product. LATERAL JOIN allows subquery to reference outer query columns - powerful for top-N per group.",
      "exampleTranslation": "INNER JOIN return เฉพาะ rows ที่ match LEFT JOIN return ทุก rows จาก left table บวก matches RIGHT JOIN return ทุก rows จาก right บวก matches FULL OUTER JOIN return ทุก rows จากทั้งสอง CROSS JOIN สร้าง cartesian product LATERAL JOIN อนุญาตให้ subquery reference outer query columns - มีพลังสำหรับ top-N per group"
    },
    {
      "vocab": "What is a subquery vs CTE?",
      "pronunciation": "-- Subquery (inline)\nSELECT * FROM orders\nWHERE customer_id IN (\n  SELECT id FROM customers WHERE country = 'US'\n);\n\n-- CTE (Common Table Expression)\nWITH us_customers AS (\n  SELECT id FROM customers WHERE country = 'US'\n)\nSELECT * FROM orders\nWHERE customer_id IN (SELECT id FROM us_customers);\n\n-- Multiple CTEs\nWITH \n  active_users AS (SELECT * FROM users WHERE active),\n  recent_orders AS (SELECT * FROM orders WHERE date > NOW() - INTERVAL '30 days')\nSELECT * FROM active_users u\nJOIN recent_orders o ON u.id = o.user_id;\n\n-- Recursive CTE\nWITH RECURSIVE subordinates AS (\n  SELECT id, name, manager_id FROM employees WHERE id = 1\n  UNION ALL\n  SELECT e.id, e.name, e.manager_id FROM employees e\n  JOIN subordinates s ON e.manager_id = s.id\n)\nSELECT * FROM subordinates;",
      "meaning": "Subquery และ CTE ต่างกันอย่างไร?",
      "example": "Subqueries are inline nested queries. CTEs (WITH clause) are named temporary result sets that improve readability and can be referenced multiple times. CTEs can be recursive for hierarchical data (org charts, trees). Performance is usually similar, but CTEs are easier to debug and maintain.",
      "exampleTranslation": "Subqueries คือ inline nested queries CTEs (WITH clause) คือ named temporary result sets ที่ปรับปรุง readability และ reference หลายครั้งได้ CTEs เป็น recursive สำหรับ hierarchical data ได้ (org charts, trees) Performance มักจะใกล้เคียงกัน แต่ CTEs debug และ maintain ง่ายกว่า"
    },
    {
      "vocab": "What are window functions?",
      "pronunciation": "-- ROW_NUMBER - unique row number\nSELECT name, department,\n  ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank\nFROM employees;\n\n-- RANK vs DENSE_RANK\nSELECT name, salary,\n  RANK() OVER (ORDER BY salary DESC),        -- 1,2,2,4 (gaps)\n  DENSE_RANK() OVER (ORDER BY salary DESC)   -- 1,2,2,3 (no gaps)\nFROM employees;\n\n-- Running total\nSELECT date, amount,\n  SUM(amount) OVER (ORDER BY date) as running_total\nFROM transactions;\n\n-- Moving average\nSELECT date, amount,\n  AVG(amount) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW)\nFROM transactions;\n\n-- LAG/LEAD - access previous/next rows\nSELECT date, amount,\n  LAG(amount, 1) OVER (ORDER BY date) as prev_amount,\n  amount - LAG(amount, 1) OVER (ORDER BY date) as diff\nFROM transactions;",
      "meaning": "Window functions คืออะไร?",
      "example": "Window functions perform calculations across related rows without collapsing them. OVER() defines the window. PARTITION BY groups rows, ORDER BY sorts within partition. Common functions: ROW_NUMBER, RANK, DENSE_RANK, SUM, AVG, LAG, LEAD, FIRST_VALUE, LAST_VALUE. Frame clause (ROWS BETWEEN) controls which rows to include.",
      "exampleTranslation": "Window functions ทำ calculations ข้าม rows ที่เกี่ยวข้องโดยไม่ collapse มัน OVER() กำหนด window PARTITION BY groups rows, ORDER BY sort ภายใน partition Functions ที่ใช้บ่อย: ROW_NUMBER, RANK, DENSE_RANK, SUM, AVG, LAG, LEAD, FIRST_VALUE, LAST_VALUE Frame clause (ROWS BETWEEN) ควบคุมว่าจะรวม rows ไหน"
    },
    {
      "vocab": "What are the types of indexes in PostgreSQL?",
      "pronunciation": "-- B-tree (default) - equality and range\nCREATE INDEX idx_name ON users (name);\nCREATE INDEX idx_date ON orders (created_at DESC);\n\n-- Hash - equality only (rarely used)\nCREATE INDEX idx_hash ON users USING HASH (email);\n\n-- GiST - geometric, full-text, range types\nCREATE INDEX idx_location ON places USING GIST (location);\n\n-- GIN - arrays, JSONB, full-text search\nCREATE INDEX idx_tags ON posts USING GIN (tags);\nCREATE INDEX idx_jsonb ON products USING GIN (metadata);\n\n-- BRIN - large tables with natural ordering\nCREATE INDEX idx_brin ON logs USING BRIN (created_at);\n\n-- Partial index\nCREATE INDEX idx_active ON users (email) WHERE active = true;\n\n-- Multi-column index\nCREATE INDEX idx_multi ON orders (customer_id, created_at DESC);\n\n-- Expression index\nCREATE INDEX idx_lower ON users (LOWER(email));",
      "meaning": "PostgreSQL มี indexes ประเภทอะไรบ้าง?",
      "example": "B-tree (default) for equality and range queries. Hash for equality only. GiST for geometric and range types. GIN for arrays, JSONB, full-text search. BRIN for large naturally-ordered tables (very small). Partial indexes cover subset of rows. Expression indexes index computed values. Choose based on query patterns.",
      "exampleTranslation": "B-tree (default) สำหรับ equality และ range queries Hash สำหรับ equality อย่างเดียว GiST สำหรับ geometric และ range types GIN สำหรับ arrays, JSONB, full-text search BRIN สำหรับ tables ใหญ่ที่เรียงตามธรรมชาติ (เล็กมาก) Partial indexes ครอบคลุม subset ของ rows Expression indexes index computed values เลือกตาม query patterns"
    },
    {
      "vocab": "What is EXPLAIN and EXPLAIN ANALYZE?",
      "pronunciation": "-- EXPLAIN - show query plan (no execution)\nEXPLAIN SELECT * FROM users WHERE email = 'test@example.com';\n\n-- EXPLAIN ANALYZE - execute and show actual times\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';\n\n-- With more details\nEXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)\nSELECT * FROM orders WHERE customer_id = 123;\n\n-- Reading output:\n-- Seq Scan: full table scan (no index)\n-- Index Scan: using index\n-- Index Only Scan: all data from index\n-- Bitmap Index Scan: build bitmap then fetch\n-- Nested Loop: join method\n-- Hash Join: build hash table for join\n-- Sort: sorting operation\n-- cost=0.00..10.00: startup..total cost\n-- rows=100: estimated rows\n-- actual time=0.1..0.5: actual timing",
      "meaning": "EXPLAIN และ EXPLAIN ANALYZE คืออะไร?",
      "example": "EXPLAIN shows the query execution plan without running the query. EXPLAIN ANALYZE actually executes and shows real timings and row counts. Use BUFFERS to see I/O stats. Look for: Seq Scan (missing index), high cost estimates, large row differences between estimated and actual. Essential for query optimization.",
      "exampleTranslation": "EXPLAIN แสดง query execution plan โดยไม่รัน query EXPLAIN ANALYZE execute จริงและแสดง timings และ row counts จริง ใช้ BUFFERS เพื่อดู I/O stats ดู: Seq Scan (ไม่มี index), cost estimates สูง, row differences ใหญ่ระหว่าง estimated กับ actual จำเป็นสำหรับ query optimization"
    },
    {
      "vocab": "What is a transaction and ACID properties?",
      "pronunciation": "-- Transaction basics\nBEGIN;\n  UPDATE accounts SET balance = balance - 100 WHERE id = 1;\n  UPDATE accounts SET balance = balance + 100 WHERE id = 2;\nCOMMIT;  -- or ROLLBACK;\n\n-- Savepoints\nBEGIN;\n  INSERT INTO orders VALUES (...);\n  SAVEPOINT my_savepoint;\n  INSERT INTO order_items VALUES (...);\n  -- Something went wrong\n  ROLLBACK TO my_savepoint;\n  -- Try different approach\n  INSERT INTO order_items VALUES (...);\nCOMMIT;\n\n-- ACID:\n-- Atomicity: all or nothing\n-- Consistency: valid state to valid state\n-- Isolation: concurrent transactions don't interfere\n-- Durability: committed data survives crashes",
      "meaning": "Transaction และ ACID properties คืออะไร?",
      "example": "Transaction groups operations that must succeed or fail together. ACID: Atomicity (all or nothing), Consistency (database remains valid), Isolation (concurrent transactions isolated), Durability (committed data persists). Use BEGIN/COMMIT/ROLLBACK. Savepoints allow partial rollback within transaction.",
      "exampleTranslation": "Transaction รวม operations ที่ต้องสำเร็จหรือล้มเหลวพร้อมกัน ACID: Atomicity (ทั้งหมดหรือไม่มี), Consistency (database ยังคง valid), Isolation (concurrent transactions แยกกัน), Durability (committed data คงอยู่) ใช้ BEGIN/COMMIT/ROLLBACK Savepoints อนุญาตให้ partial rollback ภายใน transaction"
    },
    {
      "vocab": "What are isolation levels in PostgreSQL?",
      "pronunciation": "-- Set isolation level\nBEGIN ISOLATION LEVEL READ COMMITTED;\nBEGIN ISOLATION LEVEL REPEATABLE READ;\nBEGIN ISOLATION LEVEL SERIALIZABLE;\n\n-- READ COMMITTED (default)\n-- Sees committed changes from other transactions\n-- Each statement sees latest committed data\n\n-- REPEATABLE READ\n-- Snapshot at transaction start\n-- Same query returns same results\n-- Serialization error on write conflicts\n\n-- SERIALIZABLE\n-- Strictest - transactions appear sequential\n-- May fail with serialization error\n-- Best for correctness, worst for concurrency\n\n-- Example: lost update problem\n-- T1: SELECT balance -> 100\n-- T2: SELECT balance -> 100\n-- T1: UPDATE balance = 100 + 50\n-- T2: UPDATE balance = 100 + 30  -- T1's update lost!\n-- Solution: REPEATABLE READ or SELECT FOR UPDATE",
      "meaning": "Isolation levels ใน PostgreSQL มีอะไรบ้าง?",
      "example": "READ COMMITTED (default): sees other transactions' commits between statements. REPEATABLE READ: snapshot at transaction start, prevents non-repeatable reads. SERIALIZABLE: strictest, transactions appear sequential, may throw serialization errors. Higher isolation = more correctness but less concurrency and more conflicts.",
      "exampleTranslation": "READ COMMITTED (default): เห็น commits ของ transactions อื่นระหว่าง statements REPEATABLE READ: snapshot ตอนเริ่ม transaction ป้องกัน non-repeatable reads SERIALIZABLE: เข้มงวดที่สุด transactions ดูเหมือนเป็น sequential อาจ throw serialization errors Isolation สูงกว่า = ถูกต้องกว่าแต่ concurrency น้อยกว่าและ conflicts มากกว่า"
    },
    {
      "vocab": "What is SELECT FOR UPDATE?",
      "pronunciation": "-- Lock rows for update\nBEGIN;\nSELECT * FROM accounts WHERE id = 1 FOR UPDATE;\n-- Other transactions wait here\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n\n-- Lock options\nSELECT * FROM products WHERE id = 1 FOR UPDATE;          -- exclusive lock\nSELECT * FROM products WHERE id = 1 FOR SHARE;           -- shared lock\nSELECT * FROM products WHERE id = 1 FOR UPDATE NOWAIT;   -- error if locked\nSELECT * FROM products WHERE id = 1 FOR UPDATE SKIP LOCKED; -- skip locked rows\n\n-- With JOIN - specify which table to lock\nSELECT * FROM orders o\nJOIN order_items oi ON o.id = oi.order_id\nWHERE o.id = 1\nFOR UPDATE OF orders;  -- only lock orders table\n\n-- Use case: inventory deduction\nBEGIN;\nSELECT quantity FROM products WHERE id = 1 FOR UPDATE;\n-- Check if enough quantity\nUPDATE products SET quantity = quantity - 1 WHERE id = 1;\nCOMMIT;",
      "meaning": "SELECT FOR UPDATE คืออะไร?",
      "example": "SELECT FOR UPDATE locks selected rows until transaction ends, preventing other transactions from modifying them. Prevents lost updates and race conditions. FOR SHARE allows concurrent reads. NOWAIT fails immediately if locked. SKIP LOCKED skips locked rows (good for job queues). Essential for inventory and balance operations.",
      "exampleTranslation": "SELECT FOR UPDATE lock rows ที่เลือกจนกว่า transaction จะจบ ป้องกัน transactions อื่นจากการแก้ไข ป้องกัน lost updates และ race conditions FOR SHARE อนุญาตให้อ่านพร้อมกัน NOWAIT fail ทันทีถ้า locked SKIP LOCKED ข้าม locked rows (ดีสำหรับ job queues) จำเป็นสำหรับ inventory และ balance operations"
    },
    {
      "vocab": "What are constraints in PostgreSQL?",
      "pronunciation": "-- PRIMARY KEY\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY\n);\n\n-- UNIQUE\nCREATE TABLE users (\n  email VARCHAR(255) UNIQUE\n);\n\n-- NOT NULL\nCREATE TABLE users (\n  name VARCHAR(100) NOT NULL\n);\n\n-- FOREIGN KEY\nCREATE TABLE orders (\n  customer_id INTEGER REFERENCES customers(id)\n    ON DELETE CASCADE\n    ON UPDATE CASCADE\n);\n\n-- CHECK\nCREATE TABLE products (\n  price NUMERIC CHECK (price > 0),\n  quantity INTEGER CHECK (quantity >= 0)\n);\n\n-- EXCLUDE (no overlapping ranges)\nCREATE TABLE reservations (\n  room_id INTEGER,\n  during TSRANGE,\n  EXCLUDE USING GIST (room_id WITH =, during WITH &&)\n);\n\n-- Named constraint\nALTER TABLE users ADD CONSTRAINT email_unique UNIQUE (email);",
      "meaning": "Constraints ใน PostgreSQL มีอะไรบ้าง?",
      "example": "PRIMARY KEY: unique, not null identifier. UNIQUE: no duplicates (allows one null). NOT NULL: required value. FOREIGN KEY: references another table with ON DELETE/UPDATE actions. CHECK: custom validation. EXCLUDE: prevents overlapping values (useful for scheduling). Constraints ensure data integrity at database level.",
      "exampleTranslation": "PRIMARY KEY: unique, not null identifier UNIQUE: ไม่มี duplicates (อนุญาต null หนึ่งตัว) NOT NULL: ต้องมีค่า FOREIGN KEY: references table อื่นพร้อม ON DELETE/UPDATE actions CHECK: custom validation EXCLUDE: ป้องกัน overlapping values (มีประโยชน์สำหรับ scheduling) Constraints รับประกัน data integrity ที่ database level"
    },
    {
      "vocab": "What is ON DELETE CASCADE vs RESTRICT vs SET NULL?",
      "pronunciation": "-- CASCADE - delete child rows too\nCREATE TABLE orders (\n  customer_id INTEGER REFERENCES customers(id) ON DELETE CASCADE\n);\n-- DELETE FROM customers WHERE id = 1;  -- deletes related orders\n\n-- RESTRICT (default) - prevent deletion\nCREATE TABLE orders (\n  customer_id INTEGER REFERENCES customers(id) ON DELETE RESTRICT\n);\n-- DELETE FROM customers WHERE id = 1;  -- ERROR if has orders\n\n-- SET NULL - set foreign key to null\nCREATE TABLE orders (\n  customer_id INTEGER REFERENCES customers(id) ON DELETE SET NULL\n);\n-- DELETE FROM customers WHERE id = 1;  -- orders.customer_id = NULL\n\n-- SET DEFAULT - set to default value\nCREATE TABLE orders (\n  customer_id INTEGER DEFAULT 0 REFERENCES customers(id) ON DELETE SET DEFAULT\n);\n\n-- NO ACTION - like RESTRICT but deferred\nCREATE TABLE orders (\n  customer_id INTEGER REFERENCES customers(id) ON DELETE NO ACTION\n);",
      "meaning": "ON DELETE CASCADE vs RESTRICT vs SET NULL ต่างกันอย่างไร?",
      "example": "CASCADE: automatically delete child rows when parent is deleted. RESTRICT: prevent parent deletion if children exist. SET NULL: set foreign key to null. SET DEFAULT: set to default value. NO ACTION: like RESTRICT but can be deferred. Choose based on business logic - CASCADE for true dependencies, RESTRICT for safety.",
      "exampleTranslation": "CASCADE: ลบ child rows อัตโนมัติเมื่อ parent ถูกลบ RESTRICT: ป้องกันการลบ parent ถ้ามี children SET NULL: set foreign key เป็น null SET DEFAULT: set เป็น default value NO ACTION: เหมือน RESTRICT แต่ defer ได้ เลือกตาม business logic - CASCADE สำหรับ dependencies จริง RESTRICT สำหรับ safety"
    },
    {
      "vocab": "What is a view vs materialized view?",
      "pronunciation": "-- Regular view (virtual table)\nCREATE VIEW active_users AS\nSELECT * FROM users WHERE active = true;\n\n-- Query runs each time\nSELECT * FROM active_users;\n\n-- Materialized view (stored result)\nCREATE MATERIALIZED VIEW monthly_sales AS\nSELECT \n  DATE_TRUNC('month', created_at) as month,\n  SUM(amount) as total\nFROM orders\nGROUP BY 1;\n\n-- Result is cached, must refresh\nREFRESH MATERIALIZED VIEW monthly_sales;\n\n-- Concurrent refresh (no lock)\nREFRESH MATERIALIZED VIEW CONCURRENTLY monthly_sales;\n-- Requires unique index\nCREATE UNIQUE INDEX ON monthly_sales (month);\n\n-- Check freshness\nSELECT relname, last_refresh \nFROM pg_stat_user_tables \nWHERE relname = 'monthly_sales';",
      "meaning": "View vs materialized view ต่างกันอย่างไร?",
      "example": "Regular views are virtual - query executes each time, always current data. Materialized views store results physically - faster reads but stale data until refreshed. Use REFRESH to update. CONCURRENTLY allows reads during refresh (requires unique index). Use materialized views for expensive queries accessed frequently.",
      "exampleTranslation": "Regular views เป็น virtual - query execute ทุกครั้ง ข้อมูลปัจจุบันเสมอ Materialized views เก็บผลลัพธ์เป็น physical - อ่านเร็วกว่าแต่ data ค้างจนกว่า refresh ใช้ REFRESH เพื่ออัพเดท CONCURRENTLY อนุญาตให้อ่านระหว่าง refresh (ต้องมี unique index) ใช้ materialized views สำหรับ expensive queries ที่เข้าถึงบ่อย"
    },
    {
      "vocab": "What are stored procedures vs functions?",
      "pronunciation": "-- Function (returns value)\nCREATE FUNCTION get_user_count() \nRETURNS INTEGER AS $$\nBEGIN\n  RETURN (SELECT COUNT(*) FROM users);\nEND;\n$$ LANGUAGE plpgsql;\n\nSELECT get_user_count();\n\n-- Function with parameters\nCREATE FUNCTION get_user(p_id INTEGER)\nRETURNS users AS $$\nBEGIN\n  RETURN (SELECT * FROM users WHERE id = p_id);\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Procedure (PostgreSQL 11+, no return, can commit)\nCREATE PROCEDURE transfer_funds(\n  p_from INTEGER,\n  p_to INTEGER,\n  p_amount NUMERIC\n) AS $$\nBEGIN\n  UPDATE accounts SET balance = balance - p_amount WHERE id = p_from;\n  UPDATE accounts SET balance = balance + p_amount WHERE id = p_to;\n  COMMIT;  -- can control transaction\nEND;\n$$ LANGUAGE plpgsql;\n\nCALL transfer_funds(1, 2, 100.00);",
      "meaning": "Stored procedures และ functions ต่างกันอย่างไร?",
      "example": "Functions return a value and can be used in SELECT. Procedures (PostgreSQL 11+) don't return values and can control transactions (COMMIT/ROLLBACK within). Use functions for calculations and queries, procedures for multi-step operations with transaction control. Both use PL/pgSQL language.",
      "exampleTranslation": "Functions return ค่าและใช้ใน SELECT ได้ Procedures (PostgreSQL 11+) ไม่ return ค่าและควบคุม transactions ได้ (COMMIT/ROLLBACK ภายใน) ใช้ functions สำหรับ calculations และ queries ใช้ procedures สำหรับ multi-step operations ที่มี transaction control ทั้งคู่ใช้ PL/pgSQL language"
    },
    {
      "vocab": "What is a trigger?",
      "pronunciation": "-- Trigger function\nCREATE FUNCTION update_modified() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.modified_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create trigger\nCREATE TRIGGER update_users_modified\n  BEFORE UPDATE ON users\n  FOR EACH ROW\n  EXECUTE FUNCTION update_modified();\n\n-- Audit trigger\nCREATE FUNCTION audit_changes() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO audit_log (table_name, action, old_data, new_data, changed_at)\n  VALUES (TG_TABLE_NAME, TG_OP, row_to_json(OLD), row_to_json(NEW), NOW());\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER audit_users\n  AFTER INSERT OR UPDATE OR DELETE ON users\n  FOR EACH ROW\n  EXECUTE FUNCTION audit_changes();\n\n-- Trigger timing:\n-- BEFORE: can modify NEW, return NULL to cancel\n-- AFTER: for side effects, logging\n-- INSTEAD OF: for views",
      "meaning": "Trigger คืออะไร?",
      "example": "Triggers automatically execute functions when table events occur (INSERT, UPDATE, DELETE). BEFORE triggers can modify data or cancel operations. AFTER triggers for side effects like logging. FOR EACH ROW executes per row, FOR EACH STATEMENT once per query. Common uses: audit logs, timestamps, validation, cascading updates.",
      "exampleTranslation": "Triggers execute functions อัตโนมัติเมื่อเกิด table events (INSERT, UPDATE, DELETE) BEFORE triggers แก้ไข data หรือยกเลิก operations ได้ AFTER triggers สำหรับ side effects เช่น logging FOR EACH ROW execute ต่อ row, FOR EACH STATEMENT ครั้งเดียวต่อ query ใช้บ่อย: audit logs, timestamps, validation, cascading updates"
    },
    {
      "vocab": "What is JSONB in PostgreSQL?",
      "pronunciation": "-- Create table with JSONB\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  data JSONB\n);\n\n-- Insert JSON\nINSERT INTO products (data) VALUES \n  ('{\"name\": \"Phone\", \"price\": 999, \"tags\": [\"electronics\", \"mobile\"]}');\n\n-- Query JSON\nSELECT data->>'name' as name FROM products;  -- text\nSELECT data->'price' as price FROM products;  -- jsonb\nSELECT data#>>'{tags,0}' as first_tag FROM products;  -- path\n\n-- Filter by JSON\nSELECT * FROM products WHERE data->>'name' = 'Phone';\nSELECT * FROM products WHERE data @> '{\"price\": 999}';\nSELECT * FROM products WHERE data ? 'tags';  -- has key\nSELECT * FROM products WHERE data->'tags' ? 'mobile';  -- array contains\n\n-- GIN index for JSONB\nCREATE INDEX idx_products_data ON products USING GIN (data);\nCREATE INDEX idx_products_name ON products ((data->>'name'));",
      "meaning": "JSONB ใน PostgreSQL คืออะไร?",
      "example": "JSONB stores JSON in binary format - faster to process than JSON (text). Use -> for JSONB result, ->> for text, #>> for path. Operators: @> (contains), ? (has key), ?| (has any key), ?& (has all keys). GIN index for fast JSON queries. Best for semi-structured data, API responses, flexible schemas.",
      "exampleTranslation": "JSONB เก็บ JSON ในรูป binary - process เร็วกว่า JSON (text) ใช้ -> สำหรับผลลัพธ์ JSONB, ->> สำหรับ text, #>> สำหรับ path Operators: @> (contains), ? (has key), ?| (has any key), ?& (has all keys) GIN index สำหรับ JSON queries เร็ว ดีที่สุดสำหรับ semi-structured data, API responses, flexible schemas"
    },
    {
      "vocab": "What is full-text search in PostgreSQL?",
      "pronunciation": "-- Create tsvector column\nALTER TABLE articles ADD COLUMN search_vector TSVECTOR;\n\nUPDATE articles SET search_vector = \n  to_tsvector('english', title || ' ' || content);\n\n-- Create GIN index\nCREATE INDEX idx_articles_search ON articles USING GIN (search_vector);\n\n-- Search with tsquery\nSELECT * FROM articles \nWHERE search_vector @@ to_tsquery('english', 'database & performance');\n\n-- Ranking results\nSELECT title, ts_rank(search_vector, query) as rank\nFROM articles, to_tsquery('english', 'postgresql') query\nWHERE search_vector @@ query\nORDER BY rank DESC;\n\n-- Auto-update with trigger\nCREATE TRIGGER articles_search_update\n  BEFORE INSERT OR UPDATE ON articles\n  FOR EACH ROW EXECUTE FUNCTION\n  tsvector_update_trigger(search_vector, 'pg_catalog.english', title, content);\n\n-- Phrase search\nSELECT * FROM articles \nWHERE search_vector @@ phraseto_tsquery('full text search');",
      "meaning": "Full-text search ใน PostgreSQL คืออะไร?",
      "example": "PostgreSQL has built-in full-text search. tsvector stores searchable tokens, tsquery defines search terms. Operators: & (AND), | (OR), ! (NOT), <-> (followed by). GIN index for fast search. ts_rank for relevance ranking. Supports stemming, stop words, multiple languages. Good for moderate search needs without external tools.",
      "exampleTranslation": "PostgreSQL มี built-in full-text search tsvector เก็บ searchable tokens, tsquery กำหนด search terms Operators: & (AND), | (OR), ! (NOT), <-> (followed by) GIN index สำหรับ search เร็ว ts_rank สำหรับ relevance ranking รองรับ stemming, stop words, หลายภาษา ดีสำหรับ search needs ปานกลางโดยไม่ต้องใช้ external tools"
    },
    {
      "vocab": "What is table partitioning?",
      "pronunciation": "-- Range partitioning by date\nCREATE TABLE orders (\n  id SERIAL,\n  created_at TIMESTAMP,\n  amount NUMERIC\n) PARTITION BY RANGE (created_at);\n\nCREATE TABLE orders_2023 PARTITION OF orders\n  FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');\n\nCREATE TABLE orders_2024 PARTITION OF orders\n  FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');\n\n-- List partitioning\nCREATE TABLE users (\n  id SERIAL,\n  country TEXT\n) PARTITION BY LIST (country);\n\nCREATE TABLE users_us PARTITION OF users FOR VALUES IN ('US');\nCREATE TABLE users_eu PARTITION OF users FOR VALUES IN ('UK', 'DE', 'FR');\n\n-- Hash partitioning\nCREATE TABLE logs (\n  id SERIAL,\n  user_id INTEGER\n) PARTITION BY HASH (user_id);\n\nCREATE TABLE logs_p0 PARTITION OF logs FOR VALUES WITH (MODULUS 4, REMAINDER 0);\nCREATE TABLE logs_p1 PARTITION OF logs FOR VALUES WITH (MODULUS 4, REMAINDER 1);",
      "meaning": "Table partitioning คืออะไร?",
      "example": "Partitioning splits large tables into smaller physical tables. Range partitioning by date/number ranges. List partitioning by specific values. Hash partitioning for even distribution. Benefits: faster queries on partition key, easier maintenance (drop old partitions), parallel query execution. Use for tables with millions of rows.",
      "exampleTranslation": "Partitioning แบ่ง tables ใหญ่เป็น physical tables เล็กกว่า Range partitioning ตาม date/number ranges List partitioning ตาม specific values Hash partitioning สำหรับการกระจายที่สม่ำเสมอ ประโยชน์: queries เร็วขึ้นบน partition key, maintenance ง่ายขึ้น (drop old partitions), parallel query execution ใช้สำหรับ tables ที่มีหลายล้าน rows"
    },
    {
      "vocab": "What is VACUUM and ANALYZE?",
      "pronunciation": "-- VACUUM - reclaim dead tuple space\nVACUUM users;              -- basic vacuum\nVACUUM FULL users;         -- rewrite table, reclaims more space\nVACUUM VERBOSE users;      -- show progress\n\n-- ANALYZE - update statistics for query planner\nANALYZE users;\nANALYZE users (email);     -- specific columns\n\n-- Combined\nVACUUM ANALYZE users;\n\n-- Check dead tuples\nSELECT relname, n_dead_tup, n_live_tup,\n  n_dead_tup::float / NULLIF(n_live_tup, 0) as dead_ratio\nFROM pg_stat_user_tables\nWHERE n_dead_tup > 1000;\n\n-- Autovacuum settings (postgresql.conf)\n-- autovacuum = on\n-- autovacuum_vacuum_threshold = 50\n-- autovacuum_analyze_threshold = 50\n-- autovacuum_vacuum_scale_factor = 0.2\n\n-- Check autovacuum activity\nSELECT * FROM pg_stat_user_tables;",
      "meaning": "VACUUM และ ANALYZE คืออะไร?",
      "example": "VACUUM reclaims space from deleted/updated rows (dead tuples). PostgreSQL uses MVCC, so old versions aren't immediately removed. VACUUM FULL rewrites the entire table (locks it). ANALYZE updates statistics for the query planner. Autovacuum runs automatically but may need tuning for busy tables.",
      "exampleTranslation": "VACUUM reclaim space จาก deleted/updated rows (dead tuples) PostgreSQL ใช้ MVCC ดังนั้น old versions ไม่ถูกลบทันที VACUUM FULL rewrite ทั้ง table (lock มัน) ANALYZE อัพเดท statistics สำหรับ query planner Autovacuum ทำงานอัตโนมัติแต่อาจต้อง tune สำหรับ busy tables"
    },
    {
      "vocab": "What is the difference between DELETE, TRUNCATE, and DROP?",
      "pronunciation": "-- DELETE - remove rows, logged, can rollback\nDELETE FROM users;              -- all rows\nDELETE FROM users WHERE id = 1; -- specific rows\n-- Triggers fire, slow for large tables\n\n-- TRUNCATE - remove all rows, faster\nTRUNCATE users;                 -- instant\nTRUNCATE users RESTART IDENTITY; -- reset sequences\nTRUNCATE users CASCADE;         -- truncate related tables\n-- No triggers, can rollback in transaction\n\n-- DROP - remove table entirely\nDROP TABLE users;              -- error if exists\nDROP TABLE IF EXISTS users;    -- no error\nDROP TABLE users CASCADE;      -- drop dependent objects\n\n-- Comparison:\n-- DELETE: row by row, triggers, WHERE clause, slow\n-- TRUNCATE: instant, no triggers, no WHERE, can rollback\n-- DROP: removes table definition, all data, indexes, constraints",
      "meaning": "DELETE, TRUNCATE และ DROP ต่างกันอย่างไร?",
      "example": "DELETE removes rows one by one, fires triggers, supports WHERE, slow for many rows. TRUNCATE instantly removes all rows, no triggers, resets sequences, much faster. DROP removes the entire table including structure, indexes, and constraints. Use DELETE for specific rows, TRUNCATE to empty table, DROP to remove table.",
      "exampleTranslation": "DELETE ลบ rows ทีละตัว fire triggers รองรับ WHERE ช้าสำหรับหลาย rows TRUNCATE ลบทุก rows ทันที ไม่มี triggers reset sequences เร็วกว่ามาก DROP ลบทั้ง table รวมทั้ง structure, indexes และ constraints ใช้ DELETE สำหรับ specific rows, TRUNCATE เพื่อ empty table, DROP เพื่อลบ table"
    },
    {
      "vocab": "What is UPSERT (INSERT ON CONFLICT)?",
      "pronunciation": "-- Insert or update on conflict\nINSERT INTO users (email, name)\nVALUES ('john@example.com', 'John')\nON CONFLICT (email) \nDO UPDATE SET name = EXCLUDED.name;\n\n-- Insert or do nothing\nINSERT INTO users (email, name)\nVALUES ('john@example.com', 'John')\nON CONFLICT (email) DO NOTHING;\n\n-- With multiple columns\nINSERT INTO inventory (product_id, warehouse_id, quantity)\nVALUES (1, 1, 100)\nON CONFLICT (product_id, warehouse_id)\nDO UPDATE SET quantity = inventory.quantity + EXCLUDED.quantity;\n\n-- Conditional update\nINSERT INTO products (id, name, updated_at)\nVALUES (1, 'New Name', NOW())\nON CONFLICT (id)\nDO UPDATE SET \n  name = EXCLUDED.name,\n  updated_at = EXCLUDED.updated_at\nWHERE products.updated_at < EXCLUDED.updated_at;  -- only if newer\n\n-- EXCLUDED refers to the row that would have been inserted",
      "meaning": "UPSERT (INSERT ON CONFLICT) คืออะไร?",
      "example": "UPSERT combines INSERT and UPDATE in one atomic operation. ON CONFLICT specifies which constraint triggers the update. DO UPDATE uses EXCLUDED to reference the would-be inserted values. DO NOTHING ignores conflicts. Can add WHERE for conditional updates. Essential for sync operations and idempotent inserts.",
      "exampleTranslation": "UPSERT รวม INSERT และ UPDATE ในหนึ่ง atomic operation ON CONFLICT ระบุ constraint ไหนที่ trigger update DO UPDATE ใช้ EXCLUDED เพื่อ reference ค่าที่จะ insert DO NOTHING ignore conflicts เพิ่ม WHERE สำหรับ conditional updates ได้ จำเป็นสำหรับ sync operations และ idempotent inserts"
    },
    {
      "vocab": "What is RETURNING clause?",
      "pronunciation": "-- Return inserted row\nINSERT INTO users (name, email)\nVALUES ('John', 'john@example.com')\nRETURNING *;\n\n-- Return specific columns\nINSERT INTO users (name, email)\nVALUES ('John', 'john@example.com')\nRETURNING id, created_at;\n\n-- Return from UPDATE\nUPDATE users SET active = true WHERE id = 1\nRETURNING *;\n\n-- Return from DELETE\nDELETE FROM users WHERE id = 1\nRETURNING *;\n\n-- Use in CTE for complex operations\nWITH inserted AS (\n  INSERT INTO orders (customer_id, total)\n  VALUES (1, 100.00)\n  RETURNING id\n)\nINSERT INTO order_items (order_id, product_id, quantity)\nSELECT id, 1, 2 FROM inserted;\n\n-- Useful for:\n-- Getting auto-generated IDs\n-- Audit logging\n-- Chaining operations",
      "meaning": "RETURNING clause คืออะไร?",
      "example": "RETURNING returns data from modified rows in INSERT, UPDATE, DELETE. Returns any columns including generated values (id, timestamps). Can be used with CTEs for complex multi-table operations. Eliminates need for separate SELECT after modification. Very useful for getting auto-generated IDs.",
      "exampleTranslation": "RETURNING return ข้อมูลจาก modified rows ใน INSERT, UPDATE, DELETE Return columns ใดก็ได้รวมทั้ง generated values (id, timestamps) ใช้กับ CTEs สำหรับ complex multi-table operations ได้ ไม่ต้อง SELECT แยกหลัง modification มีประโยชน์มากสำหรับการดึง auto-generated IDs"
    },
    {
      "vocab": "What is a lateral join?",
      "pronunciation": "-- Get top 3 orders per customer\nSELECT c.name, o.id, o.amount\nFROM customers c\nLATERAL (\n  SELECT id, amount FROM orders\n  WHERE customer_id = c.id  -- references outer query\n  ORDER BY amount DESC\n  LIMIT 3\n) o;\n\n-- Without LATERAL (doesn't work)\n-- Subquery can't reference c.id\n\n-- Alternative with window function\nSELECT name, order_id, amount FROM (\n  SELECT c.name, o.id as order_id, o.amount,\n    ROW_NUMBER() OVER (PARTITION BY c.id ORDER BY o.amount DESC) as rn\n  FROM customers c JOIN orders o ON c.id = o.customer_id\n) sub WHERE rn <= 3;\n\n-- LATERAL with set-returning function\nSELECT * FROM customers c,\nLATERAL unnest(c.tags) AS tag;\n\n-- LATERAL with generate_series\nSELECT d.date, COALESCE(o.count, 0) as order_count\nFROM generate_series('2024-01-01'::date, '2024-01-31', '1 day') d(date)\nLEFT JOIN LATERAL (\n  SELECT COUNT(*) as count FROM orders WHERE DATE(created_at) = d.date\n) o ON true;",
      "meaning": "Lateral join คืออะไร?",
      "example": "LATERAL allows a subquery to reference columns from preceding tables in the FROM clause. Essential for top-N per group queries, correlated subqueries in FROM, and set-returning functions. The subquery runs once per row from the outer table. More flexible than regular subqueries or window functions for some patterns.",
      "exampleTranslation": "LATERAL อนุญาตให้ subquery reference columns จาก tables ก่อนหน้าใน FROM clause จำเป็นสำหรับ top-N per group queries, correlated subqueries ใน FROM และ set-returning functions Subquery รันหนึ่งครั้งต่อ row จาก outer table ยืดหยุ่นกว่า regular subqueries หรือ window functions สำหรับบาง patterns"
    },
    {
      "vocab": "What is connection pooling (PgBouncer)?",
      "pronunciation": "-- Why pooling?\n-- PostgreSQL creates process per connection (expensive)\n-- Without pooling: 100 users = 100 connections = 100 processes\n-- With pooling: 100 users share 20 connections\n\n-- PgBouncer modes:\n-- Session: connection per session (least efficient)\n-- Transaction: connection per transaction (recommended)\n-- Statement: connection per statement (most efficient, limitations)\n\n-- pgbouncer.ini\n[databases]\nmydb = host=localhost port=5432 dbname=mydb\n\n[pgbouncer]\nlisten_port = 6432\nlisten_addr = 0.0.0.0\nauth_type = md5\npool_mode = transaction\nmax_client_conn = 1000\ndefault_pool_size = 20\n\n-- Connect through PgBouncer\npsql -h localhost -p 6432 -U user mydb\n\n-- Application config\nDATABASE_URL=postgresql://user:pass@localhost:6432/mydb",
      "meaning": "Connection pooling (PgBouncer) คืออะไร?",
      "example": "PostgreSQL creates heavyweight process per connection. PgBouncer pools connections, allowing many clients to share fewer database connections. Transaction mode (recommended) assigns connection per transaction. Reduces database load, enables more concurrent users. Essential for production with many short-lived connections.",
      "exampleTranslation": "PostgreSQL สร้าง heavyweight process ต่อ connection PgBouncer pool connections อนุญาตให้หลาย clients แชร์ database connections น้อยลง Transaction mode (แนะนำ) assign connection ต่อ transaction ลด database load รองรับ concurrent users มากขึ้น จำเป็นสำหรับ production ที่มี short-lived connections มาก"
    },
    {
      "vocab": "What is COPY command?",
      "pronunciation": "-- Export to CSV\nCOPY users TO '/tmp/users.csv' WITH (FORMAT CSV, HEADER);\n\n-- Export query result\nCOPY (SELECT * FROM users WHERE active) TO '/tmp/active_users.csv' WITH CSV;\n\n-- Import from CSV\nCOPY users FROM '/tmp/users.csv' WITH (FORMAT CSV, HEADER);\n\n-- From stdin (useful in scripts)\nCOPY users FROM STDIN WITH CSV;\n\n-- \\copy in psql (client-side, no superuser needed)\n\\copy users TO 'users.csv' WITH CSV HEADER\n\\copy users FROM 'users.csv' WITH CSV HEADER\n\n-- Performance options\nCOPY large_table FROM '/tmp/data.csv'\nWITH (\n  FORMAT CSV,\n  HEADER,\n  DELIMITER ',',\n  NULL '\\N',\n  QUOTE '\"',\n  ESCAPE '\\\\'\n);\n\n-- Much faster than INSERT:\n-- COPY: ~100,000 rows/second\n-- INSERT: ~1,000 rows/second",
      "meaning": "COPY command คืออะไร?",
      "example": "COPY is PostgreSQL's fastest way to bulk import/export data. Server-side COPY requires superuser and file on server. \\copy in psql works client-side without superuser. Supports CSV, text formats. 10-100x faster than INSERT for bulk loading. Essential for data migration, ETL, and backups.",
      "exampleTranslation": "COPY เป็นวิธีที่เร็วที่สุดของ PostgreSQL ในการ bulk import/export data Server-side COPY ต้อง superuser และ file บน server \\copy ใน psql ทำงาน client-side ไม่ต้อง superuser รองรับ CSV, text formats เร็วกว่า INSERT 10-100 เท่าสำหรับ bulk loading จำเป็นสำหรับ data migration, ETL และ backups"
    },
    {
      "vocab": "What is pg_dump and pg_restore?",
      "pronunciation": "-- Dump entire database (SQL format)\npg_dump mydb > backup.sql\n\n-- Dump with custom format (compressed, parallel restore)\npg_dump -Fc mydb > backup.dump\n\n-- Dump specific tables\npg_dump -t users -t orders mydb > partial.sql\n\n-- Dump schema only\npg_dump --schema-only mydb > schema.sql\n\n-- Dump data only\npg_dump --data-only mydb > data.sql\n\n-- Restore SQL dump\npsql mydb < backup.sql\n\n-- Restore custom format\npg_restore -d mydb backup.dump\n\n-- Parallel restore (faster)\npg_restore -j 4 -d mydb backup.dump\n\n-- Restore to different database\ncreatedb newdb\npg_restore -d newdb backup.dump\n\n-- Dump all databases\npg_dumpall > all_databases.sql\n\n-- Include roles\npg_dumpall --roles-only > roles.sql",
      "meaning": "pg_dump และ pg_restore คืออะไร?",
      "example": "pg_dump exports database to file. SQL format is human-readable. Custom format (-Fc) is compressed and supports parallel restore. pg_restore imports custom format dumps. Use -j for parallel restore. Can dump specific tables, schema-only, or data-only. pg_dumpall exports all databases including roles.",
      "exampleTranslation": "pg_dump export database เป็นไฟล์ SQL format อ่านได้ง่าย Custom format (-Fc) บีบอัดและรองรับ parallel restore pg_restore import custom format dumps ใช้ -j สำหรับ parallel restore Dump specific tables, schema-only หรือ data-only ได้ pg_dumpall export ทุก databases รวมทั้ง roles"
    },
    {
      "vocab": "What is logical replication?",
      "pronunciation": "-- On publisher (source)\nCREATE PUBLICATION my_pub FOR ALL TABLES;\n-- Or specific tables\nCREATE PUBLICATION my_pub FOR TABLE users, orders;\n\n-- On subscriber (target)\nCREATE SUBSCRIPTION my_sub\n  CONNECTION 'host=source port=5432 dbname=mydb user=replicator'\n  PUBLICATION my_pub;\n\n-- Check replication status\nSELECT * FROM pg_stat_replication;  -- on publisher\nSELECT * FROM pg_stat_subscription; -- on subscriber\n\n-- Add table to publication\nALTER PUBLICATION my_pub ADD TABLE new_table;\n\n-- Refresh subscription\nALTER SUBSCRIPTION my_sub REFRESH PUBLICATION;\n\n-- Use cases:\n-- Selective replication (specific tables)\n-- Cross-version replication\n-- Data integration\n-- Zero-downtime upgrades\n\n-- vs Streaming Replication:\n-- Streaming: full database, binary, standby only\n-- Logical: selective, row-level, can write to subscriber",
      "meaning": "Logical replication คืออะไร?",
      "example": "Logical replication copies data changes at row level between databases. Publisher sends changes, subscriber applies them. Can replicate specific tables, works across PostgreSQL versions. Subscriber can have additional indexes and local tables. Use for selective replication, data integration, and version upgrades.",
      "exampleTranslation": "Logical replication copy data changes ที่ row level ระหว่าง databases Publisher ส่ง changes, subscriber apply มัน Replicate specific tables ได้ ทำงานข้าม PostgreSQL versions Subscriber มี indexes เพิ่มเติมและ local tables ได้ ใช้สำหรับ selective replication, data integration และ version upgrades"
    },
    {
      "vocab": "What is COALESCE and NULLIF?",
      "pronunciation": "-- COALESCE - first non-null value\nSELECT COALESCE(nickname, first_name, 'Unknown') as display_name\nFROM users;\n\n-- Common: default value for NULL\nSELECT COALESCE(discount, 0) as discount FROM products;\n\n-- With aggregation\nSELECT COALESCE(SUM(amount), 0) as total FROM orders WHERE 1=0;\n-- Returns 0 instead of NULL\n\n-- NULLIF - returns NULL if equal\nSELECT NULLIF(value, 0) FROM data;  -- NULL if value is 0\n\n-- Avoid division by zero\nSELECT total / NULLIF(count, 0) as average FROM stats;\n-- Returns NULL instead of error when count is 0\n\n-- Combined\nSELECT \n  total / COALESCE(NULLIF(count, 0), 1) as safe_average\nFROM stats;\n-- Returns total if count is 0 or NULL\n\n-- GREATEST / LEAST\nSELECT GREATEST(a, b, c) as max_value FROM numbers;\nSELECT LEAST(a, b, c) as min_value FROM numbers;",
      "meaning": "COALESCE และ NULLIF คืออะไร?",
      "example": "COALESCE returns the first non-null argument. Use for default values and handling NULL in calculations. NULLIF returns NULL if two arguments are equal, otherwise the first argument. Use to avoid division by zero. GREATEST/LEAST return max/min of arguments. Essential for NULL-safe queries.",
      "exampleTranslation": "COALESCE return argument แรกที่ไม่ใช่ null ใช้สำหรับ default values และจัดการ NULL ใน calculations NULLIF return NULL ถ้าสอง arguments เท่ากัน ไม่งั้น return argument แรก ใช้เพื่อหลีกเลี่ยง division by zero GREATEST/LEAST return max/min ของ arguments จำเป็นสำหรับ NULL-safe queries"
    },
    {
      "vocab": "What is CASE expression?",
      "pronunciation": "-- Simple CASE\nSELECT name,\n  CASE status\n    WHEN 'A' THEN 'Active'\n    WHEN 'I' THEN 'Inactive'\n    WHEN 'P' THEN 'Pending'\n    ELSE 'Unknown'\n  END as status_text\nFROM users;\n\n-- Searched CASE (with conditions)\nSELECT name, amount,\n  CASE\n    WHEN amount >= 1000 THEN 'High'\n    WHEN amount >= 100 THEN 'Medium'\n    WHEN amount > 0 THEN 'Low'\n    ELSE 'Zero'\n  END as tier\nFROM orders;\n\n-- In WHERE clause\nSELECT * FROM products\nWHERE CASE \n  WHEN category = 'electronics' THEN price > 100\n  WHEN category = 'books' THEN price > 10\n  ELSE true\nEND;\n\n-- Conditional aggregation\nSELECT \n  COUNT(*) as total,\n  COUNT(*) FILTER (WHERE status = 'active') as active_count,\n  SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_sum\nFROM users;",
      "meaning": "CASE expression คืออะไร?",
      "example": "CASE provides conditional logic in SQL. Simple CASE compares against specific values. Searched CASE evaluates boolean conditions. Can be used in SELECT, WHERE, ORDER BY, and with aggregations. FILTER clause (PostgreSQL) is cleaner for conditional aggregation. Returns NULL if no condition matches and no ELSE.",
      "exampleTranslation": "CASE ให้ conditional logic ใน SQL Simple CASE เปรียบเทียบกับค่าเฉพาะ Searched CASE evaluate boolean conditions ใช้ใน SELECT, WHERE, ORDER BY และกับ aggregations ได้ FILTER clause (PostgreSQL) สะอาดกว่าสำหรับ conditional aggregation Return NULL ถ้าไม่มี condition ตรงและไม่มี ELSE"
    },
    {
      "vocab": "What are aggregate functions with FILTER?",
      "pronunciation": "-- Traditional conditional aggregation\nSELECT \n  SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) as paid_total,\n  SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) as pending_total\nFROM orders;\n\n-- With FILTER (PostgreSQL 9.4+, cleaner)\nSELECT \n  SUM(amount) FILTER (WHERE status = 'paid') as paid_total,\n  SUM(amount) FILTER (WHERE status = 'pending') as pending_total,\n  COUNT(*) FILTER (WHERE status = 'paid') as paid_count,\n  AVG(amount) FILTER (WHERE amount > 100) as high_value_avg\nFROM orders;\n\n-- Multiple conditions\nSELECT\n  date_trunc('month', created_at) as month,\n  COUNT(*) FILTER (WHERE status = 'completed') as completed,\n  COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled,\n  SUM(amount) FILTER (WHERE status = 'completed' AND amount > 0) as revenue\nFROM orders\nGROUP BY 1;\n\n-- With window functions\nSELECT *,\n  SUM(amount) FILTER (WHERE status = 'paid') OVER (PARTITION BY customer_id) as customer_paid_total\nFROM orders;",
      "meaning": "Aggregate functions กับ FILTER คืออะไร?",
      "example": "FILTER clause (PostgreSQL 9.4+) applies conditions to aggregate functions. Cleaner than CASE WHEN inside aggregates. Works with COUNT, SUM, AVG, and other aggregates. Can combine with GROUP BY and window functions. More readable and sometimes faster than CASE approach.",
      "exampleTranslation": "FILTER clause (PostgreSQL 9.4+) apply conditions กับ aggregate functions สะอาดกว่า CASE WHEN ภายใน aggregates ทำงานกับ COUNT, SUM, AVG และ aggregates อื่นๆ รวมกับ GROUP BY และ window functions ได้ อ่านง่ายกว่าและบางทีเร็วกว่า CASE approach"
    },
    {
      "vocab": "What is array type in PostgreSQL?",
      "pronunciation": "-- Create table with array\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  name TEXT,\n  tags TEXT[]\n);\n\n-- Insert array values\nINSERT INTO products (name, tags) VALUES\n  ('Phone', ARRAY['electronics', 'mobile']),\n  ('Book', '{books, education}');  -- alternative syntax\n\n-- Query arrays\nSELECT * FROM products WHERE 'electronics' = ANY(tags);\nSELECT * FROM products WHERE tags @> ARRAY['mobile'];  -- contains\nSELECT * FROM products WHERE tags && ARRAY['books', 'mobile'];  -- overlaps\n\n-- Array functions\nSELECT array_length(tags, 1) FROM products;\nSELECT array_append(tags, 'new') FROM products;\nSELECT array_cat(tags, ARRAY['a', 'b']) FROM products;\nSELECT unnest(tags) FROM products;  -- expand to rows\n\n-- Array access\nSELECT tags[1] FROM products;  -- first element (1-indexed)\nSELECT tags[1:2] FROM products;  -- slice\n\n-- GIN index for array\nCREATE INDEX idx_tags ON products USING GIN (tags);",
      "meaning": "Array type ใน PostgreSQL คืออะไร?",
      "example": "PostgreSQL supports native array types for any data type. Use ANY for element membership, @> for contains, && for overlap. Array functions: length, append, cat, unnest. Arrays are 1-indexed. GIN index for fast array queries. Good for tags, categories, or denormalized data. Consider JSONB for more complex structures.",
      "exampleTranslation": "PostgreSQL รองรับ native array types สำหรับ data type ใดก็ได้ ใช้ ANY สำหรับ element membership, @> สำหรับ contains, && สำหรับ overlap Array functions: length, append, cat, unnest Arrays เป็น 1-indexed GIN index สำหรับ fast array queries ดีสำหรับ tags, categories หรือ denormalized data พิจารณา JSONB สำหรับ structures ที่ซับซ้อนกว่า"
    },
    {
      "vocab": "What is DISTINCT ON?",
      "pronunciation": "-- Get first row per group (PostgreSQL-specific)\nSELECT DISTINCT ON (customer_id)\n  customer_id, id as order_id, created_at, amount\nFROM orders\nORDER BY customer_id, created_at DESC;\n-- Gets most recent order per customer\n\n-- Multiple columns in DISTINCT ON\nSELECT DISTINCT ON (department, job_title)\n  department, job_title, name, salary\nFROM employees\nORDER BY department, job_title, salary DESC;\n-- Highest paid per department+title combo\n\n-- vs GROUP BY\n-- GROUP BY: aggregate functions, summarize\n-- DISTINCT ON: select complete row, first per group\n\n-- vs Window function\nSELECT * FROM (\n  SELECT *,\n    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY created_at DESC) as rn\n  FROM orders\n) sub WHERE rn = 1;\n-- Same result, but DISTINCT ON is simpler and often faster",
      "meaning": "DISTINCT ON คืออะไร?",
      "example": "DISTINCT ON returns first row for each unique combination of specified columns. Must ORDER BY the DISTINCT ON columns first, then your preferred ordering. PostgreSQL-specific, very efficient for \"first/latest per group\" queries. Alternative to window functions with ROW_NUMBER() = 1. ORDER BY required.",
      "exampleTranslation": "DISTINCT ON return row แรกสำหรับแต่ละ unique combination ของ columns ที่ระบุ ต้อง ORDER BY DISTINCT ON columns ก่อน แล้วค่อย ordering ที่ต้องการ PostgreSQL-specific มีประสิทธิภาพมากสำหรับ \"first/latest per group\" queries ทางเลือกแทน window functions กับ ROW_NUMBER() = 1 ต้องมี ORDER BY"
    },
    {
      "vocab": "What is the difference between COUNT(*) vs COUNT(column) vs COUNT(DISTINCT)?",
      "pronunciation": "-- COUNT(*) - counts all rows including NULLs\nSELECT COUNT(*) FROM users;  -- 100 rows\n\n-- COUNT(column) - counts non-NULL values\nSELECT COUNT(email) FROM users;  -- 95 (5 have NULL email)\n\n-- COUNT(DISTINCT column) - counts unique non-NULL values\nSELECT COUNT(DISTINCT country) FROM users;  -- 10 unique countries\n\n-- Multiple distincts\nSELECT \n  COUNT(*) as total,\n  COUNT(email) as with_email,\n  COUNT(DISTINCT email) as unique_emails,\n  COUNT(DISTINCT country) as countries\nFROM users;\n\n-- DISTINCT in other aggregates\nSELECT \n  SUM(DISTINCT amount) as unique_amounts_sum,\n  AVG(DISTINCT score) as unique_scores_avg\nFROM data;\n\n-- Performance: COUNT(*) is usually faster\n-- COUNT(column) needs to check for NULL\n-- COUNT(DISTINCT) needs to track unique values",
      "meaning": "COUNT(*) vs COUNT(column) vs COUNT(DISTINCT) ต่างกันอย่างไร?",
      "example": "COUNT(*) counts all rows regardless of NULL values - fastest. COUNT(column) counts only non-NULL values in that column. COUNT(DISTINCT column) counts unique non-NULL values. DISTINCT can be used with other aggregates too. COUNT(*) is optimized in PostgreSQL and preferred when counting rows.",
      "exampleTranslation": "COUNT(*) นับทุก rows ไม่ว่าจะมี NULL values - เร็วที่สุด COUNT(column) นับเฉพาะ non-NULL values ใน column นั้น COUNT(DISTINCT column) นับ unique non-NULL values DISTINCT ใช้กับ aggregates อื่นได้เช่นกัน COUNT(*) ถูก optimize ใน PostgreSQL และใช้บ่อยเมื่อนับ rows"
    },
    {
      "vocab": "What is GROUPING SETS, CUBE, and ROLLUP?",
      "pronunciation": "-- GROUPING SETS - multiple groupings in one query\nSELECT region, product, SUM(sales)\nFROM sales_data\nGROUP BY GROUPING SETS (\n  (region, product),  -- by region and product\n  (region),           -- subtotal by region\n  (product),          -- subtotal by product\n  ()                  -- grand total\n);\n\n-- ROLLUP - hierarchical subtotals\nSELECT year, quarter, month, SUM(sales)\nFROM sales_data\nGROUP BY ROLLUP (year, quarter, month);\n-- Produces: (year,quarter,month), (year,quarter), (year), ()\n\n-- CUBE - all combinations\nSELECT region, product, SUM(sales)\nFROM sales_data\nGROUP BY CUBE (region, product);\n-- Produces: (region,product), (region), (product), ()\n\n-- Identify grouping level\nSELECT \n  CASE WHEN GROUPING(region) = 1 THEN 'All Regions' ELSE region END,\n  CASE WHEN GROUPING(product) = 1 THEN 'All Products' ELSE product END,\n  SUM(sales)\nFROM sales_data\nGROUP BY CUBE (region, product);",
      "meaning": "GROUPING SETS, CUBE และ ROLLUP คืออะไร?",
      "example": "GROUPING SETS creates multiple groupings in single query - like multiple GROUP BY combined. ROLLUP creates hierarchical subtotals (year -> quarter -> month -> total). CUBE creates all possible combinations of groupings. GROUPING() function identifies which level produced the row. Essential for reporting and data analysis.",
      "exampleTranslation": "GROUPING SETS สร้างหลาย groupings ใน query เดียว เหมือนหลาย GROUP BY รวมกัน ROLLUP สร้าง hierarchical subtotals (year -> quarter -> month -> total) CUBE สร้างทุก combinations ของ groupings ที่เป็นไปได้ GROUPING() function ระบุว่า level ไหนสร้าง row จำเป็นสำหรับ reporting และ data analysis"
    },
    {
      "vocab": "What is CTid in PostgreSQL?",
      "pronunciation": "-- ctid is physical row location (page, offset)\nSELECT ctid, * FROM users LIMIT 5;\n-- ctid: (0,1), (0,2), (0,3)... (page 0, rows 1,2,3)\n\n-- Delete duplicate rows keeping one\nDELETE FROM users a\nUSING users b\nWHERE a.ctid < b.ctid\n  AND a.email = b.email;\n\n-- Alternative: keep row with min ctid per email\nDELETE FROM users\nWHERE ctid NOT IN (\n  SELECT MIN(ctid) FROM users GROUP BY email\n);\n\n-- Find duplicates\nSELECT email, COUNT(*), array_agg(ctid)\nFROM users\nGROUP BY email\nHAVING COUNT(*) > 1;\n\n-- Note: ctid changes after VACUUM\n-- Don't store or rely on ctid long-term\n-- Use for one-time deduplication only",
      "meaning": "CTid ใน PostgreSQL คืออะไร?",
      "example": "ctid is a system column showing physical row location (page number, row offset). Used for identifying and removing duplicate rows without unique key. Caution: ctid changes after VACUUM or updates. Only use for immediate operations like deduplication, not for persistent references.",
      "exampleTranslation": "ctid เป็น system column ที่แสดง physical row location (page number, row offset) ใช้สำหรับ identify และลบ duplicate rows โดยไม่มี unique key ข้อควรระวัง: ctid เปลี่ยนหลัง VACUUM หรือ updates ใช้สำหรับ operations ทันทีเช่น deduplication เท่านั้น ไม่ใช่ persistent references"
    },
    {
      "vocab": "What is the difference between UNION and UNION ALL?",
      "pronunciation": "-- UNION - combines and removes duplicates\nSELECT name FROM customers\nUNION\nSELECT name FROM suppliers;\n-- Slower: sorts and deduplicates\n\n-- UNION ALL - combines keeping duplicates\nSELECT name FROM customers\nUNION ALL\nSELECT name FROM suppliers;\n-- Faster: just appends results\n\n-- Multiple UNIONs\nSELECT 'customer' as type, name FROM customers\nUNION ALL\nSELECT 'supplier', name FROM suppliers\nUNION ALL\nSELECT 'employee', name FROM employees;\n\n-- With ORDER BY (at the end)\nSELECT name, 'customer' as source FROM customers\nUNION ALL\nSELECT name, 'supplier' FROM suppliers\nORDER BY name;\n\n-- INTERSECT - common rows only\nSELECT name FROM customers\nINTERSECT\nSELECT name FROM suppliers;\n\n-- EXCEPT - rows in first but not second\nSELECT name FROM customers\nEXCEPT\nSELECT name FROM suppliers;",
      "meaning": "UNION และ UNION ALL ต่างกันอย่างไร?",
      "example": "UNION combines results and removes duplicates (slower, requires sort). UNION ALL keeps all rows including duplicates (faster). Always prefer UNION ALL when duplicates are acceptable or impossible. INTERSECT returns common rows. EXCEPT returns rows in first query not in second. All require matching column counts and compatible types.",
      "exampleTranslation": "UNION รวมผลลัพธ์และลบ duplicates (ช้ากว่า ต้อง sort) UNION ALL เก็บทุก rows รวมทั้ง duplicates (เร็วกว่า) ใช้ UNION ALL เสมอเมื่อ duplicates ยอมรับได้หรือเป็นไปไม่ได้ INTERSECT return rows ที่มีเหมือนกัน EXCEPT return rows ใน query แรกที่ไม่มีใน query ที่สอง ทั้งหมดต้อง matching column counts และ compatible types"
    },
    {
      "vocab": "What is advisory lock?",
      "pronunciation": "-- Session-level advisory lock\nSELECT pg_advisory_lock(123);  -- acquire lock with key 123\n-- Do work...\nSELECT pg_advisory_unlock(123);  -- release\n\n-- Transaction-level (auto-releases at commit/rollback)\nSELECT pg_advisory_xact_lock(123);\n\n-- Try lock (non-blocking)\nSELECT pg_try_advisory_lock(123);  -- returns true if acquired\n\n-- Two-key locks (for finer granularity)\nSELECT pg_advisory_lock(classid, objid);\nSELECT pg_advisory_lock(1, 42);  -- lock table 1, row 42\n\n-- Use cases:\n-- 1. Prevent concurrent job execution\nIF pg_try_advisory_lock(12345) THEN\n  -- Run job\n  PERFORM pg_advisory_unlock(12345);\nEND IF;\n\n-- 2. Application-level locking\nSELECT pg_advisory_lock(hashtext('process-orders'));\n\n-- Check active locks\nSELECT * FROM pg_locks WHERE locktype = 'advisory';",
      "meaning": "Advisory lock คืออะไร?",
      "example": "Advisory locks are application-defined locks not tied to any table or row. Use for coordinating processes, preventing concurrent job execution, or custom locking logic. Session-level locks persist until released or disconnected. Transaction-level auto-release. Non-blocking version with try_advisory_lock. Identified by integer key(s).",
      "exampleTranslation": "Advisory locks คือ application-defined locks ที่ไม่ผูกกับ table หรือ row ใดๆ ใช้สำหรับ coordinating processes ป้องกัน concurrent job execution หรือ custom locking logic Session-level locks คงอยู่จนกว่าจะ release หรือ disconnect Transaction-level auto-release Non-blocking version ด้วย try_advisory_lock ระบุด้วย integer key(s)"
    },
    {
      "vocab": "What is table inheritance in PostgreSQL?",
      "pronunciation": "-- Parent table\nCREATE TABLE vehicles (\n  id SERIAL PRIMARY KEY,\n  brand VARCHAR(100),\n  year INTEGER\n);\n\n-- Child tables inherit parent columns\nCREATE TABLE cars (\n  num_doors INTEGER\n) INHERITS (vehicles);\n\nCREATE TABLE motorcycles (\n  engine_cc INTEGER\n) INHERITS (vehicles);\n\n-- Insert into child tables\nINSERT INTO cars (brand, year, num_doors) VALUES ('Toyota', 2024, 4);\nINSERT INTO motorcycles (brand, year, engine_cc) VALUES ('Honda', 2024, 600);\n\n-- Query parent sees all children\nSELECT * FROM vehicles;  -- includes cars and motorcycles\n\n-- Query only parent (ONLY keyword)\nSELECT * FROM ONLY vehicles;\n\n-- Check which table row comes from\nSELECT tableoid::regclass, * FROM vehicles;\n\n-- Note: Constraints not inherited automatically\n-- Use partitioning instead for most cases",
      "meaning": "Table inheritance ใน PostgreSQL คืออะไร?",
      "example": "Table inheritance allows child tables to inherit columns from parent. Queries on parent automatically include children. Use ONLY to query parent exclusively. tableoid shows source table. Constraints, indexes, foreign keys don't inherit automatically. Modern PostgreSQL: prefer partitioning for data organization, inheritance for specialized cases.",
      "exampleTranslation": "Table inheritance อนุญาตให้ child tables inherit columns จาก parent Queries บน parent รวม children อัตโนมัติ ใช้ ONLY เพื่อ query parent เท่านั้น tableoid แสดง source table Constraints, indexes, foreign keys ไม่ inherit อัตโนมัติ PostgreSQL สมัยใหม่: ใช้ partitioning สำหรับ data organization ใช้ inheritance สำหรับ cases พิเศษ"
    }
  ]
}
