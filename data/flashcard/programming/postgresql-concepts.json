{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "PostgreSQL Concepts",
    "description": "Core PostgreSQL concepts including SQL, indexes, transactions, performance tuning, and advanced features",
    "category": "Database",
    "tags": [
      "postgresql",
      "sql",
      "database",
      "concepts"
    ],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What are the main PostgreSQL data types?",
      "pronunciation": "-- Numeric\nINTEGER, BIGINT, SMALLINT\nNUMERIC(precision, scale), DECIMAL",
      "meaning": "PostgreSQL มี data types หลักอะไรบ้าง?",
      "example": "PostgreSQL has rich data types: Numeric (INTEGER, BIGINT, NUMERIC, SERIAL), Character (VARCHAR, TEXT), Date/Time (TIMESTAMP, TIMESTAMPTZ, INTERVAL), Boolean, Binary (BYTEA), JSON/JSONB, Arrays, UUID, and more. Use appropriate types for data integrity and performance. TIMESTAMPTZ stores timezone info.",
      "exampleTranslation": "PostgreSQL มี data types ที่หลากหลาย: Numeric (INTEGER, BIGINT, NUMERIC, SERIAL), Character (VARCHAR, TEXT), Date/Time (TIMESTAMP, TIMESTAMPTZ, INTERVAL), Boolean, Binary (BYTEA), JSON/JSONB, Arrays, UUID และอื่นๆ ใช้ types ที่เหมาะสมเพื่อ data integrity และ performance TIMESTAMPTZ เก็บ timezone info"
    },
    {
      "vocab": "What is the difference between CHAR, VARCHAR, and TEXT?",
      "pronunciation": "-- CHAR(n) - fixed length, padded with spaces\nCREATE TABLE t1 (code CHAR(5));\nINSERT INTO t1 VALUES ('AB');  -- stored as 'AB   '",
      "meaning": "CHAR, VARCHAR และ TEXT ต่างกันอย่างไร?",
      "example": "CHAR(n) is fixed-length, padded with spaces - use for fixed codes like country codes. VARCHAR(n) is variable-length with max limit. TEXT has no length limit. In PostgreSQL, performance is identical for all three - the limit is only for validation. VARCHAR without length is same as TEXT.",
      "exampleTranslation": "CHAR(n) คือ fixed-length เติม spaces - ใช้สำหรับ codes ที่คงที่เช่น country codes VARCHAR(n) คือ variable-length มี max limit TEXT ไม่มี length limit ใน PostgreSQL performance เท่ากันทั้งสาม - limit มีไว้สำหรับ validation เท่านั้น VARCHAR ไม่มี length เหมือนกับ TEXT"
    },
    {
      "vocab": "What is SERIAL vs IDENTITY?",
      "pronunciation": "-- SERIAL (legacy approach)\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,",
      "meaning": "SERIAL และ IDENTITY ต่างกันอย่างไร?",
      "example": "SERIAL is PostgreSQL-specific shorthand that creates a sequence. IDENTITY is SQL standard (PostgreSQL 10+). GENERATED ALWAYS prevents manual ID insertion. GENERATED BY DEFAULT allows manual override. Prefer IDENTITY for new projects as it's SQL standard and more explicit about behavior.",
      "exampleTranslation": "SERIAL เป็น PostgreSQL-specific shorthand ที่สร้าง sequence IDENTITY เป็น SQL standard (PostgreSQL 10+) GENERATED ALWAYS ป้องกัน manual ID insertion GENERATED BY DEFAULT อนุญาตให้ override ด้วยตนเอง ใช้ IDENTITY สำหรับ projects ใหม่เพราะเป็น SQL standard และชัดเจนกว่าเรื่อง behavior"
    },
    {
      "vocab": "What are the types of JOINs in PostgreSQL?",
      "pronunciation": "-- INNER JOIN - matching rows only\nSELECT * FROM orders o\nINNER JOIN customers c ON o.customer_id = c.id;",
      "meaning": "PostgreSQL มี JOINs ประเภทอะไรบ้าง?",
      "example": "INNER JOIN returns only matching rows. LEFT JOIN returns all left table rows plus matches. RIGHT JOIN returns all right rows plus matches. FULL OUTER JOIN returns all rows from both. CROSS JOIN creates cartesian product. LATERAL JOIN allows subquery to reference outer query columns - powerful for top-N per group.",
      "exampleTranslation": "INNER JOIN return เฉพาะ rows ที่ match LEFT JOIN return ทุก rows จาก left table บวก matches RIGHT JOIN return ทุก rows จาก right บวก matches FULL OUTER JOIN return ทุก rows จากทั้งสอง CROSS JOIN สร้าง cartesian product LATERAL JOIN อนุญาตให้ subquery reference outer query columns - มีพลังสำหรับ top-N per group"
    },
    {
      "vocab": "What is a subquery vs CTE?",
      "pronunciation": "-- Subquery (inline)\nSELECT * FROM orders\nWHERE customer_id IN (",
      "meaning": "Subquery และ CTE ต่างกันอย่างไร?",
      "example": "Subqueries are inline nested queries. CTEs (WITH clause) are named temporary result sets that improve readability and can be referenced multiple times. CTEs can be recursive for hierarchical data (org charts, trees). Performance is usually similar, but CTEs are easier to debug and maintain.",
      "exampleTranslation": "Subqueries คือ inline nested queries CTEs (WITH clause) คือ named temporary result sets ที่ปรับปรุง readability และ reference หลายครั้งได้ CTEs เป็น recursive สำหรับ hierarchical data ได้ (org charts, trees) Performance มักจะใกล้เคียงกัน แต่ CTEs debug และ maintain ง่ายกว่า"
    },
    {
      "vocab": "What are window functions?",
      "pronunciation": "-- ROW_NUMBER - unique row number\nSELECT name, department,\n  ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank",
      "meaning": "Window functions คืออะไร?",
      "example": "Window functions perform calculations across related rows without collapsing them. OVER() defines the window. PARTITION BY groups rows, ORDER BY sorts within partition. Common functions: ROW_NUMBER, RANK, DENSE_RANK, SUM, AVG, LAG, LEAD, FIRST_VALUE, LAST_VALUE. Frame clause (ROWS BETWEEN) controls which rows to include.",
      "exampleTranslation": "Window functions ทำ calculations ข้าม rows ที่เกี่ยวข้องโดยไม่ collapse มัน OVER() กำหนด window PARTITION BY groups rows, ORDER BY sort ภายใน partition Functions ที่ใช้บ่อย: ROW_NUMBER, RANK, DENSE_RANK, SUM, AVG, LAG, LEAD, FIRST_VALUE, LAST_VALUE Frame clause (ROWS BETWEEN) ควบคุมว่าจะรวม rows ไหน"
    },
    {
      "vocab": "What are the types of indexes in PostgreSQL?",
      "pronunciation": "-- B-tree (default) - equality and range\nCREATE INDEX idx_name ON users (name);\nCREATE INDEX idx_date ON orders (created_at DESC);",
      "meaning": "PostgreSQL มี indexes ประเภทอะไรบ้าง?",
      "example": "B-tree (default) for equality and range queries. Hash for equality only. GiST for geometric and range types. GIN for arrays, JSONB, full-text search. BRIN for large naturally-ordered tables (very small). Partial indexes cover subset of rows. Expression indexes index computed values. Choose based on query patterns.",
      "exampleTranslation": "B-tree (default) สำหรับ equality และ range queries Hash สำหรับ equality อย่างเดียว GiST สำหรับ geometric และ range types GIN สำหรับ arrays, JSONB, full-text search BRIN สำหรับ tables ใหญ่ที่เรียงตามธรรมชาติ (เล็กมาก) Partial indexes ครอบคลุม subset ของ rows Expression indexes index computed values เลือกตาม query patterns"
    },
    {
      "vocab": "What is EXPLAIN and EXPLAIN ANALYZE?",
      "pronunciation": "-- EXPLAIN - show query plan (no execution)\nEXPLAIN SELECT * FROM users WHERE email = 'test@example.com';\n-- EXPLAIN ANALYZE - execute and show actual times",
      "meaning": "EXPLAIN และ EXPLAIN ANALYZE คืออะไร?",
      "example": "EXPLAIN shows the query execution plan without running the query. EXPLAIN ANALYZE actually executes and shows real timings and row counts. Use BUFFERS to see I/O stats. Look for: Seq Scan (missing index), high cost estimates, large row differences between estimated and actual. Essential for query optimization.",
      "exampleTranslation": "EXPLAIN แสดง query execution plan โดยไม่รัน query EXPLAIN ANALYZE execute จริงและแสดง timings และ row counts จริง ใช้ BUFFERS เพื่อดู I/O stats ดู: Seq Scan (ไม่มี index), cost estimates สูง, row differences ใหญ่ระหว่าง estimated กับ actual จำเป็นสำหรับ query optimization"
    },
    {
      "vocab": "What is a transaction and ACID properties?",
      "pronunciation": "-- Transaction basics\nBEGIN;\n  UPDATE accounts SET balance = balance - 100 WHERE id = 1;",
      "meaning": "Transaction และ ACID properties คืออะไร?",
      "example": "Transaction groups operations that must succeed or fail together. ACID: Atomicity (all or nothing), Consistency (database remains valid), Isolation (concurrent transactions isolated), Durability (committed data persists). Use BEGIN/COMMIT/ROLLBACK. Savepoints allow partial rollback within transaction.",
      "exampleTranslation": "Transaction รวม operations ที่ต้องสำเร็จหรือล้มเหลวพร้อมกัน ACID: Atomicity (ทั้งหมดหรือไม่มี), Consistency (database ยังคง valid), Isolation (concurrent transactions แยกกัน), Durability (committed data คงอยู่) ใช้ BEGIN/COMMIT/ROLLBACK Savepoints อนุญาตให้ partial rollback ภายใน transaction"
    },
    {
      "vocab": "What are isolation levels in PostgreSQL?",
      "pronunciation": "-- Set isolation level\nBEGIN ISOLATION LEVEL READ COMMITTED;\nBEGIN ISOLATION LEVEL REPEATABLE READ;",
      "meaning": "Isolation levels ใน PostgreSQL มีอะไรบ้าง?",
      "example": "READ COMMITTED (default): sees other transactions' commits between statements. REPEATABLE READ: snapshot at transaction start, prevents non-repeatable reads. SERIALIZABLE: strictest, transactions appear sequential, may throw serialization errors. Higher isolation = more correctness but less concurrency and more conflicts.",
      "exampleTranslation": "READ COMMITTED (default): เห็น commits ของ transactions อื่นระหว่าง statements REPEATABLE READ: snapshot ตอนเริ่ม transaction ป้องกัน non-repeatable reads SERIALIZABLE: เข้มงวดที่สุด transactions ดูเหมือนเป็น sequential อาจ throw serialization errors Isolation สูงกว่า = ถูกต้องกว่าแต่ concurrency น้อยกว่าและ conflicts มากกว่า"
    },
    {
      "vocab": "What is SELECT FOR UPDATE?",
      "pronunciation": "-- Lock rows for update\nBEGIN;\nSELECT * FROM accounts WHERE id = 1 FOR UPDATE;",
      "meaning": "SELECT FOR UPDATE คืออะไร?",
      "example": "SELECT FOR UPDATE locks selected rows until transaction ends, preventing other transactions from modifying them. Prevents lost updates and race conditions. FOR SHARE allows concurrent reads. NOWAIT fails immediately if locked. SKIP LOCKED skips locked rows (good for job queues). Essential for inventory and balance operations.",
      "exampleTranslation": "SELECT FOR UPDATE lock rows ที่เลือกจนกว่า transaction จะจบ ป้องกัน transactions อื่นจากการแก้ไข ป้องกัน lost updates และ race conditions FOR SHARE อนุญาตให้อ่านพร้อมกัน NOWAIT fail ทันทีถ้า locked SKIP LOCKED ข้าม locked rows (ดีสำหรับ job queues) จำเป็นสำหรับ inventory และ balance operations"
    },
    {
      "vocab": "What are constraints in PostgreSQL?",
      "pronunciation": "-- PRIMARY KEY\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY",
      "meaning": "Constraints ใน PostgreSQL มีอะไรบ้าง?",
      "example": "PRIMARY KEY: unique, not null identifier. UNIQUE: no duplicates (allows one null). NOT NULL: required value. FOREIGN KEY: references another table with ON DELETE/UPDATE actions. CHECK: custom validation. EXCLUDE: prevents overlapping values (useful for scheduling). Constraints ensure data integrity at database level.",
      "exampleTranslation": "PRIMARY KEY: unique, not null identifier UNIQUE: ไม่มี duplicates (อนุญาต null หนึ่งตัว) NOT NULL: ต้องมีค่า FOREIGN KEY: references table อื่นพร้อม ON DELETE/UPDATE actions CHECK: custom validation EXCLUDE: ป้องกัน overlapping values (มีประโยชน์สำหรับ scheduling) Constraints รับประกัน data integrity ที่ database level"
    },
    {
      "vocab": "What is ON DELETE CASCADE vs RESTRICT vs SET NULL?",
      "pronunciation": "-- CASCADE - delete child rows too\nCREATE TABLE orders (\n  customer_id INTEGER REFERENCES customers(id) ON DELETE CASCADE",
      "meaning": "ON DELETE CASCADE vs RESTRICT vs SET NULL ต่างกันอย่างไร?",
      "example": "CASCADE: automatically delete child rows when parent is deleted. RESTRICT: prevent parent deletion if children exist. SET NULL: set foreign key to null. SET DEFAULT: set to default value. NO ACTION: like RESTRICT but can be deferred. Choose based on business logic - CASCADE for true dependencies, RESTRICT for safety.",
      "exampleTranslation": "CASCADE: ลบ child rows อัตโนมัติเมื่อ parent ถูกลบ RESTRICT: ป้องกันการลบ parent ถ้ามี children SET NULL: set foreign key เป็น null SET DEFAULT: set เป็น default value NO ACTION: เหมือน RESTRICT แต่ defer ได้ เลือกตาม business logic - CASCADE สำหรับ dependencies จริง RESTRICT สำหรับ safety"
    },
    {
      "vocab": "What is a view vs materialized view?",
      "pronunciation": "-- Regular view (virtual table)\nCREATE VIEW active_users AS\nSELECT * FROM users WHERE active = true;",
      "meaning": "View vs materialized view ต่างกันอย่างไร?",
      "example": "Regular views are virtual - query executes each time, always current data. Materialized views store results physically - faster reads but stale data until refreshed. Use REFRESH to update. CONCURRENTLY allows reads during refresh (requires unique index). Use materialized views for expensive queries accessed frequently.",
      "exampleTranslation": "Regular views เป็น virtual - query execute ทุกครั้ง ข้อมูลปัจจุบันเสมอ Materialized views เก็บผลลัพธ์เป็น physical - อ่านเร็วกว่าแต่ data ค้างจนกว่า refresh ใช้ REFRESH เพื่ออัพเดท CONCURRENTLY อนุญาตให้อ่านระหว่าง refresh (ต้องมี unique index) ใช้ materialized views สำหรับ expensive queries ที่เข้าถึงบ่อย"
    },
    {
      "vocab": "What are stored procedures vs functions?",
      "pronunciation": "-- Function (returns value)\nCREATE FUNCTION get_user_count() \nRETURNS INTEGER AS $$",
      "meaning": "Stored procedures และ functions ต่างกันอย่างไร?",
      "example": "Functions return a value and can be used in SELECT. Procedures (PostgreSQL 11+) don't return values and can control transactions (COMMIT/ROLLBACK within). Use functions for calculations and queries, procedures for multi-step operations with transaction control. Both use PL/pgSQL language.",
      "exampleTranslation": "Functions return ค่าและใช้ใน SELECT ได้ Procedures (PostgreSQL 11+) ไม่ return ค่าและควบคุม transactions ได้ (COMMIT/ROLLBACK ภายใน) ใช้ functions สำหรับ calculations และ queries ใช้ procedures สำหรับ multi-step operations ที่มี transaction control ทั้งคู่ใช้ PL/pgSQL language"
    },
    {
      "vocab": "What is a trigger?",
      "pronunciation": "-- Trigger function\nCREATE FUNCTION update_modified() RETURNS TRIGGER AS $$\nBEGIN",
      "meaning": "Trigger คืออะไร?",
      "example": "Triggers automatically execute functions when table events occur (INSERT, UPDATE, DELETE). BEFORE triggers can modify data or cancel operations. AFTER triggers for side effects like logging. FOR EACH ROW executes per row, FOR EACH STATEMENT once per query. Common uses: audit logs, timestamps, validation, cascading updates.",
      "exampleTranslation": "Triggers execute functions อัตโนมัติเมื่อเกิด table events (INSERT, UPDATE, DELETE) BEFORE triggers แก้ไข data หรือยกเลิก operations ได้ AFTER triggers สำหรับ side effects เช่น logging FOR EACH ROW execute ต่อ row, FOR EACH STATEMENT ครั้งเดียวต่อ query ใช้บ่อย: audit logs, timestamps, validation, cascading updates"
    },
    {
      "vocab": "What is JSONB in PostgreSQL?",
      "pronunciation": "-- Create table with JSONB\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,",
      "meaning": "JSONB ใน PostgreSQL คืออะไร?",
      "example": "JSONB stores JSON in binary format - faster to process than JSON (text). Use -> for JSONB result, ->> for text, #>> for path. Operators: @> (contains), ? (has key), ?| (has any key), ?& (has all keys). GIN index for fast JSON queries. Best for semi-structured data, API responses, flexible schemas.",
      "exampleTranslation": "JSONB เก็บ JSON ในรูป binary - process เร็วกว่า JSON (text) ใช้ -> สำหรับผลลัพธ์ JSONB, ->> สำหรับ text, #>> สำหรับ path Operators: @> (contains), ? (has key), ?| (has any key), ?& (has all keys) GIN index สำหรับ JSON queries เร็ว ดีที่สุดสำหรับ semi-structured data, API responses, flexible schemas"
    },
    {
      "vocab": "What is full-text search in PostgreSQL?",
      "pronunciation": "-- Create tsvector column\nALTER TABLE articles ADD COLUMN search_vector TSVECTOR;\nUPDATE articles SET search_vector = ",
      "meaning": "Full-text search ใน PostgreSQL คืออะไร?",
      "example": "PostgreSQL has built-in full-text search. tsvector stores searchable tokens, tsquery defines search terms. Operators: & (AND), | (OR), ! (NOT), <-> (followed by). GIN index for fast search. ts_rank for relevance ranking. Supports stemming, stop words, multiple languages. Good for moderate search needs without external tools.",
      "exampleTranslation": "PostgreSQL มี built-in full-text search tsvector เก็บ searchable tokens, tsquery กำหนด search terms Operators: & (AND), | (OR), ! (NOT), <-> (followed by) GIN index สำหรับ search เร็ว ts_rank สำหรับ relevance ranking รองรับ stemming, stop words, หลายภาษา ดีสำหรับ search needs ปานกลางโดยไม่ต้องใช้ external tools"
    },
    {
      "vocab": "What is table partitioning?",
      "pronunciation": "-- Range partitioning by date\nCREATE TABLE orders (\n  id SERIAL,",
      "meaning": "Table partitioning คืออะไร?",
      "example": "Partitioning splits large tables into smaller physical tables. Range partitioning by date/number ranges. List partitioning by specific values. Hash partitioning for even distribution. Benefits: faster queries on partition key, easier maintenance (drop old partitions), parallel query execution. Use for tables with millions of rows.",
      "exampleTranslation": "Partitioning แบ่ง tables ใหญ่เป็น physical tables เล็กกว่า Range partitioning ตาม date/number ranges List partitioning ตาม specific values Hash partitioning สำหรับการกระจายที่สม่ำเสมอ ประโยชน์: queries เร็วขึ้นบน partition key, maintenance ง่ายขึ้น (drop old partitions), parallel query execution ใช้สำหรับ tables ที่มีหลายล้าน rows"
    },
    {
      "vocab": "What is VACUUM and ANALYZE?",
      "pronunciation": "-- VACUUM - reclaim dead tuple space\nVACUUM users;              -- basic vacuum\nVACUUM FULL users;         -- rewrite table, reclaims more space",
      "meaning": "VACUUM และ ANALYZE คืออะไร?",
      "example": "VACUUM reclaims space from deleted/updated rows (dead tuples). PostgreSQL uses MVCC, so old versions aren't immediately removed. VACUUM FULL rewrites the entire table (locks it). ANALYZE updates statistics for the query planner. Autovacuum runs automatically but may need tuning for busy tables.",
      "exampleTranslation": "VACUUM reclaim space จาก deleted/updated rows (dead tuples) PostgreSQL ใช้ MVCC ดังนั้น old versions ไม่ถูกลบทันที VACUUM FULL rewrite ทั้ง table (lock มัน) ANALYZE อัพเดท statistics สำหรับ query planner Autovacuum ทำงานอัตโนมัติแต่อาจต้อง tune สำหรับ busy tables"
    },
    {
      "vocab": "What is the difference between DELETE, TRUNCATE, and DROP?",
      "pronunciation": "-- DELETE - remove rows, logged, can rollback\nDELETE FROM users;              -- all rows\nDELETE FROM users WHERE id = 1; -- specific rows",
      "meaning": "DELETE, TRUNCATE และ DROP ต่างกันอย่างไร?",
      "example": "DELETE removes rows one by one, fires triggers, supports WHERE, slow for many rows. TRUNCATE instantly removes all rows, no triggers, resets sequences, much faster. DROP removes the entire table including structure, indexes, and constraints. Use DELETE for specific rows, TRUNCATE to empty table, DROP to remove table.",
      "exampleTranslation": "DELETE ลบ rows ทีละตัว fire triggers รองรับ WHERE ช้าสำหรับหลาย rows TRUNCATE ลบทุก rows ทันที ไม่มี triggers reset sequences เร็วกว่ามาก DROP ลบทั้ง table รวมทั้ง structure, indexes และ constraints ใช้ DELETE สำหรับ specific rows, TRUNCATE เพื่อ empty table, DROP เพื่อลบ table"
    },
    {
      "vocab": "What is UPSERT (INSERT ON CONFLICT)?",
      "pronunciation": "-- Insert or update on conflict\nINSERT INTO users (email, name)\nVALUES ('john@example.com', 'John')",
      "meaning": "UPSERT (INSERT ON CONFLICT) คืออะไร?",
      "example": "UPSERT combines INSERT and UPDATE in one atomic operation. ON CONFLICT specifies which constraint triggers the update. DO UPDATE uses EXCLUDED to reference the would-be inserted values. DO NOTHING ignores conflicts. Can add WHERE for conditional updates. Essential for sync operations and idempotent inserts.",
      "exampleTranslation": "UPSERT รวม INSERT และ UPDATE ในหนึ่ง atomic operation ON CONFLICT ระบุ constraint ไหนที่ trigger update DO UPDATE ใช้ EXCLUDED เพื่อ reference ค่าที่จะ insert DO NOTHING ignore conflicts เพิ่ม WHERE สำหรับ conditional updates ได้ จำเป็นสำหรับ sync operations และ idempotent inserts"
    },
    {
      "vocab": "What is RETURNING clause?",
      "pronunciation": "-- Return inserted row\nINSERT INTO users (name, email)\nVALUES ('John', 'john@example.com')",
      "meaning": "RETURNING clause คืออะไร?",
      "example": "RETURNING returns data from modified rows in INSERT, UPDATE, DELETE. Returns any columns including generated values (id, timestamps). Can be used with CTEs for complex multi-table operations. Eliminates need for separate SELECT after modification. Very useful for getting auto-generated IDs.",
      "exampleTranslation": "RETURNING return ข้อมูลจาก modified rows ใน INSERT, UPDATE, DELETE Return columns ใดก็ได้รวมทั้ง generated values (id, timestamps) ใช้กับ CTEs สำหรับ complex multi-table operations ได้ ไม่ต้อง SELECT แยกหลัง modification มีประโยชน์มากสำหรับการดึง auto-generated IDs"
    },
    {
      "vocab": "What is a lateral join?",
      "pronunciation": "-- Get top 3 orders per customer\nSELECT c.name, o.id, o.amount\nFROM customers c",
      "meaning": "Lateral join คืออะไร?",
      "example": "LATERAL allows a subquery to reference columns from preceding tables in the FROM clause. Essential for top-N per group queries, correlated subqueries in FROM, and set-returning functions. The subquery runs once per row from the outer table. More flexible than regular subqueries or window functions for some patterns.",
      "exampleTranslation": "LATERAL อนุญาตให้ subquery reference columns จาก tables ก่อนหน้าใน FROM clause จำเป็นสำหรับ top-N per group queries, correlated subqueries ใน FROM และ set-returning functions Subquery รันหนึ่งครั้งต่อ row จาก outer table ยืดหยุ่นกว่า regular subqueries หรือ window functions สำหรับบาง patterns"
    },
    {
      "vocab": "What is connection pooling (PgBouncer)?",
      "pronunciation": "-- Why pooling?\n-- PostgreSQL creates process per connection (expensive)\n-- Without pooling: 100 users = 100 connections = 100 processes",
      "meaning": "Connection pooling (PgBouncer) คืออะไร?",
      "example": "PostgreSQL creates heavyweight process per connection. PgBouncer pools connections, allowing many clients to share fewer database connections. Transaction mode (recommended) assigns connection per transaction. Reduces database load, enables more concurrent users. Essential for production with many short-lived connections.",
      "exampleTranslation": "PostgreSQL สร้าง heavyweight process ต่อ connection PgBouncer pool connections อนุญาตให้หลาย clients แชร์ database connections น้อยลง Transaction mode (แนะนำ) assign connection ต่อ transaction ลด database load รองรับ concurrent users มากขึ้น จำเป็นสำหรับ production ที่มี short-lived connections มาก"
    },
    {
      "vocab": "What is COPY command?",
      "pronunciation": "-- Export to CSV\nCOPY users TO '/tmp/users.csv' WITH (FORMAT CSV, HEADER);\n-- Export query result",
      "meaning": "COPY command คืออะไร?",
      "example": "COPY is PostgreSQL's fastest way to bulk import/export data. Server-side COPY requires superuser and file on server. \\copy in psql works client-side without superuser. Supports CSV, text formats. 10-100x faster than INSERT for bulk loading. Essential for data migration, ETL, and backups.",
      "exampleTranslation": "COPY เป็นวิธีที่เร็วที่สุดของ PostgreSQL ในการ bulk import/export data Server-side COPY ต้อง superuser และ file บน server \\copy ใน psql ทำงาน client-side ไม่ต้อง superuser รองรับ CSV, text formats เร็วกว่า INSERT 10-100 เท่าสำหรับ bulk loading จำเป็นสำหรับ data migration, ETL และ backups"
    },
    {
      "vocab": "What is pg_dump and pg_restore?",
      "pronunciation": "-- Dump entire database (SQL format)\npg_dump mydb > backup.sql\n-- Dump with custom format (compressed, parallel restore)",
      "meaning": "pg_dump และ pg_restore คืออะไร?",
      "example": "pg_dump exports database to file. SQL format is human-readable. Custom format (-Fc) is compressed and supports parallel restore. pg_restore imports custom format dumps. Use -j for parallel restore. Can dump specific tables, schema-only, or data-only. pg_dumpall exports all databases including roles.",
      "exampleTranslation": "pg_dump export database เป็นไฟล์ SQL format อ่านได้ง่าย Custom format (-Fc) บีบอัดและรองรับ parallel restore pg_restore import custom format dumps ใช้ -j สำหรับ parallel restore Dump specific tables, schema-only หรือ data-only ได้ pg_dumpall export ทุก databases รวมทั้ง roles"
    },
    {
      "vocab": "What is logical replication?",
      "pronunciation": "-- On publisher (source)\nCREATE PUBLICATION my_pub FOR ALL TABLES;\n-- Or specific tables",
      "meaning": "Logical replication คืออะไร?",
      "example": "Logical replication copies data changes at row level between databases. Publisher sends changes, subscriber applies them. Can replicate specific tables, works across PostgreSQL versions. Subscriber can have additional indexes and local tables. Use for selective replication, data integration, and version upgrades.",
      "exampleTranslation": "Logical replication copy data changes ที่ row level ระหว่าง databases Publisher ส่ง changes, subscriber apply มัน Replicate specific tables ได้ ทำงานข้าม PostgreSQL versions Subscriber มี indexes เพิ่มเติมและ local tables ได้ ใช้สำหรับ selective replication, data integration และ version upgrades"
    },
    {
      "vocab": "What is COALESCE and NULLIF?",
      "pronunciation": "-- COALESCE - first non-null value\nSELECT COALESCE(nickname, first_name, 'Unknown') as display_name\nFROM users;",
      "meaning": "COALESCE และ NULLIF คืออะไร?",
      "example": "COALESCE returns the first non-null argument. Use for default values and handling NULL in calculations. NULLIF returns NULL if two arguments are equal, otherwise the first argument. Use to avoid division by zero. GREATEST/LEAST return max/min of arguments. Essential for NULL-safe queries.",
      "exampleTranslation": "COALESCE return argument แรกที่ไม่ใช่ null ใช้สำหรับ default values และจัดการ NULL ใน calculations NULLIF return NULL ถ้าสอง arguments เท่ากัน ไม่งั้น return argument แรก ใช้เพื่อหลีกเลี่ยง division by zero GREATEST/LEAST return max/min ของ arguments จำเป็นสำหรับ NULL-safe queries"
    },
    {
      "vocab": "What is CASE expression?",
      "pronunciation": "-- Simple CASE\nSELECT name,\n  CASE status",
      "meaning": "CASE expression คืออะไร?",
      "example": "CASE provides conditional logic in SQL. Simple CASE compares against specific values. Searched CASE evaluates boolean conditions. Can be used in SELECT, WHERE, ORDER BY, and with aggregations. FILTER clause (PostgreSQL) is cleaner for conditional aggregation. Returns NULL if no condition matches and no ELSE.",
      "exampleTranslation": "CASE ให้ conditional logic ใน SQL Simple CASE เปรียบเทียบกับค่าเฉพาะ Searched CASE evaluate boolean conditions ใช้ใน SELECT, WHERE, ORDER BY และกับ aggregations ได้ FILTER clause (PostgreSQL) สะอาดกว่าสำหรับ conditional aggregation Return NULL ถ้าไม่มี condition ตรงและไม่มี ELSE"
    },
    {
      "vocab": "What are aggregate functions with FILTER?",
      "pronunciation": "-- Traditional conditional aggregation\nSELECT \n  SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) as paid_total,",
      "meaning": "Aggregate functions กับ FILTER คืออะไร?",
      "example": "FILTER clause (PostgreSQL 9.4+) applies conditions to aggregate functions. Cleaner than CASE WHEN inside aggregates. Works with COUNT, SUM, AVG, and other aggregates. Can combine with GROUP BY and window functions. More readable and sometimes faster than CASE approach.",
      "exampleTranslation": "FILTER clause (PostgreSQL 9.4+) apply conditions กับ aggregate functions สะอาดกว่า CASE WHEN ภายใน aggregates ทำงานกับ COUNT, SUM, AVG และ aggregates อื่นๆ รวมกับ GROUP BY และ window functions ได้ อ่านง่ายกว่าและบางทีเร็วกว่า CASE approach"
    },
    {
      "vocab": "What is array type in PostgreSQL?",
      "pronunciation": "-- Create table with array\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,",
      "meaning": "Array type ใน PostgreSQL คืออะไร?",
      "example": "PostgreSQL supports native array types for any data type. Use ANY for element membership, @> for contains, && for overlap. Array functions: length, append, cat, unnest. Arrays are 1-indexed. GIN index for fast array queries. Good for tags, categories, or denormalized data. Consider JSONB for more complex structures.",
      "exampleTranslation": "PostgreSQL รองรับ native array types สำหรับ data type ใดก็ได้ ใช้ ANY สำหรับ element membership, @> สำหรับ contains, && สำหรับ overlap Array functions: length, append, cat, unnest Arrays เป็น 1-indexed GIN index สำหรับ fast array queries ดีสำหรับ tags, categories หรือ denormalized data พิจารณา JSONB สำหรับ structures ที่ซับซ้อนกว่า"
    },
    {
      "vocab": "What is DISTINCT ON?",
      "pronunciation": "-- Get first row per group (PostgreSQL-specific)\nSELECT DISTINCT ON (customer_id)\n  customer_id, id as order_id, created_at, amount",
      "meaning": "DISTINCT ON คืออะไร?",
      "example": "DISTINCT ON returns first row for each unique combination of specified columns. Must ORDER BY the DISTINCT ON columns first, then your preferred ordering. PostgreSQL-specific, very efficient for \"first/latest per group\" queries. Alternative to window functions with ROW_NUMBER() = 1. ORDER BY required.",
      "exampleTranslation": "DISTINCT ON return row แรกสำหรับแต่ละ unique combination ของ columns ที่ระบุ ต้อง ORDER BY DISTINCT ON columns ก่อน แล้วค่อย ordering ที่ต้องการ PostgreSQL-specific มีประสิทธิภาพมากสำหรับ \"first/latest per group\" queries ทางเลือกแทน window functions กับ ROW_NUMBER() = 1 ต้องมี ORDER BY"
    },
    {
      "vocab": "What is the difference between COUNT(*) vs COUNT(column) vs COUNT(DISTINCT)?",
      "pronunciation": "-- COUNT(*) - counts all rows including NULLs\nSELECT COUNT(*) FROM users;  -- 100 rows\n-- COUNT(column) - counts non-NULL values",
      "meaning": "COUNT(*) vs COUNT(column) vs COUNT(DISTINCT) ต่างกันอย่างไร?",
      "example": "COUNT(*) counts all rows regardless of NULL values - fastest. COUNT(column) counts only non-NULL values in that column. COUNT(DISTINCT column) counts unique non-NULL values. DISTINCT can be used with other aggregates too. COUNT(*) is optimized in PostgreSQL and preferred when counting rows.",
      "exampleTranslation": "COUNT(*) นับทุก rows ไม่ว่าจะมี NULL values - เร็วที่สุด COUNT(column) นับเฉพาะ non-NULL values ใน column นั้น COUNT(DISTINCT column) นับ unique non-NULL values DISTINCT ใช้กับ aggregates อื่นได้เช่นกัน COUNT(*) ถูก optimize ใน PostgreSQL และใช้บ่อยเมื่อนับ rows"
    },
    {
      "vocab": "What is GROUPING SETS, CUBE, and ROLLUP?",
      "pronunciation": "-- GROUPING SETS - multiple groupings in one query\nSELECT region, product, SUM(sales)\nFROM sales_data",
      "meaning": "GROUPING SETS, CUBE และ ROLLUP คืออะไร?",
      "example": "GROUPING SETS creates multiple groupings in single query - like multiple GROUP BY combined. ROLLUP creates hierarchical subtotals (year -> quarter -> month -> total). CUBE creates all possible combinations of groupings. GROUPING() function identifies which level produced the row. Essential for reporting and data analysis.",
      "exampleTranslation": "GROUPING SETS สร้างหลาย groupings ใน query เดียว เหมือนหลาย GROUP BY รวมกัน ROLLUP สร้าง hierarchical subtotals (year -> quarter -> month -> total) CUBE สร้างทุก combinations ของ groupings ที่เป็นไปได้ GROUPING() function ระบุว่า level ไหนสร้าง row จำเป็นสำหรับ reporting และ data analysis"
    },
    {
      "vocab": "What is CTid in PostgreSQL?",
      "pronunciation": "-- ctid is physical row location (page, offset)\nSELECT ctid, * FROM users LIMIT 5;\n-- ctid: (0,1), (0,2), (0,3)... (page 0, rows 1,2,3)",
      "meaning": "CTid ใน PostgreSQL คืออะไร?",
      "example": "ctid is a system column showing physical row location (page number, row offset). Used for identifying and removing duplicate rows without unique key. Caution: ctid changes after VACUUM or updates. Only use for immediate operations like deduplication, not for persistent references.",
      "exampleTranslation": "ctid เป็น system column ที่แสดง physical row location (page number, row offset) ใช้สำหรับ identify และลบ duplicate rows โดยไม่มี unique key ข้อควรระวัง: ctid เปลี่ยนหลัง VACUUM หรือ updates ใช้สำหรับ operations ทันทีเช่น deduplication เท่านั้น ไม่ใช่ persistent references"
    },
    {
      "vocab": "What is the difference between UNION and UNION ALL?",
      "pronunciation": "-- UNION - combines and removes duplicates\nSELECT name FROM customers\nUNION",
      "meaning": "UNION และ UNION ALL ต่างกันอย่างไร?",
      "example": "UNION combines results and removes duplicates (slower, requires sort). UNION ALL keeps all rows including duplicates (faster). Always prefer UNION ALL when duplicates are acceptable or impossible. INTERSECT returns common rows. EXCEPT returns rows in first query not in second. All require matching column counts and compatible types.",
      "exampleTranslation": "UNION รวมผลลัพธ์และลบ duplicates (ช้ากว่า ต้อง sort) UNION ALL เก็บทุก rows รวมทั้ง duplicates (เร็วกว่า) ใช้ UNION ALL เสมอเมื่อ duplicates ยอมรับได้หรือเป็นไปไม่ได้ INTERSECT return rows ที่มีเหมือนกัน EXCEPT return rows ใน query แรกที่ไม่มีใน query ที่สอง ทั้งหมดต้อง matching column counts และ compatible types"
    },
    {
      "vocab": "What is advisory lock?",
      "pronunciation": "-- Session-level advisory lock\nSELECT pg_advisory_lock(123);  -- acquire lock with key 123\n-- Do work...",
      "meaning": "Advisory lock คืออะไร?",
      "example": "Advisory locks are application-defined locks not tied to any table or row. Use for coordinating processes, preventing concurrent job execution, or custom locking logic. Session-level locks persist until released or disconnected. Transaction-level auto-release. Non-blocking version with try_advisory_lock. Identified by integer key(s).",
      "exampleTranslation": "Advisory locks คือ application-defined locks ที่ไม่ผูกกับ table หรือ row ใดๆ ใช้สำหรับ coordinating processes ป้องกัน concurrent job execution หรือ custom locking logic Session-level locks คงอยู่จนกว่าจะ release หรือ disconnect Transaction-level auto-release Non-blocking version ด้วย try_advisory_lock ระบุด้วย integer key(s)"
    },
    {
      "vocab": "What is table inheritance in PostgreSQL?",
      "pronunciation": "-- Parent table\nCREATE TABLE vehicles (\n  id SERIAL PRIMARY KEY,",
      "meaning": "Table inheritance ใน PostgreSQL คืออะไร?",
      "example": "Table inheritance allows child tables to inherit columns from parent. Queries on parent automatically include children. Use ONLY to query parent exclusively. tableoid shows source table. Constraints, indexes, foreign keys don't inherit automatically. Modern PostgreSQL: prefer partitioning for data organization, inheritance for specialized cases.",
      "exampleTranslation": "Table inheritance อนุญาตให้ child tables inherit columns จาก parent Queries บน parent รวม children อัตโนมัติ ใช้ ONLY เพื่อ query parent เท่านั้น tableoid แสดง source table Constraints, indexes, foreign keys ไม่ inherit อัตโนมัติ PostgreSQL สมัยใหม่: ใช้ partitioning สำหรับ data organization ใช้ inheritance สำหรับ cases พิเศษ"
    }
  ]
}