{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "JavaScript Concepts",
    "description": "Core JavaScript concepts including types, functions, closures, async patterns, prototypes, and ES6+ features",
    "category": "Programming",
    "tags": ["javascript", "js", "web", "concepts"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What are the primitive data types in JavaScript?",
      "pronunciation": "// 7 Primitive types\nlet str = \"hello\";        // string\nlet num = 42;             // number\nlet big = 9007199254740991n;  // bigint\nlet bool = true;          // boolean\nlet undef = undefined;    // undefined\nlet nul = null;           // null\nlet sym = Symbol(\"id\");   // symbol\n\n// Check type\ntypeof str      // \"string\"\ntypeof num      // \"number\"\ntypeof bool     // \"boolean\"\ntypeof undef    // \"undefined\"\ntypeof nul      // \"object\" (historical bug!)\ntypeof sym      // \"symbol\"\n\n// Primitives are immutable\nlet s = \"hello\";\ns[0] = \"H\";  // doesn't work\ns.toUpperCase();  // returns new string",
      "meaning": "JavaScript มี primitive data types อะไรบ้าง?",
      "example": "7 primitives: string, number, bigint, boolean, undefined, null, symbol. Primitives are immutable and passed by value. typeof returns type as string. Note: typeof null returns 'object' (historical bug). Everything else is an object (arrays, functions, objects).",
      "exampleTranslation": "7 primitives: string, number, bigint, boolean, undefined, null, symbol Primitives เป็น immutable และ passed by value typeof return type เป็น string หมายเหตุ: typeof null return 'object' (historical bug) ทุกอย่างอื่นเป็น object (arrays, functions, objects)"
    },
    {
      "vocab": "What is the difference between var, let, and const?",
      "pronunciation": "// var: function-scoped, hoisted\nfunction example() {\n  console.log(x);  // undefined (hoisted)\n  var x = 5;\n  var x = 10;      // redeclaration OK\n}\n\n// let: block-scoped, temporal dead zone\n{\n  // console.log(y);  // ReferenceError (TDZ)\n  let y = 5;\n  // let y = 10;      // SyntaxError: can't redeclare\n  y = 10;            // reassignment OK\n}\n\n// const: block-scoped, must initialize, can't reassign\nconst z = 5;\n// z = 10;           // TypeError\n\n// const with objects (reference is constant)\nconst obj = {a: 1};\nobj.a = 2;          // OK, modifying content\nobj.b = 3;          // OK, adding property\n// obj = {};         // TypeError, can't reassign\n\nconst arr = [1, 2];\narr.push(3);        // OK\n// arr = [];         // TypeError",
      "meaning": "var, let และ const ต่างกันอย่างไร?",
      "example": "var: function-scoped, hoisted to undefined, can redeclare. let: block-scoped, temporal dead zone (TDZ), can reassign but not redeclare. const: block-scoped, must initialize, cannot reassign reference. const objects/arrays: reference is constant but contents can be modified. Prefer const, use let when reassignment needed, avoid var.",
      "exampleTranslation": "var: function-scoped, hoisted เป็น undefined, redeclare ได้ let: block-scoped, temporal dead zone (TDZ), reassign ได้แต่ redeclare ไม่ได้ const: block-scoped, ต้อง initialize, reassign reference ไม่ได้ const objects/arrays: reference คงที่แต่ contents แก้ไขได้ ใช้ const เป็นหลัก ใช้ let เมื่อต้อง reassign หลีกเลี่ยง var"
    },
    {
      "vocab": "What is hoisting?",
      "pronunciation": "// Variable hoisting (var)\nconsole.log(x);  // undefined\nvar x = 5;\n\n// Equivalent to:\nvar x;\nconsole.log(x);  // undefined\nx = 5;\n\n// Function declaration hoisting\nsayHello();  // \"Hello!\" - works!\nfunction sayHello() {\n  console.log(\"Hello!\");\n}\n\n// Function expression NOT hoisted\n// sayBye();  // TypeError: sayBye is not a function\nvar sayBye = function() {\n  console.log(\"Bye!\");\n};\n\n// let/const: TDZ (temporal dead zone)\n// console.log(y);  // ReferenceError\nlet y = 10;\n\n// Class declarations NOT hoisted\n// const p = new Person();  // ReferenceError\nclass Person {}",
      "meaning": "Hoisting คืออะไร?",
      "example": "Hoisting moves declarations to top of scope during compilation. var declarations hoisted as undefined. Function declarations fully hoisted (can call before declaration). Function expressions, let, const, classes are NOT hoisted (or have TDZ). TDZ: variable exists but cannot be accessed before declaration. Best practice: declare at top.",
      "exampleTranslation": "Hoisting ย้าย declarations ไปบนสุดของ scope ระหว่าง compilation var declarations ถูก hoist เป็น undefined Function declarations ถูก hoist ทั้งหมด (เรียกก่อน declaration ได้) Function expressions, let, const, classes ไม่ถูก hoist (หรือมี TDZ) TDZ: variable มีอยู่แต่เข้าถึงก่อน declaration ไม่ได้ Best practice: declare ที่ด้านบน"
    },
    {
      "vocab": "What is a closure?",
      "pronunciation": "// Closure: function + its lexical environment\nfunction outer() {\n  let count = 0;  // enclosed variable\n  \n  return function inner() {\n    count++;      // accesses outer's variable\n    return count;\n  };\n}\n\nconst counter = outer();\nconsole.log(counter());  // 1\nconsole.log(counter());  // 2\nconsole.log(counter());  // 3\n\n// Practical: private variables\nfunction createWallet(initial) {\n  let balance = initial;  // private\n  \n  return {\n    deposit(amount) { balance += amount; },\n    withdraw(amount) { balance -= amount; },\n    getBalance() { return balance; }\n  };\n}\n\nconst wallet = createWallet(100);\nwallet.deposit(50);\nconsole.log(wallet.getBalance());  // 150\n// wallet.balance  // undefined (private!)",
      "meaning": "Closure คืออะไร?",
      "example": "Closure is a function bundled with its lexical environment (outer variables). Inner function 'closes over' outer variables and retains access even after outer function returns. Use cases: private variables, factory functions, callbacks, maintaining state. Variables are not copied - same reference is shared.",
      "exampleTranslation": "Closure คือ function ที่รวมกับ lexical environment ของมัน (outer variables) Inner function 'closes over' outer variables และเข้าถึงได้แม้หลัง outer function return แล้ว Use cases: private variables, factory functions, callbacks, maintaining state Variables ไม่ถูก copy - ใช้ reference เดียวกัน"
    },
    {
      "vocab": "What is the event loop?",
      "pronunciation": "// JavaScript is single-threaded with event loop\n\nconsole.log('1');           // sync - call stack\n\nsetTimeout(() => {\n  console.log('2');         // macro task queue\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3');         // micro task queue\n});\n\nconsole.log('4');           // sync - call stack\n\n// Output: 1, 4, 3, 2\n\n// Event loop priority:\n// 1. Call stack (sync code)\n// 2. Microtask queue (promises, queueMicrotask)\n// 3. Macrotask queue (setTimeout, setInterval, I/O)\n\n// Microtasks run between each macrotask\nsetTimeout(() => console.log('timeout'), 0);\nPromise.resolve().then(() => console.log('promise 1'));\nPromise.resolve().then(() => console.log('promise 2'));\n// Output: promise 1, promise 2, timeout",
      "meaning": "Event loop คืออะไร?",
      "example": "Event loop handles async operations in single-threaded JavaScript. Order: 1) Call stack (sync code), 2) Microtask queue (Promises, queueMicrotask), 3) Macrotask queue (setTimeout, I/O). All microtasks run before next macrotask. This is why Promise callbacks run before setTimeout(0).",
      "exampleTranslation": "Event loop จัดการ async operations ใน single-threaded JavaScript ลำดับ: 1) Call stack (sync code), 2) Microtask queue (Promises, queueMicrotask), 3) Macrotask queue (setTimeout, I/O) Microtasks ทั้งหมดรันก่อน macrotask ถัดไป นี่คือเหตุผลที่ Promise callbacks รันก่อน setTimeout(0)"
    },
    {
      "vocab": "What is the 'this' keyword?",
      "pronunciation": "// 'this' depends on HOW function is called\n\n// 1. Global context\nconsole.log(this);  // window (browser) / global (Node)\n\n// 2. Object method\nconst obj = {\n  name: 'John',\n  greet() { console.log(this.name); }  // 'John'\n};\n\n// 3. Function call (non-strict: global, strict: undefined)\nfunction show() { console.log(this); }\nshow();  // window or undefined\n\n// 4. Arrow function (inherits from enclosing scope)\nconst obj2 = {\n  name: 'Jane',\n  greet: () => console.log(this.name),  // undefined!\n  greet2() {\n    const arrow = () => console.log(this.name);  // 'Jane'\n    arrow();\n  }\n};\n\n// 5. Explicit binding\nfunction sayHi() { console.log(this.name); }\nsayHi.call({name: 'A'});    // 'A'\nsayHi.apply({name: 'B'});   // 'B'\nconst bound = sayHi.bind({name: 'C'});\nbound();  // 'C'\n\n// 6. new keyword\nfunction Person(name) { this.name = name; }\nconst p = new Person('Dave');  // this = new object",
      "meaning": "'this' keyword คืออะไร?",
      "example": "'this' is determined by how function is called, not where defined. Global: window/global. Object method: the object. Regular function: global (non-strict) or undefined (strict). Arrow function: inherits from enclosing scope. call/apply/bind: explicit binding. new keyword: new object. Arrow functions don't have own 'this'.",
      "exampleTranslation": "'this' ถูกกำหนดโดยวิธีที่ function ถูกเรียก ไม่ใช่ที่ defined Global: window/global Object method: object นั้น Regular function: global (non-strict) หรือ undefined (strict) Arrow function: สืบทอดจาก enclosing scope call/apply/bind: explicit binding new keyword: object ใหม่ Arrow functions ไม่มี 'this' ของตัวเอง"
    },
    {
      "vocab": "What is the difference between == and ===?",
      "pronunciation": "// == (loose equality): type coercion\n5 == '5'        // true (string converted to number)\n0 == false      // true (false converted to 0)\n'' == false     // true\nnull == undefined  // true\n'1' == true     // true\n\n// === (strict equality): no coercion\n5 === '5'       // false (different types)\n0 === false     // false\nnull === undefined  // false\n\n// Object comparison (reference)\nconst a = {x: 1};\nconst b = {x: 1};\nconst c = a;\n\na == b   // false (different references)\na === b  // false\na === c  // true (same reference)\n\n// NaN is not equal to anything\nNaN == NaN   // false\nNaN === NaN  // false\nNumber.isNaN(NaN)  // true (correct way)\n\n// Object.is() - like === but handles NaN and -0\nObject.is(NaN, NaN)  // true\nObject.is(-0, 0)     // false",
      "meaning": "== และ === ต่างกันอย่างไร?",
      "example": "== (loose equality) performs type coercion before comparing. === (strict equality) compares type and value without coercion. Always prefer === to avoid unexpected coercion bugs. Objects compared by reference, not value. NaN !== NaN, use Number.isNaN(). Object.is() is like === but handles NaN and -0 correctly.",
      "exampleTranslation": "== (loose equality) ทำ type coercion ก่อนเปรียบเทียบ === (strict equality) เปรียบเทียบ type และ value โดยไม่ coerce ใช้ === เสมอเพื่อหลีกเลี่ยง bugs จาก coercion Objects เปรียบเทียบด้วย reference ไม่ใช่ value NaN !== NaN ใช้ Number.isNaN() Object.is() เหมือน === แต่จัดการ NaN และ -0 ถูกต้อง"
    },
    {
      "vocab": "What are truthy and falsy values?",
      "pronunciation": "// Falsy values (8 total)\nif (false) {}      // false\nif (0) {}          // 0\nif (-0) {}         // -0\nif (0n) {}         // 0n (BigInt zero)\nif ('') {}         // empty string\nif (null) {}       // null\nif (undefined) {}  // undefined\nif (NaN) {}        // NaN\n\n// Everything else is truthy\nif ('0') {}        // truthy (non-empty string)\nif ('false') {}    // truthy\nif ([]) {}         // truthy (empty array)\nif ({}) {}         // truthy (empty object)\nif (function(){}) {}  // truthy\nif (-1) {}         // truthy\n\n// Common patterns\nconst name = userInput || 'Default';  // falsy check\nconst name = userInput ?? 'Default';  // null/undefined only\n\n// Boolean conversion\nBoolean('')     // false\n!!''            // false (double negation)\n!!'hello'       // true",
      "meaning": "Truthy และ falsy values คืออะไร?",
      "example": "8 falsy values: false, 0, -0, 0n, '', null, undefined, NaN. Everything else is truthy, including '0', 'false', [], {}, functions. Use || for falsy fallback, ?? (nullish coalescing) for null/undefined only. Convert to boolean with Boolean() or !!. Empty arrays and objects are truthy!",
      "exampleTranslation": "8 falsy values: false, 0, -0, 0n, '', null, undefined, NaN ทุกอย่างอื่นเป็น truthy รวมถึง '0', 'false', [], {}, functions ใช้ || สำหรับ falsy fallback, ?? (nullish coalescing) สำหรับ null/undefined เท่านั้น แปลงเป็น boolean ด้วย Boolean() หรือ !! Empty arrays และ objects เป็น truthy!"
    },
    {
      "vocab": "What is the difference between function declaration and expression?",
      "pronunciation": "// Function Declaration (hoisted)\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\n// Can call before declaration\nsayHi();  // works!\nfunction sayHi() { console.log('Hi'); }\n\n// Function Expression (NOT hoisted)\nconst greet = function(name) {\n  return `Hello, ${name}!`;\n};\n\n// Named function expression\nconst factorial = function fact(n) {\n  return n <= 1 ? 1 : n * fact(n - 1);  // name for recursion\n};\n\n// Arrow Function (expression)\nconst greet = (name) => `Hello, ${name}!`;\nconst square = x => x * x;  // single param, no parens\nconst add = (a, b) => a + b;  // implicit return\nconst process = (x) => {\n  const result = x * 2;\n  return result;  // explicit return needed with {}\n};\n\n// Arrow vs regular: no own this, arguments, super\nconst obj = {\n  items: [1, 2, 3],\n  process() {\n    this.items.map(x => x * this.multiplier);  // this works\n  }\n};",
      "meaning": "Function declaration และ expression ต่างกันอย่างไร?",
      "example": "Declaration: hoisted, can call before definition. Expression: assigned to variable, not hoisted. Arrow functions: concise syntax, no own 'this', 'arguments', or 'super'. Implicit return without braces. Use declarations for named functions, expressions for callbacks and when you need lexical 'this'.",
      "exampleTranslation": "Declaration: hoisted เรียกก่อน definition ได้ Expression: assign ให้ variable ไม่ถูก hoist Arrow functions: syntax กระชับ ไม่มี 'this', 'arguments', หรือ 'super' ของตัวเอง Implicit return โดยไม่ต้องมี braces ใช้ declarations สำหรับ named functions, expressions สำหรับ callbacks และเมื่อต้องการ lexical 'this'"
    },
    {
      "vocab": "What are Promises?",
      "pronunciation": "// Promise: object representing eventual completion/failure\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    const success = true;\n    if (success) {\n      resolve('Data loaded');\n    } else {\n      reject(new Error('Failed'));\n    }\n  }, 1000);\n});\n\n// Consuming promises\npromise\n  .then(result => console.log(result))\n  .catch(error => console.error(error))\n  .finally(() => console.log('Done'));\n\n// Chaining\nfetch('/api/user')\n  .then(res => res.json())\n  .then(user => fetch(`/api/posts/${user.id}`))\n  .then(res => res.json())\n  .then(posts => console.log(posts))\n  .catch(err => console.error(err));\n\n// Static methods\nPromise.all([p1, p2, p3])       // all must succeed\nPromise.allSettled([p1, p2])    // wait for all, get results\nPromise.race([p1, p2])          // first to settle\nPromise.any([p1, p2])           // first to fulfill\nPromise.resolve(value)          // create resolved\nPromise.reject(error)           // create rejected",
      "meaning": "Promises คืออะไร?",
      "example": "Promise represents eventual completion or failure of async operation. States: pending, fulfilled, rejected. Use .then() for success, .catch() for errors, .finally() for cleanup. Chaining returns new promises. Static methods: Promise.all (all succeed), Promise.allSettled (all complete), Promise.race (first), Promise.any (first success).",
      "exampleTranslation": "Promise แทน eventual completion หรือ failure ของ async operation States: pending, fulfilled, rejected ใช้ .then() สำหรับ success, .catch() สำหรับ errors, .finally() สำหรับ cleanup Chaining return promises ใหม่ Static methods: Promise.all (ทั้งหมดสำเร็จ), Promise.allSettled (ทั้งหมดเสร็จ), Promise.race (ตัวแรก), Promise.any (ตัวแรกที่สำเร็จ)"
    },
    {
      "vocab": "What is async/await?",
      "pronunciation": "// async function always returns a Promise\nasync function fetchUser() {\n  return 'John';  // wrapped in Promise.resolve()\n}\n\n// await pauses until Promise settles\nasync function getData() {\n  try {\n    const response = await fetch('/api/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;  // re-throw or handle\n  }\n}\n\n// Parallel execution\nasync function fetchAll() {\n  // Sequential (slow)\n  const a = await fetchA();\n  const b = await fetchB();\n  \n  // Parallel (fast)\n  const [a, b] = await Promise.all([\n    fetchA(),\n    fetchB()\n  ]);\n}\n\n// Top-level await (ES2022, modules only)\nconst data = await fetch('/api').then(r => r.json());\n\n// Error handling patterns\nconst [error, result] = await getData()\n  .then(data => [null, data])\n  .catch(err => [err, null]);",
      "meaning": "async/await คืออะไร?",
      "example": "async/await is syntactic sugar over Promises. async function returns Promise. await pauses execution until Promise settles. Use try/catch for error handling. Common mistake: awaiting in loop (sequential). Use Promise.all for parallel execution. Top-level await available in ES modules.",
      "exampleTranslation": "async/await คือ syntactic sugar เหนือ Promises async function return Promise await หยุด execution จนกว่า Promise settles ใช้ try/catch สำหรับ error handling ข้อผิดพลาดที่พบบ่อย: awaiting ใน loop (sequential) ใช้ Promise.all สำหรับ parallel execution Top-level await มีใน ES modules"
    },
    {
      "vocab": "What is prototypal inheritance?",
      "pronunciation": "// Every object has a prototype\nconst animal = {\n  speak() { console.log('Some sound'); }\n};\n\nconst dog = Object.create(animal);\ndog.bark = function() { console.log('Woof!'); };\n\ndog.bark();   // 'Woof!' (own method)\ndog.speak();  // 'Some sound' (inherited)\n\n// Prototype chain\nconsole.log(dog.__proto__ === animal);  // true\nconsole.log(animal.__proto__ === Object.prototype);  // true\nconsole.log(Object.prototype.__proto__);  // null (end of chain)\n\n// Constructor function pattern\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  console.log(`Hi, I'm ${this.name}`);\n};\n\nconst john = new Person('John');\njohn.greet();  // \"Hi, I'm John\"\n\n// Check prototype\nObject.getPrototypeOf(john) === Person.prototype  // true\njohn instanceof Person  // true\njohn.hasOwnProperty('name')  // true\njohn.hasOwnProperty('greet')  // false (on prototype)",
      "meaning": "Prototypal inheritance คืออะไร?",
      "example": "JavaScript uses prototypal inheritance - objects inherit from other objects. Every object has internal [[Prototype]] link. Property lookup walks the prototype chain. Object.create() creates object with specified prototype. Constructor functions use .prototype for shared methods. Use hasOwnProperty() to check own vs inherited properties.",
      "exampleTranslation": "JavaScript ใช้ prototypal inheritance - objects สืบทอดจาก objects อื่น ทุก object มี internal [[Prototype]] link Property lookup เดินตาม prototype chain Object.create() สร้าง object กับ prototype ที่ระบุ Constructor functions ใช้ .prototype สำหรับ shared methods ใช้ hasOwnProperty() เพื่อ check own vs inherited properties"
    },
    {
      "vocab": "What are ES6 classes?",
      "pronunciation": "// Class declaration (syntactic sugar over prototypes)\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a sound`);\n  }\n  \n  static create(name) {  // static method\n    return new Animal(name);\n  }\n}\n\n// Inheritance\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);  // must call super first\n    this.breed = breed;\n  }\n  \n  speak() {\n    super.speak();  // call parent method\n    console.log('Woof!');\n  }\n  \n  // Getters and setters\n  get info() {\n    return `${this.name} (${this.breed})`;\n  }\n  \n  set nickname(value) {\n    this._nickname = value;\n  }\n}\n\nconst dog = new Dog('Max', 'Labrador');\ndog.speak();\nconsole.log(dog.info);  // getter\n\n// Private fields (ES2022)\nclass Counter {\n  #count = 0;  // private field\n  increment() { this.#count++; }\n  get value() { return this.#count; }\n}",
      "meaning": "ES6 classes คืออะไร?",
      "example": "ES6 classes are syntactic sugar over prototypal inheritance. Use class keyword, constructor for initialization. extends for inheritance, super to call parent. Static methods belong to class, not instances. Getters/setters for computed properties. Private fields with # prefix (ES2022). Under the hood, still uses prototypes.",
      "exampleTranslation": "ES6 classes เป็น syntactic sugar เหนือ prototypal inheritance ใช้ class keyword, constructor สำหรับ initialization extends สำหรับ inheritance, super เพื่อเรียก parent Static methods อยู่กับ class ไม่ใช่ instances Getters/setters สำหรับ computed properties Private fields ด้วย # prefix (ES2022) ภายใต้ยังคงใช้ prototypes"
    },
    {
      "vocab": "What is destructuring?",
      "pronunciation": "// Array destructuring\nconst [a, b] = [1, 2];\nconst [first, , third] = [1, 2, 3];  // skip elements\nconst [x, y = 10] = [5];  // default values\nconst [head, ...rest] = [1, 2, 3, 4];  // rest pattern\n\n// Swap variables\nlet m = 1, n = 2;\n[m, n] = [n, m];\n\n// Object destructuring\nconst {name, age} = {name: 'John', age: 30};\nconst {name: userName} = user;  // rename\nconst {name, age = 25} = user;  // default\nconst {a, b, ...others} = obj;  // rest\n\n// Nested destructuring\nconst {address: {city}} = user;\n\n// Function parameters\nfunction greet({name, age = 0}) {\n  console.log(`${name} is ${age}`);\n}\ngreet({name: 'John'});\n\n// Mixed destructuring\nconst users = [{name: 'John'}, {name: 'Jane'}];\nconst [{name: firstName}] = users;  // 'John'",
      "meaning": "Destructuring คืออะไร?",
      "example": "Destructuring extracts values from arrays/objects into variables. Array: position-based [a, b]. Object: key-based {name}. Features: default values, renaming (object), rest pattern (...), nested destructuring. Great for function parameters and module imports. Fails on null/undefined - use defaults.",
      "exampleTranslation": "Destructuring แยกค่าจาก arrays/objects เป็น variables Array: position-based [a, b] Object: key-based {name} Features: default values, renaming (object), rest pattern (...), nested destructuring ดีสำหรับ function parameters และ module imports Fail บน null/undefined - ใช้ defaults"
    },
    {
      "vocab": "What are spread and rest operators?",
      "pronunciation": "// Spread (...) - expands iterable\nconst arr1 = [1, 2, 3];\nconst arr2 = [...arr1, 4, 5];  // [1, 2, 3, 4, 5]\n\n// Copy array (shallow)\nconst copy = [...arr1];\n\n// Merge arrays\nconst merged = [...arr1, ...arr2];\n\n// Spread in objects\nconst obj1 = {a: 1, b: 2};\nconst obj2 = {...obj1, c: 3};  // {a: 1, b: 2, c: 3}\nconst override = {...obj1, b: 10};  // {a: 1, b: 10}\n\n// Spread in function calls\nMath.max(...[1, 5, 3]);  // 5\nconsole.log(...['a', 'b', 'c']);\n\n// Rest (...) - collects into array\nfunction sum(...numbers) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\nsum(1, 2, 3, 4);  // 10\n\n// Rest in destructuring\nconst [first, ...rest] = [1, 2, 3];  // rest = [2, 3]\nconst {a, ...others} = {a: 1, b: 2, c: 3};  // others = {b: 2, c: 3}\n\n// Rest must be last\nfunction fn(a, b, ...rest) {}  // OK\n// function fn(...rest, a) {}  // SyntaxError",
      "meaning": "Spread และ rest operators คืออะไร?",
      "example": "Spread (...) expands iterables/objects: array copying, merging, function arguments. Rest (...) collects elements into array: function parameters, destructuring. Same syntax, different contexts. Spread: right side of =. Rest: left side or function params. Both create shallow copies. Rest must be last parameter.",
      "exampleTranslation": "Spread (...) ขยาย iterables/objects: array copying, merging, function arguments Rest (...) รวบรวม elements เป็น array: function parameters, destructuring Syntax เดียวกัน contexts ต่างกัน Spread: ด้านขวาของ = Rest: ด้านซ้ายหรือ function params ทั้งคู่สร้าง shallow copies Rest ต้องเป็น parameter ตัวสุดท้าย"
    },
    {
      "vocab": "What are template literals?",
      "pronunciation": "// Template literals with backticks\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;  // string interpolation\n\n// Multi-line strings\nconst html = `\n  <div>\n    <h1>Title</h1>\n    <p>Content</p>\n  </div>\n`;\n\n// Expressions in templates\nconst a = 5, b = 10;\nconsole.log(`Sum: ${a + b}`);  // Sum: 15\nconsole.log(`Double: ${a * 2}`);  // Double: 10\n\n// Nested templates\nconst items = ['a', 'b', 'c'];\nconst list = `<ul>${items.map(i => `<li>${i}</li>`).join('')}</ul>`;\n\n// Tagged templates\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, str, i) => {\n    return result + str + (values[i] ? `<b>${values[i]}</b>` : '');\n  }, '');\n}\n\nconst msg = highlight`Hello ${name}, you have ${5} messages`;\n// \"Hello <b>John</b>, you have <b>5</b> messages\"\n\n// Raw strings\nString.raw`Line1\\nLine2`;  // 'Line1\\\\nLine2' (no escape)",
      "meaning": "Template literals คืออะไร?",
      "example": "Template literals use backticks (`) for strings. Features: ${expression} for interpolation, multi-line strings without \\n, nested templates. Tagged templates allow custom processing - first arg is string parts, rest are values. String.raw for raw strings without escape processing. Better than string concatenation.",
      "exampleTranslation": "Template literals ใช้ backticks (`) สำหรับ strings Features: ${expression} สำหรับ interpolation, multi-line strings โดยไม่ต้อง \\n, nested templates Tagged templates อนุญาตให้ custom processing - arg แรกเป็น string parts ที่เหลือเป็น values String.raw สำหรับ raw strings โดยไม่ process escape ดีกว่า string concatenation"
    },
    {
      "vocab": "What are Map and Set?",
      "pronunciation": "// Map: key-value pairs (any type as key)\nconst map = new Map();\nmap.set('name', 'John');\nmap.set(1, 'one');\nmap.set({id: 1}, 'object key');\n\nmap.get('name');  // 'John'\nmap.has(1);       // true\nmap.delete(1);    // removes key\nmap.size;         // 2\nmap.clear();      // removes all\n\n// Iteration\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\nmap.keys();    // iterator of keys\nmap.values();  // iterator of values\nmap.entries(); // iterator of [key, value]\n\n// Set: unique values\nconst set = new Set([1, 2, 2, 3]);  // {1, 2, 3}\nset.add(4);\nset.has(2);    // true\nset.delete(2);\nset.size;      // 3\n\n// Remove duplicates from array\nconst unique = [...new Set([1, 1, 2, 2, 3])];\n\n// WeakMap and WeakSet: weak references\n// Keys must be objects, garbage collected when no other reference\nconst weakMap = new WeakMap();\nconst weakSet = new WeakSet();",
      "meaning": "Map และ Set คืออะไร?",
      "example": "Map: key-value collection with any type as key (unlike Object). Maintains insertion order. Methods: set, get, has, delete, clear. Set: unique values collection. Methods: add, has, delete. Both are iterable. WeakMap/WeakSet: weak references, keys must be objects, allow garbage collection. Use Set to dedupe arrays.",
      "exampleTranslation": "Map: key-value collection ที่ key เป็น type ใดก็ได้ (ต่างจาก Object) รักษา insertion order Methods: set, get, has, delete, clear Set: unique values collection Methods: add, has, delete ทั้งคู่เป็น iterable WeakMap/WeakSet: weak references, keys ต้องเป็น objects, อนุญาต garbage collection ใช้ Set เพื่อ dedupe arrays"
    },
    {
      "vocab": "What are the common array methods?",
      "pronunciation": "const arr = [1, 2, 3, 4, 5];\n\n// Transforming (return new array)\narr.map(x => x * 2);         // [2, 4, 6, 8, 10]\narr.filter(x => x > 2);      // [3, 4, 5]\narr.slice(1, 3);             // [2, 3] (start, end)\n\n// Reducing\narr.reduce((sum, x) => sum + x, 0);  // 15\narr.reduceRight((sum, x) => sum + x, 0);  // from right\n\n// Searching\narr.find(x => x > 2);        // 3 (first match)\narr.findIndex(x => x > 2);   // 2 (index)\narr.indexOf(3);              // 2\narr.includes(3);             // true\narr.some(x => x > 4);        // true (any match)\narr.every(x => x > 0);       // true (all match)\n\n// Mutating (modify original)\narr.push(6);      // add to end\narr.pop();        // remove from end\narr.unshift(0);   // add to start\narr.shift();      // remove from start\narr.splice(1, 2, 'a');  // remove 2 at index 1, insert 'a'\narr.sort((a, b) => a - b);  // sort in place\narr.reverse();    // reverse in place\n\n// Other\narr.flat(2);      // flatten nested arrays\narr.flatMap(x => [x, x*2]);  // map then flat\n[1,2].concat([3,4]);  // [1,2,3,4]",
      "meaning": "Array methods ที่ใช้บ่อยมีอะไรบ้าง?",
      "example": "Immutable (new array): map, filter, slice, concat, flat, flatMap. Reducing: reduce, reduceRight. Searching: find, findIndex, indexOf, includes, some, every. Mutating (modify original): push, pop, shift, unshift, splice, sort, reverse. Use immutable methods for functional programming. sort mutates - copy first if needed.",
      "exampleTranslation": "Immutable (array ใหม่): map, filter, slice, concat, flat, flatMap Reducing: reduce, reduceRight Searching: find, findIndex, indexOf, includes, some, every Mutating (แก้ไข original): push, pop, shift, unshift, splice, sort, reverse ใช้ immutable methods สำหรับ functional programming sort mutates - copy ก่อนถ้าต้องการ"
    },
    {
      "vocab": "What is optional chaining and nullish coalescing?",
      "pronunciation": "// Optional chaining (?.) - safe property access\nconst user = {profile: {name: 'John'}};\n\n// Without optional chaining\nconst city = user && user.address && user.address.city;\n\n// With optional chaining\nconst city = user?.address?.city;  // undefined (no error)\n\n// Methods and arrays\nuser.getProfile?.();       // safe method call\nuser.items?.[0];           // safe array access\nuser.items?.[0]?.name;     // chained\n\n// Nullish coalescing (??) - null/undefined only\nconst name = null ?? 'Default';      // 'Default'\nconst name = undefined ?? 'Default'; // 'Default'\nconst name = '' ?? 'Default';        // '' (empty is valid)\nconst name = 0 ?? 'Default';         // 0 (zero is valid)\n\n// vs || (logical OR) - any falsy\nconst name = '' || 'Default';   // 'Default'\nconst name = 0 || 'Default';    // 'Default'\n\n// Combined usage\nconst displayName = user?.profile?.name ?? 'Anonymous';\n\n// Nullish assignment\nuser.name ??= 'Default';  // assign only if null/undefined",
      "meaning": "Optional chaining และ nullish coalescing คืออะไร?",
      "example": "Optional chaining (?.) safely accesses nested properties - returns undefined if any part is null/undefined. Works with properties, methods, arrays. Nullish coalescing (??) provides default only for null/undefined, unlike || which triggers on any falsy value. Use together for safe access with defaults.",
      "exampleTranslation": "Optional chaining (?.) เข้าถึง nested properties อย่างปลอดภัย - return undefined ถ้าส่วนใดเป็น null/undefined ใช้กับ properties, methods, arrays Nullish coalescing (??) ให้ default เฉพาะ null/undefined ต่างจาก || ที่ trigger กับ falsy ใดๆ ใช้ด้วยกันสำหรับ safe access พร้อม defaults"
    },
    {
      "vocab": "What are JavaScript modules (import/export)?",
      "pronunciation": "// Named exports\nexport const PI = 3.14;\nexport function add(a, b) { return a + b; }\nexport class Calculator {}\n\n// Export list\nconst x = 1, y = 2;\nexport {x, y};\nexport {x as exportedX};  // rename\n\n// Default export (one per module)\nexport default function main() {}\nexport default class App {}\nconst value = 42;\nexport default value;\n\n// Named imports\nimport {add, PI} from './math.js';\nimport {add as sum} from './math.js';  // rename\nimport * as math from './math.js';     // namespace\nmath.add(1, 2);\n\n// Default import\nimport Main from './main.js';\nimport React from 'react';\n\n// Mixed\nimport React, {useState, useEffect} from 'react';\n\n// Dynamic import\nconst module = await import('./module.js');\nmodule.default;  // default export\nmodule.namedExport;  // named export\n\n// Re-export\nexport {add} from './math.js';\nexport * from './utils.js';",
      "meaning": "JavaScript modules (import/export) คืออะไร?",
      "example": "ES modules use import/export for code organization. Named exports: multiple per file, import with braces. Default export: one per file, import without braces. Dynamic import() returns Promise for code splitting. Modules have own scope, run in strict mode. Use .mjs extension or type='module' in HTML.",
      "exampleTranslation": "ES modules ใช้ import/export สำหรับ code organization Named exports: หลายตัวต่อ file, import ด้วย braces Default export: หนึ่งต่อ file, import โดยไม่มี braces Dynamic import() return Promise สำหรับ code splitting Modules มี scope ของตัวเอง รันใน strict mode ใช้ .mjs extension หรือ type='module' ใน HTML"
    },
    {
      "vocab": "What is the Proxy object?",
      "pronunciation": "// Proxy: intercept object operations\nconst target = {name: 'John', age: 30};\n\nconst handler = {\n  get(target, prop, receiver) {\n    console.log(`Getting ${prop}`);\n    return Reflect.get(target, prop, receiver);\n  },\n  \n  set(target, prop, value, receiver) {\n    console.log(`Setting ${prop} to ${value}`);\n    return Reflect.set(target, prop, value, receiver);\n  }\n};\n\nconst proxy = new Proxy(target, handler);\nproxy.name;       // logs: Getting name, returns 'John'\nproxy.age = 31;   // logs: Setting age to 31\n\n// Validation example\nconst validator = {\n  set(obj, prop, value) {\n    if (prop === 'age' && typeof value !== 'number') {\n      throw new TypeError('Age must be a number');\n    }\n    obj[prop] = value;\n    return true;\n  }\n};\n\n// Traps: get, set, has, deleteProperty, apply, construct,\n//        getPrototypeOf, setPrototypeOf, ownKeys, etc.\n\n// Revocable proxy\nconst {proxy, revoke} = Proxy.revocable(target, handler);\nrevoke();  // proxy becomes unusable",
      "meaning": "Proxy object คืออะไร?",
      "example": "Proxy intercepts operations on target object using handler traps. Traps: get, set, has, deleteProperty, apply (functions), construct (new), etc. Use cases: validation, logging, access control, virtual properties, reactive programming. Reflect provides default behavior. Revocable proxies can be disabled.",
      "exampleTranslation": "Proxy intercept operations บน target object โดยใช้ handler traps Traps: get, set, has, deleteProperty, apply (functions), construct (new) เป็นต้น Use cases: validation, logging, access control, virtual properties, reactive programming Reflect ให้ default behavior Revocable proxies สามารถ disable ได้"
    },
    {
      "vocab": "What are generators?",
      "pronunciation": "// Generator function (function*)\nfunction* countUp() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = countUp();\ngen.next();  // {value: 1, done: false}\ngen.next();  // {value: 2, done: false}\ngen.next();  // {value: 3, done: false}\ngen.next();  // {value: undefined, done: true}\n\n// Generators are iterable\nfor (const num of countUp()) {\n  console.log(num);  // 1, 2, 3\n}\n\n// Infinite sequence\nfunction* fibonacci() {\n  let [a, b] = [0, 1];\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nconst fib = fibonacci();\nfib.next().value;  // 0\nfib.next().value;  // 1\nfib.next().value;  // 1\nfib.next().value;  // 2\n\n// Two-way communication\nfunction* ask() {\n  const name = yield 'What is your name?';\n  const age = yield `Hello ${name}, how old are you?`;\n  return `${name} is ${age}`;\n}\n\nconst q = ask();\nq.next();           // {value: 'What is your name?'}\nq.next('John');     // {value: 'Hello John...'}\nq.next(30);         // {value: 'John is 30', done: true}",
      "meaning": "Generators คืออะไร?",
      "example": "Generators are functions that can pause execution with yield. Returns iterator with next() method. Each next() runs until yield, returning {value, done}. Can receive values via next(value). Use cases: lazy evaluation, infinite sequences, async flow control, custom iterators. Generators are iterable with for...of.",
      "exampleTranslation": "Generators เป็น functions ที่หยุด execution ด้วย yield ได้ Return iterator ที่มี next() method แต่ละ next() รันจนถึง yield return {value, done} รับค่าผ่าน next(value) ได้ Use cases: lazy evaluation, infinite sequences, async flow control, custom iterators Generators เป็น iterable ด้วย for...of"
    },
    {
      "vocab": "What is Symbol?",
      "pronunciation": "// Symbol: unique primitive value\nconst sym1 = Symbol('description');\nconst sym2 = Symbol('description');\nsym1 === sym2;  // false (always unique)\n\n// As object property keys\nconst id = Symbol('id');\nconst user = {\n  name: 'John',\n  [id]: 123  // symbol key\n};\n\nuser[id];  // 123\nObject.keys(user);  // ['name'] - symbols hidden\nObject.getOwnPropertySymbols(user);  // [Symbol(id)]\n\n// Global symbol registry\nconst globalSym = Symbol.for('app.id');  // create or get\nconst same = Symbol.for('app.id');       // get existing\nglobalSym === same;  // true\nSymbol.keyFor(globalSym);  // 'app.id'\n\n// Well-known symbols (built-in)\nSymbol.iterator   // for...of behavior\nSymbol.toStringTag  // Object.prototype.toString\nSymbol.hasInstance  // instanceof behavior\nSymbol.toPrimitive  // type conversion\n\n// Custom iterator\nconst obj = {\n  data: [1, 2, 3],\n  [Symbol.iterator]() {\n    let i = 0;\n    return {\n      next: () => ({\n        value: this.data[i],\n        done: i++ >= this.data.length\n      })\n    };\n  }\n};",
      "meaning": "Symbol คืออะไร?",
      "example": "Symbol creates unique identifiers. Every Symbol() call returns unique value. Use as property keys for private/hidden properties - not enumerable with Object.keys(). Symbol.for() creates global symbols by key. Well-known symbols customize language behavior (Symbol.iterator, Symbol.toStringTag). Can't convert Symbol to string/number implicitly.",
      "exampleTranslation": "Symbol สร้าง unique identifiers ทุกการเรียก Symbol() return ค่า unique ใช้เป็น property keys สำหรับ private/hidden properties - ไม่ถูก enumerate ด้วย Object.keys() Symbol.for() สร้าง global symbols ด้วย key Well-known symbols customize language behavior (Symbol.iterator, Symbol.toStringTag) แปลง Symbol เป็น string/number โดยปริยายไม่ได้"
    },
    {
      "vocab": "What is the difference between call, apply, and bind?",
      "pronunciation": "// All three set 'this' for function execution\n\nfunction greet(greeting, punctuation) {\n  console.log(`${greeting}, ${this.name}${punctuation}`);\n}\n\nconst person = {name: 'John'};\n\n// call: invoke immediately, args as list\ngreet.call(person, 'Hello', '!');  // \"Hello, John!\"\n\n// apply: invoke immediately, args as array\ngreet.apply(person, ['Hello', '!']);  // \"Hello, John!\"\n\n// bind: return new function with bound 'this'\nconst boundGreet = greet.bind(person);\nboundGreet('Hi', '?');  // \"Hi, John?\"\n\n// Partial application with bind\nconst sayHello = greet.bind(person, 'Hello');\nsayHello('!');  // \"Hello, John!\"\n\n// Use cases\n// call: borrowing methods\nArray.prototype.slice.call(arguments);\n\n// apply: passing array as arguments\nMath.max.apply(null, [1, 5, 3]);  // 5\nMath.max(...[1, 5, 3]);  // spread is now preferred\n\n// bind: event handlers, callbacks\nbutton.addEventListener('click', handler.bind(this));\nsetTimeout(obj.method.bind(obj), 1000);",
      "meaning": "call, apply และ bind ต่างกันอย่างไร?",
      "example": "All set 'this' context for function. call: invokes immediately with comma-separated args. apply: invokes immediately with args as array. bind: returns new function with bound 'this' (doesn't invoke). bind also supports partial application (pre-filling args). Use bind for callbacks and event handlers to preserve 'this'.",
      "exampleTranslation": "ทั้งหมด set 'this' context สำหรับ function call: invoke ทันทีกับ args คั่นด้วยคอมมา apply: invoke ทันทีกับ args เป็น array bind: return function ใหม่ที่ bound 'this' (ไม่ invoke) bind ยังรองรับ partial application (pre-filling args) ใช้ bind สำหรับ callbacks และ event handlers เพื่อรักษา 'this'"
    },
    {
      "vocab": "What is event bubbling and capturing?",
      "pronunciation": "// Event propagation phases:\n// 1. Capturing (top to target)\n// 2. Target\n// 3. Bubbling (target to top)\n\n// <div id=\"outer\">\n//   <div id=\"inner\">\n//     <button id=\"btn\">Click</button>\n//   </div>\n// </div>\n\n// Bubbling (default)\nbtn.addEventListener('click', () => console.log('btn'));\ninner.addEventListener('click', () => console.log('inner'));\nouter.addEventListener('click', () => console.log('outer'));\n// Click btn → logs: btn, inner, outer\n\n// Capturing (third argument true)\nouter.addEventListener('click', () => console.log('capture'), true);\n// Click btn → logs: capture, btn, inner, outer\n\n// Stop propagation\nbtn.addEventListener('click', (e) => {\n  e.stopPropagation();  // stops bubbling/capturing\n  console.log('btn only');\n});\n\n// Event delegation\nul.addEventListener('click', (e) => {\n  if (e.target.matches('li')) {\n    console.log('Clicked:', e.target.textContent);\n  }\n});\n\n// Prevent default behavior\nform.addEventListener('submit', (e) => {\n  e.preventDefault();  // don't submit form\n});",
      "meaning": "Event bubbling และ capturing คืออะไร?",
      "example": "Events propagate in 3 phases: capturing (down), target, bubbling (up). Default listeners use bubbling. Set third arg true for capturing. stopPropagation() prevents further propagation. Event delegation uses bubbling - single listener on parent handles children. Use e.target for actual clicked element, e.currentTarget for listener element.",
      "exampleTranslation": "Events propagate ใน 3 phases: capturing (ลง), target, bubbling (ขึ้น) Default listeners ใช้ bubbling Set arg ที่สามเป็น true สำหรับ capturing stopPropagation() ป้องกัน propagation ต่อไป Event delegation ใช้ bubbling - listener เดียวบน parent จัดการ children ใช้ e.target สำหรับ element ที่ถูก click, e.currentTarget สำหรับ listener element"
    },
    {
      "vocab": "What is the difference between null and undefined?",
      "pronunciation": "// undefined: variable declared but not assigned\nlet x;\nconsole.log(x);  // undefined\n\n// Function without return\nfunction noReturn() {}\nconsole.log(noReturn());  // undefined\n\n// Missing object property\nconst obj = {};\nconsole.log(obj.missing);  // undefined\n\n// Missing function argument\nfunction fn(a, b) {\n  console.log(b);  // undefined if not passed\n}\n\n// null: intentional absence of value\nlet user = null;  // explicitly set to nothing\n\n// Type differences\ntypeof undefined  // \"undefined\"\ntypeof null       // \"object\" (historical bug)\n\n// Equality\nnull == undefined   // true (loose equality)\nnull === undefined  // false (strict)\n\n// Arithmetic\nundefined + 1  // NaN\nnull + 1       // 1 (null converts to 0)\n\n// JSON\nJSON.stringify({a: undefined, b: null})  // {\"b\":null}\n// undefined properties are omitted\n\n// Default parameters\nfunction fn(x = 'default') {}\nfn(undefined);  // x = 'default'\nfn(null);       // x = null (null is a value)",
      "meaning": "null และ undefined ต่างกันอย่างไร?",
      "example": "undefined: variable not yet assigned, missing properties, no return value. Represents 'not initialized'. null: intentional absence of value. Represents 'empty' or 'nothing'. typeof undefined = 'undefined', typeof null = 'object' (bug). null == undefined but null !== undefined. Default parameters trigger on undefined only, not null.",
      "exampleTranslation": "undefined: variable ยังไม่ถูก assign, missing properties, ไม่มี return value แทน 'not initialized' null: intentional absence of value แทน 'empty' หรือ 'nothing' typeof undefined = 'undefined', typeof null = 'object' (bug) null == undefined แต่ null !== undefined Default parameters trigger บน undefined เท่านั้น ไม่ใช่ null"
    },
    {
      "vocab": "What is JSON and how to work with it?",
      "pronunciation": "// JSON: JavaScript Object Notation\n// Text format for data exchange\n\n// Valid JSON\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"active\": true,\n  \"address\": null,\n  \"hobbies\": [\"reading\", \"gaming\"],\n  \"profile\": {\"bio\": \"Developer\"}\n}\n\n// JSON rules:\n// - Keys must be double-quoted strings\n// - No trailing commas\n// - No functions, undefined, symbols\n// - No comments\n\n// Parse: JSON string → JavaScript object\nconst obj = JSON.parse('{\"name\": \"John\"}');\n\n// Stringify: JavaScript object → JSON string\nconst json = JSON.stringify({name: 'John'});\n\n// Pretty print\nJSON.stringify(obj, null, 2);  // 2-space indent\n\n// Replacer function\nJSON.stringify(obj, (key, value) => {\n  if (key === 'password') return undefined;  // exclude\n  return value;\n});\n\n// Reviver function\nJSON.parse(json, (key, value) => {\n  if (key === 'date') return new Date(value);\n  return value;\n});\n\n// Deep clone (simple objects)\nconst clone = JSON.parse(JSON.stringify(obj));\n// Note: loses functions, undefined, dates, etc.",
      "meaning": "JSON คืออะไรและใช้งานอย่างไร?",
      "example": "JSON is text format for data exchange. Keys must be double-quoted, values can be string, number, boolean, null, object, array. JSON.parse() converts string to object, JSON.stringify() converts object to string. Use replacer/reviver for custom conversion. JSON.parse/stringify can deep clone simple objects but loses functions, Date, undefined.",
      "exampleTranslation": "JSON คือ text format สำหรับ data exchange Keys ต้องเป็น double-quoted, values เป็น string, number, boolean, null, object, array JSON.parse() แปลง string เป็น object, JSON.stringify() แปลง object เป็น string ใช้ replacer/reviver สำหรับ custom conversion JSON.parse/stringify deep clone simple objects ได้แต่เสีย functions, Date, undefined"
    },
    {
      "vocab": "What is the Fetch API?",
      "pronunciation": "// Fetch: modern API for HTTP requests\n\n// Basic GET\nconst response = await fetch('/api/data');\nconst data = await response.json();\n\n// Check response\nif (!response.ok) {\n  throw new Error(`HTTP error: ${response.status}`);\n}\n\n// POST with JSON\nconst response = await fetch('/api/users', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({name: 'John'})\n});\n\n// Other options\nfetch(url, {\n  method: 'PUT',           // GET, POST, PUT, DELETE, etc.\n  headers: {...},          // request headers\n  body: JSON.stringify(data),\n  mode: 'cors',            // cors, no-cors, same-origin\n  credentials: 'include',  // include, same-origin, omit\n  cache: 'no-cache',       // cache mode\n  signal: controller.signal  // for abort\n});\n\n// AbortController\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 5000);\n\ntry {\n  await fetch(url, {signal: controller.signal});\n} catch (e) {\n  if (e.name === 'AbortError') {\n    console.log('Request aborted');\n  }\n}\n\n// Response methods\nresponse.json();   // parse JSON\nresponse.text();   // plain text\nresponse.blob();   // binary data",
      "meaning": "Fetch API คืออะไร?",
      "example": "Fetch is Promise-based API for HTTP requests, replacing XMLHttpRequest. Returns Response object - use .json(), .text(), .blob() for body. Check response.ok for success. Set method, headers, body for different request types. Use AbortController to cancel requests. Note: Fetch doesn't reject on HTTP errors, only network failures.",
      "exampleTranslation": "Fetch คือ Promise-based API สำหรับ HTTP requests แทนที่ XMLHttpRequest Return Response object - ใช้ .json(), .text(), .blob() สำหรับ body Check response.ok สำหรับ success Set method, headers, body สำหรับ request types ต่างๆ ใช้ AbortController เพื่อ cancel requests หมายเหตุ: Fetch ไม่ reject บน HTTP errors เฉพาะ network failures"
    },
    {
      "vocab": "What is localStorage and sessionStorage?",
      "pronunciation": "// localStorage: persists until cleared\nlocalStorage.setItem('name', 'John');\nlocalStorage.getItem('name');  // 'John'\nlocalStorage.removeItem('name');\nlocalStorage.clear();  // remove all\n\n// Store objects (must stringify)\nlocalStorage.setItem('user', JSON.stringify({name: 'John'}));\nconst user = JSON.parse(localStorage.getItem('user'));\n\n// sessionStorage: cleared when tab closes\nsessionStorage.setItem('token', 'abc123');\n\n// Differences:\n// localStorage:\n//   - Persists across browser sessions\n//   - Shared across all tabs of same origin\n//   - ~5-10MB limit\n\n// sessionStorage:\n//   - Cleared when tab closes\n//   - Separate per tab (same origin)\n//   - ~5-10MB limit\n\n// Storage event (localStorage only, other tabs)\nwindow.addEventListener('storage', (e) => {\n  console.log(e.key, e.oldValue, e.newValue);\n});\n\n// Check if available\nfunction storageAvailable(type) {\n  try {\n    const x = '__test__';\n    window[type].setItem(x, x);\n    window[type].removeItem(x);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}",
      "meaning": "localStorage และ sessionStorage คืออะไร?",
      "example": "Both store key-value string pairs in browser. localStorage: persists forever, shared across tabs. sessionStorage: cleared on tab close, per-tab storage. Methods: setItem, getItem, removeItem, clear. Store objects with JSON.stringify/parse. ~5-10MB limit. Storage event fires on localStorage changes from other tabs.",
      "exampleTranslation": "ทั้งคู่เก็บ key-value string pairs ใน browser localStorage: คงอยู่ตลอด shared across tabs sessionStorage: cleared เมื่อปิด tab, per-tab storage Methods: setItem, getItem, removeItem, clear เก็บ objects ด้วย JSON.stringify/parse ~5-10MB limit Storage event fire เมื่อ localStorage เปลี่ยนจาก tabs อื่น"
    },
    {
      "vocab": "What are JavaScript design patterns?",
      "pronunciation": "// 1. Module Pattern (encapsulation)\nconst counter = (() => {\n  let count = 0;  // private\n  return {\n    increment() { count++; },\n    getCount() { return count; }\n  };\n})();\n\n// 2. Singleton\nclass Database {\n  static instance;\n  constructor() {\n    if (Database.instance) return Database.instance;\n    Database.instance = this;\n  }\n}\n\n// 3. Factory\nfunction createUser(type) {\n  switch(type) {\n    case 'admin': return new Admin();\n    case 'user': return new User();\n  }\n}\n\n// 4. Observer (Pub/Sub)\nclass EventEmitter {\n  constructor() { this.events = {}; }\n  on(event, fn) { (this.events[event] ||= []).push(fn); }\n  emit(event, data) { this.events[event]?.forEach(fn => fn(data)); }\n}\n\n// 5. Decorator\nfunction withLogging(fn) {\n  return function(...args) {\n    console.log('Calling', fn.name);\n    return fn.apply(this, args);\n  };\n}\n\n// 6. Strategy\nconst strategies = {\n  add: (a, b) => a + b,\n  multiply: (a, b) => a * b\n};\nconst calculate = (strategy, a, b) => strategies[strategy](a, b);",
      "meaning": "JavaScript design patterns มีอะไรบ้าง?",
      "example": "Common patterns: Module (encapsulation via closures), Singleton (single instance), Factory (create objects without new), Observer/PubSub (event-driven communication), Decorator (extend functionality), Strategy (interchangeable algorithms). Modern JS uses modules for encapsulation, classes for factories, EventEmitter for observer pattern.",
      "exampleTranslation": "Patterns ที่ใช้บ่อย: Module (encapsulation ผ่าน closures), Singleton (instance เดียว), Factory (สร้าง objects โดยไม่ใช้ new), Observer/PubSub (event-driven communication), Decorator (extend functionality), Strategy (algorithms ที่สลับได้) Modern JS ใช้ modules สำหรับ encapsulation, classes สำหรับ factories, EventEmitter สำหรับ observer pattern"
    },
    {
      "vocab": "What is debounce and throttle?",
      "pronunciation": "// Debounce: wait until calls stop, then execute\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n\n// Usage: search input\nconst search = debounce((query) => {\n  fetchResults(query);\n}, 300);\n\ninput.addEventListener('input', (e) => search(e.target.value));\n// Only calls API 300ms after user stops typing\n\n// Throttle: execute at most once per interval\nfunction throttle(fn, limit) {\n  let inThrottle;\n  return function(...args) {\n    if (!inThrottle) {\n      fn.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// Usage: scroll handler\nconst onScroll = throttle(() => {\n  updatePosition();\n}, 100);\n\nwindow.addEventListener('scroll', onScroll);\n// Executes at most every 100ms while scrolling\n\n// Use debounce for: search, resize end, form validation\n// Use throttle for: scroll, mousemove, continuous updates",
      "meaning": "Debounce และ throttle คืออะไร?",
      "example": "Both limit function execution rate. Debounce: waits for pause in calls, executes after delay. Good for search input, resize end. Throttle: executes at most once per interval. Good for scroll, mousemove. Debounce delays until done, throttle rate-limits continuous events. Libraries: lodash.debounce, lodash.throttle.",
      "exampleTranslation": "ทั้งคู่จำกัด function execution rate Debounce: รอจนหยุดเรียก แล้ว execute หลัง delay ดีสำหรับ search input, resize end Throttle: execute อย่างมากหนึ่งครั้งต่อ interval ดีสำหรับ scroll, mousemove Debounce delay จนเสร็จ throttle rate-limit continuous events Libraries: lodash.debounce, lodash.throttle"
    },
    {
      "vocab": "What is currying?",
      "pronunciation": "// Currying: transform f(a, b, c) into f(a)(b)(c)\n\n// Regular function\nfunction add(a, b, c) {\n  return a + b + c;\n}\nadd(1, 2, 3);  // 6\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\ncurriedAdd(1)(2)(3);  // 6\n\n// Arrow function style\nconst curriedAdd = a => b => c => a + b + c;\n\n// Partial application\nconst add5 = curriedAdd(5);  // a is fixed to 5\nconst add5and10 = add5(10);  // b is fixed to 10\nadd5and10(3);  // 18\n\n// Generic curry function\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    return (...nextArgs) => curried(...args, ...nextArgs);\n  };\n}\n\nconst curriedSum = curry(add);\ncurriedSum(1)(2)(3);  // 6\ncurriedSum(1, 2)(3);  // 6\ncurriedSum(1)(2, 3);  // 6\n\n// Use cases: reusable function factories\nconst multiply = curry((a, b) => a * b);\nconst double = multiply(2);\nconst triple = multiply(3);",
      "meaning": "Currying คืออะไร?",
      "example": "Currying transforms function with multiple args into sequence of single-arg functions. f(a,b,c) becomes f(a)(b)(c). Enables partial application - fix some args and get new function. Use cases: creating specialized functions, point-free style, composition. curry() helper allows flexible calling patterns.",
      "exampleTranslation": "Currying แปลง function ที่มีหลาย args เป็น sequence ของ single-arg functions f(a,b,c) เป็น f(a)(b)(c) Enable partial application - fix บาง args และได้ function ใหม่ Use cases: สร้าง specialized functions, point-free style, composition curry() helper อนุญาตให้เรียกได้หลายแบบ"
    },
    {
      "vocab": "What are WeakMap and WeakSet?",
      "pronunciation": "// WeakMap: keys must be objects, weakly held\nconst wm = new WeakMap();\n\nlet obj = {name: 'John'};\nwm.set(obj, 'metadata');\nwm.get(obj);  // 'metadata'\nwm.has(obj);  // true\n\nobj = null;  // object can be garbage collected\n// Entry in WeakMap is also removed\n\n// WeakMap limitations:\n// - Keys must be objects (not primitives)\n// - Not iterable (no .keys(), .values(), .entries())\n// - No .size property\n// - No .clear() method\n\n// Use case: private data\nconst privateData = new WeakMap();\n\nclass User {\n  constructor(name) {\n    privateData.set(this, {name});\n  }\n  getName() {\n    return privateData.get(this).name;\n  }\n}\n\n// WeakSet: objects only, weakly held\nconst ws = new WeakSet();\nlet user = {id: 1};\nws.add(user);\nws.has(user);  // true\n\nuser = null;  // object can be GC'd\n\n// Use case: tracking objects\nconst processed = new WeakSet();\nfunction process(obj) {\n  if (processed.has(obj)) return;  // skip if processed\n  // process...\n  processed.add(obj);\n}",
      "meaning": "WeakMap และ WeakSet คืออะไร?",
      "example": "WeakMap/WeakSet hold 'weak' references - don't prevent garbage collection. Keys must be objects. Not iterable, no size. Use cases: associate metadata without preventing GC, track processed objects, store private data. When object key is GC'd, entry is automatically removed. Essential for memory-sensitive applications.",
      "exampleTranslation": "WeakMap/WeakSet ถือ 'weak' references - ไม่ป้องกัน garbage collection Keys ต้องเป็น objects ไม่สามารถ iterate ได้ ไม่มี size Use cases: associate metadata โดยไม่ป้องกัน GC, track processed objects, store private data เมื่อ object key ถูก GC'd entry จะถูกลบอัตโนมัติ จำเป็นสำหรับ memory-sensitive applications"
    },
    {
      "vocab": "What are common JavaScript errors and how to handle them?",
      "pronunciation": "// Error types\nnew Error('Generic error');\nnew SyntaxError('Invalid syntax');\nnew TypeError('Wrong type');\nnew ReferenceError('Variable not defined');\nnew RangeError('Number out of range');\nnew URIError('Invalid URI');\n\n// Try-catch-finally\ntry {\n  throw new Error('Something went wrong');\n} catch (error) {\n  console.error(error.message);\n  console.error(error.stack);  // stack trace\n} finally {\n  // always runs\n}\n\n// Re-throwing\ncatch (error) {\n  if (error instanceof TypeError) {\n    // handle\n  } else {\n    throw error;  // re-throw others\n  }\n}\n\n// Custom errors\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\n// Async error handling\nasync function fetchData() {\n  try {\n    const data = await fetch('/api');\n  } catch (error) {\n    console.error('Fetch failed:', error);\n  }\n}\n\n// Promise error handling\npromise\n  .then(data => process(data))\n  .catch(error => handleError(error));\n\n// Global error handlers\nwindow.onerror = (msg, url, line, col, error) => {};\nwindow.onunhandledrejection = (event) => {};",
      "meaning": "JavaScript errors ที่พบบ่อยและจัดการอย่างไร?",
      "example": "Error types: SyntaxError (bad code), TypeError (wrong type operation), ReferenceError (undefined variable), RangeError (out of bounds). Use try-catch for sync, .catch() or try-catch with await for async. Create custom errors by extending Error. finally always runs. Global handlers catch unhandled errors.",
      "exampleTranslation": "Error types: SyntaxError (code ผิด), TypeError (operation ผิด type), ReferenceError (undefined variable), RangeError (out of bounds) ใช้ try-catch สำหรับ sync, .catch() หรือ try-catch กับ await สำหรับ async สร้าง custom errors โดย extending Error finally รันเสมอ Global handlers catch unhandled errors"
    },
    {
      "vocab": "What is Object.freeze, seal, and preventExtensions?",
      "pronunciation": "// Object.preventExtensions: no new properties\nconst obj1 = {a: 1};\nObject.preventExtensions(obj1);\nobj1.b = 2;      // fails silently (or throws in strict)\nobj1.a = 10;     // OK, can modify existing\ndelete obj1.a;   // OK, can delete\nObject.isExtensible(obj1);  // false\n\n// Object.seal: no add/delete, can modify\nconst obj2 = {a: 1};\nObject.seal(obj2);\nobj2.b = 2;      // fails\nobj2.a = 10;     // OK\ndelete obj2.a;   // fails\nObject.isSealed(obj2);  // true\n\n// Object.freeze: fully immutable (shallow)\nconst obj3 = {a: 1, nested: {b: 2}};\nObject.freeze(obj3);\nobj3.a = 10;         // fails\nobj3.b = 3;          // fails\ndelete obj3.a;       // fails\nobj3.nested.b = 20;  // WORKS! (shallow freeze)\nObject.isFrozen(obj3);  // true\n\n// Deep freeze\nfunction deepFreeze(obj) {\n  Object.freeze(obj);\n  for (const key of Object.keys(obj)) {\n    if (typeof obj[key] === 'object' && obj[key] !== null) {\n      deepFreeze(obj[key]);\n    }\n  }\n  return obj;\n}\n\n// None of these affect const - const prevents reassignment only",
      "meaning": "Object.freeze, seal และ preventExtensions คืออะไร?",
      "example": "Three levels of immutability: preventExtensions (no new props), seal (+ no delete), freeze (+ no modify). All are shallow - nested objects not affected. Use deepFreeze for full immutability. Different from const: const prevents variable reassignment, these prevent object mutation. Returns the same object.",
      "exampleTranslation": "3 ระดับของ immutability: preventExtensions (ไม่เพิ่ม props), seal (+ ไม่ delete), freeze (+ ไม่ modify) ทั้งหมดเป็น shallow - nested objects ไม่ได้รับผลกระทบ ใช้ deepFreeze สำหรับ full immutability ต่างจาก const: const ป้องกัน variable reassignment พวกนี้ป้องกัน object mutation Return object เดิม"
    },
    {
      "vocab": "What is memoization?",
      "pronunciation": "// Memoization: cache function results\nfunction memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key);  // return cached\n    }\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Expensive computation\nfunction fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfibonacci(40);  // Very slow!\n\n// Memoized version\nconst memoFib = memoize(function fib(n) {\n  if (n <= 1) return n;\n  return memoFib(n - 1) + memoFib(n - 2);\n});\n\nmemoFib(40);  // Fast!\n\n// Manual memoization\nfunction factorial(n, cache = {}) {\n  if (n in cache) return cache[n];\n  if (n <= 1) return 1;\n  cache[n] = n * factorial(n - 1, cache);\n  return cache[n];\n}\n\n// With WeakMap for object arguments\nfunction memoizeWeak(fn) {\n  const cache = new WeakMap();\n  return function(obj) {\n    if (cache.has(obj)) return cache.get(obj);\n    const result = fn(obj);\n    cache.set(obj, result);\n    return result;\n  };\n}",
      "meaning": "Memoization คืออะไร?",
      "example": "Memoization caches function results based on arguments. Skips recomputation if same args seen before. Trade memory for speed. Best for: pure functions, expensive calculations, recursive algorithms (fibonacci). Use Map or object for cache. WeakMap for object args to allow GC. Clear cache if results may become stale.",
      "exampleTranslation": "Memoization cache ผลลัพธ์ของ function ตาม arguments ข้ามการคำนวณซ้ำถ้า args เดิมเคยเห็น Trade memory for speed ดีที่สุดสำหรับ: pure functions, expensive calculations, recursive algorithms (fibonacci) ใช้ Map หรือ object สำหรับ cache WeakMap สำหรับ object args เพื่ออนุญาตให้ GC Clear cache ถ้า results อาจ stale"
    },
    {
      "vocab": "What is IIFE (Immediately Invoked Function Expression)?",
      "pronunciation": "// IIFE: define and execute immediately\n(function() {\n  console.log('Runs immediately!');\n})();\n\n// With parameters\n(function(name) {\n  console.log(`Hello, ${name}!`);\n})('John');\n\n// Arrow function IIFE\n(() => {\n  console.log('Arrow IIFE');\n})();\n\n// Async IIFE\n(async () => {\n  const data = await fetchData();\n  console.log(data);\n})();\n\n// Return value\nconst result = (function() {\n  return 42;\n})();\n\n// Classic use: avoid global pollution\nconst module = (function() {\n  // private variables\n  let privateVar = 0;\n  \n  // public API\n  return {\n    increment() { privateVar++; },\n    getCount() { return privateVar; }\n  };\n})();\n\nmodule.increment();\nmodule.getCount();  // 1\n\n// Modern alternative: ES modules\n// But IIFE still useful for:\n// - Async IIFE for top-level await workaround\n// - Isolating code in scripts\n// - Loop variable capture (though let fixes this)",
      "meaning": "IIFE (Immediately Invoked Function Expression) คืออะไร?",
      "example": "IIFE is function defined and executed immediately. Syntax: (function(){})() or (() => {})(). Creates private scope, avoiding global pollution. Classic module pattern uses IIFE. Modern uses: async IIFE for await in non-module context, isolating code. Less needed with ES modules, let/const, and block scope.",
      "exampleTranslation": "IIFE คือ function ที่ define และ execute ทันที Syntax: (function(){})() หรือ (() => {})() สร้าง private scope หลีกเลี่ยง global pollution Classic module pattern ใช้ IIFE Modern uses: async IIFE สำหรับ await ใน non-module context, isolating code ต้องการน้อยลงกับ ES modules, let/const และ block scope"
    },
    {
      "vocab": "What is the difference between shallow copy and deep copy?",
      "pronunciation": "// Shallow copy: copies first level only\nconst original = {\n  name: 'John',\n  address: {city: 'NYC'}  // nested object\n};\n\n// Shallow copy methods\nconst copy1 = {...original};  // spread\nconst copy2 = Object.assign({}, original);\nconst copy3 = Array.from(original);  // arrays\n\n// Problem with shallow\ncopy1.name = 'Jane';           // OK, independent\ncopy1.address.city = 'LA';     // Changes original too!\nconsole.log(original.address.city);  // 'LA' !\n\n// Deep copy methods\n// 1. JSON (limitations: no functions, Date, undefined)\nconst deep1 = JSON.parse(JSON.stringify(original));\n\n// 2. structuredClone (modern, handles more types)\nconst deep2 = structuredClone(original);  // ES2022\n\n// 3. Manual recursive\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (Array.isArray(obj)) return obj.map(deepClone);\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v]) => [k, deepClone(v)])\n  );\n}\n\n// 4. Libraries: lodash.cloneDeep\nimport cloneDeep from 'lodash/cloneDeep';\nconst deep3 = cloneDeep(original);\n\n// structuredClone handles:\n// Date, Map, Set, ArrayBuffer, RegExp, etc.\n// Does NOT handle: functions, DOM nodes, symbols",
      "meaning": "Shallow copy และ deep copy ต่างกันอย่างไร?",
      "example": "Shallow copy copies first level only - nested objects share references. Methods: spread, Object.assign. Deep copy copies all levels - fully independent. Methods: structuredClone (modern), JSON.parse/stringify (limited), recursive function, lodash.cloneDeep. structuredClone handles most types but not functions or DOM nodes.",
      "exampleTranslation": "Shallow copy คัดลอกแค่ level แรก - nested objects share references Methods: spread, Object.assign Deep copy คัดลอกทุก levels - เป็นอิสระทั้งหมด Methods: structuredClone (modern), JSON.parse/stringify (จำกัด), recursive function, lodash.cloneDeep structuredClone จัดการ types ส่วนใหญ่แต่ไม่รวม functions หรือ DOM nodes"
    },
    {
      "vocab": "What is strict mode?",
      "pronunciation": "// Enable strict mode\n'use strict';  // at file or function level\n\n// Changes in strict mode:\n\n// 1. No undeclared variables\nx = 10;  // ReferenceError (normally creates global)\n\n// 2. No duplicate parameters\nfunction fn(a, a) {}  // SyntaxError\n\n// 3. No duplicate object keys (in ES5)\n// const obj = {a: 1, a: 2};  // Error in ES5 strict\n\n// 4. this is undefined in functions\nfunction show() {\n  console.log(this);  // undefined (not window)\n}\n\n// 5. No octal literals\nconst oct = 010;  // SyntaxError (use 0o10)\n\n// 6. Cannot delete undeletables\ndelete Object.prototype;  // TypeError\n\n// 7. eval has own scope\neval('var x = 10');\nconsole.log(x);  // ReferenceError\n\n// 8. Reserved words\nlet implements, interface, package;  // Error\n\n// ES6 modules are automatically strict\n// Classes are automatically strict inside\n\n// Check if strict\nfunction isStrict() {\n  return !this;\n}",
      "meaning": "Strict mode คืออะไร?",
      "example": "Strict mode enables stricter parsing and error handling. 'use strict' at file/function start. Changes: no implicit globals, no duplicate params, undefined 'this' in functions, no octals, reserved keywords protected. ES modules and classes are strict by default. Catches more bugs, enables optimizations. Always use.",
      "exampleTranslation": "Strict mode enable parsing และ error handling ที่เข้มงวดขึ้น 'use strict' ที่ต้น file/function Changes: ไม่มี implicit globals, ไม่มี duplicate params, undefined 'this' ใน functions, ไม่มี octals, reserved keywords ถูกป้องกัน ES modules และ classes เป็น strict โดย default จับ bugs ได้มากขึ้น enable optimizations ใช้เสมอ"
    },
    {
      "vocab": "What are getters and setters?",
      "pronunciation": "// Getters and setters in objects\nconst user = {\n  firstName: 'John',\n  lastName: 'Doe',\n  \n  // Getter\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n  \n  // Setter\n  set fullName(value) {\n    [this.firstName, this.lastName] = value.split(' ');\n  }\n};\n\nconsole.log(user.fullName);  // 'John Doe' (looks like property)\nuser.fullName = 'Jane Smith';  // setter called\nconsole.log(user.firstName);  // 'Jane'\n\n// In classes\nclass Circle {\n  constructor(radius) {\n    this._radius = radius;\n  }\n  \n  get radius() {\n    return this._radius;\n  }\n  \n  set radius(value) {\n    if (value < 0) throw new Error('Negative radius');\n    this._radius = value;\n  }\n  \n  get area() {\n    return Math.PI * this._radius ** 2;\n  }\n}\n\n// Object.defineProperty\nObject.defineProperty(obj, 'prop', {\n  get() { return this._prop; },\n  set(value) { this._prop = value; },\n  enumerable: true,\n  configurable: true\n});\n\n// Use cases: validation, computed properties, lazy loading, logging",
      "meaning": "Getters และ setters คืออะไร?",
      "example": "Getters/setters are special methods that look like property access. get propName() returns computed value. set propName(value) intercepts assignment. Use for: validation, computed properties, encapsulation, lazy loading. Convention: prefix backing property with _ . Define with Object.defineProperty for more control.",
      "exampleTranslation": "Getters/setters คือ special methods ที่ดูเหมือน property access get propName() return computed value set propName(value) intercept assignment ใช้สำหรับ: validation, computed properties, encapsulation, lazy loading Convention: prefix backing property ด้วย _ Define ด้วย Object.defineProperty สำหรับ control มากขึ้น"
    },
    {
      "vocab": "What is the difference between for...in and for...of?",
      "pronunciation": "// for...in: iterates over enumerable property KEYS\nconst obj = {a: 1, b: 2, c: 3};\nfor (const key in obj) {\n  console.log(key);  // 'a', 'b', 'c'\n  console.log(obj[key]);  // 1, 2, 3\n}\n\n// for...of: iterates over iterable VALUES\nconst arr = ['a', 'b', 'c'];\nfor (const value of arr) {\n  console.log(value);  // 'a', 'b', 'c'\n}\n\n// for...in on array (NOT recommended)\nfor (const index in arr) {\n  console.log(index);  // '0', '1', '2' (strings!)\n}\n// Problem: includes inherited properties\n\n// for...of works with iterables:\nfor (const char of 'hello') {}  // strings\nfor (const item of [1, 2, 3]) {}  // arrays\nfor (const [key, val] of map) {}  // Map\nfor (const item of set) {}  // Set\nfor (const item of generator()) {}  // generators\n\n// Objects are NOT iterable\n// for (const item of {a: 1}) {}  // TypeError\n\n// Iterate object with for...of\nfor (const key of Object.keys(obj)) {}\nfor (const val of Object.values(obj)) {}\nfor (const [key, val] of Object.entries(obj)) {}\n\n// for...in includes inherited properties\nfunction Person() {}\nPerson.prototype.species = 'human';\nconst p = new Person();\np.name = 'John';\nfor (const key in p) console.log(key);  // name, species",
      "meaning": "for...in และ for...of ต่างกันอย่างไร?",
      "example": "for...in iterates over object property keys (strings), including inherited. for...of iterates over iterable values (arrays, strings, Map, Set, generators). Don't use for...in on arrays - use for...of or array methods. Objects aren't iterable - use Object.keys/values/entries with for...of.",
      "exampleTranslation": "for...in iterate object property keys (strings) รวม inherited for...of iterate iterable values (arrays, strings, Map, Set, generators) อย่าใช้ for...in กับ arrays - ใช้ for...of หรือ array methods Objects ไม่ iterable - ใช้ Object.keys/values/entries กับ for...of"
    },
    {
      "vocab": "What is the arguments object?",
      "pronunciation": "// arguments: array-like object in regular functions\nfunction sum() {\n  console.log(arguments);  // {0: 1, 1: 2, 2: 3, length: 3}\n  console.log(arguments[0]);  // 1\n  console.log(arguments.length);  // 3\n  \n  // Not a real array!\n  // arguments.map(x => x)  // TypeError\n  \n  // Convert to array\n  const args = Array.from(arguments);\n  const args2 = [...arguments];\n  const args3 = Array.prototype.slice.call(arguments);\n  \n  return args.reduce((a, b) => a + b, 0);\n}\n\nsum(1, 2, 3);  // 6\n\n// Arrow functions DON'T have arguments\nconst arrowSum = () => {\n  // console.log(arguments);  // ReferenceError (or outer's arguments)\n};\n\n// Use rest parameters instead (modern)\nfunction modernSum(...args) {\n  console.log(args);  // [1, 2, 3] - real array!\n  return args.reduce((a, b) => a + b, 0);\n}\n\n// arguments.callee (deprecated, banned in strict)\nfunction factorial(n) {\n  return n <= 1 ? 1 : n * arguments.callee(n - 1);  // don't use\n}\n\n// Named function expression instead\nconst factorial = function fact(n) {\n  return n <= 1 ? 1 : n * fact(n - 1);\n};",
      "meaning": "Arguments object คืออะไร?",
      "example": "arguments is array-like object containing function arguments in regular functions. Has indexes and length but no array methods. Convert with Array.from() or spread. Arrow functions don't have arguments. Modern: use rest parameters (...args) - gives real array. arguments.callee is deprecated and banned in strict mode.",
      "exampleTranslation": "arguments คือ array-like object ที่มี function arguments ใน regular functions มี indexes และ length แต่ไม่มี array methods แปลงด้วย Array.from() หรือ spread Arrow functions ไม่มี arguments Modern: ใช้ rest parameters (...args) - ให้ real array arguments.callee deprecated และถูกห้ามใน strict mode"
    },
    {
      "vocab": "What is function composition?",
      "pronunciation": "// Composition: combine simple functions into complex ones\nconst add10 = x => x + 10;\nconst multiply2 = x => x * 2;\nconst subtract5 = x => x - 5;\n\n// Manual composition\nconst result = subtract5(multiply2(add10(5)));\n// 5 → 15 → 30 → 25\n\n// Compose function (right to left)\nconst compose = (...fns) => x => \n  fns.reduceRight((acc, fn) => fn(acc), x);\n\nconst calculate = compose(subtract5, multiply2, add10);\ncalculate(5);  // 25\n\n// Pipe function (left to right, more intuitive)\nconst pipe = (...fns) => x => \n  fns.reduce((acc, fn) => fn(acc), x);\n\nconst process = pipe(\n  add10,      // 5 → 15\n  multiply2,  // 15 → 30\n  subtract5   // 30 → 25\n);\nprocess(5);  // 25\n\n// Real-world example\nconst processUser = pipe(\n  validateInput,\n  normalizeData,\n  saveToDatabase,\n  sendConfirmation\n);\n\n// With async functions\nconst pipeAsync = (...fns) => x => \n  fns.reduce(\n    (promise, fn) => promise.then(fn),\n    Promise.resolve(x)\n  );\n\nconst asyncProcess = pipeAsync(\n  fetchUser,\n  enrichData,\n  saveUser\n);",
      "meaning": "Function composition คืออะไร?",
      "example": "Composition combines simple functions into complex operations. compose(): right-to-left (math notation). pipe(): left-to-right (data flow). Each function's output becomes next function's input. Promotes: reusability, testability, readability. Works with curried functions. pipeAsync for Promise chains.",
      "exampleTranslation": "Composition รวม simple functions เป็น complex operations compose(): ขวาไปซ้าย (math notation) pipe(): ซ้ายไปขวา (data flow) output ของแต่ละ function เป็น input ของ function ถัดไป ส่งเสริม: reusability, testability, readability ใช้กับ curried functions pipeAsync สำหรับ Promise chains"
    },
    {
      "vocab": "What are tagged template literals?",
      "pronunciation": "// Tagged template: function called with template parts\nfunction tag(strings, ...values) {\n  console.log(strings);  // ['Hello ', ', you are ', ' years old']\n  console.log(values);   // ['John', 30]\n  return 'custom result';\n}\n\nconst name = 'John', age = 30;\nconst result = tag`Hello ${name}, you are ${age} years old`;\n// result = 'custom result'\n\n// Highlight example\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, str, i) => {\n    const value = values[i] !== undefined ? `<mark>${values[i]}</mark>` : '';\n    return result + str + value;\n  }, '');\n}\n\nhighlight`Search for ${query} in ${category}`;\n// 'Search for <mark>javascript</mark> in <mark>tutorials</mark>'\n\n// SQL safe query (prevent injection)\nfunction sql(strings, ...values) {\n  const escaped = values.map(v => escapeSQL(v));\n  return strings.reduce((q, s, i) => q + s + (escaped[i] || ''), '');\n}\n\nconst query = sql`SELECT * FROM users WHERE id = ${userId}`;\n\n// Common libraries using tagged templates:\n// - styled-components: styled.div`color: red;`\n// - GraphQL: gql`query { users { name } }`\n// - Lit HTML: html`<div>${content}</div>`\n\n// String.raw: escape sequences not processed\nString.raw`Line1\\nLine2`;  // 'Line1\\\\nLine2'",
      "meaning": "Tagged template literals คืออะไร?",
      "example": "Tagged templates call function with template parts. Function receives strings array and interpolated values. Can transform, validate, escape content. Use cases: syntax highlighting, SQL injection prevention, CSS-in-JS (styled-components), GraphQL queries, i18n. String.raw for raw strings without escape processing.",
      "exampleTranslation": "Tagged templates เรียก function ด้วย template parts Function รับ strings array และ interpolated values Transform, validate, escape content ได้ Use cases: syntax highlighting, SQL injection prevention, CSS-in-JS (styled-components), GraphQL queries, i18n String.raw สำหรับ raw strings โดยไม่ process escape"
    }
  ]
}
