{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "JavaScript Concepts",
    "description": "Core JavaScript concepts including types, functions, closures, async patterns, prototypes, and ES6+ features",
    "category": "Programming",
    "tags": ["javascript", "js", "web", "concepts"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What are the primitive data types in JavaScript?",
      "pronunciation": "string, number, bigint, boolean, undefined, null, symbol",
      "meaning": "JavaScript มี primitive data types อะไรบ้าง?",
      "example": "7 primitives: string, number, bigint, boolean, undefined, null, symbol. Primitives are immutable and passed by value. typeof returns type as string. Note: typeof null returns 'object' (historical bug). Everything else is an object (arrays, functions, objects).",
      "exampleTranslation": "7 primitives: string, number, bigint, boolean, undefined, null, symbol Primitives เป็น immutable และ passed by value typeof return type เป็น string หมายเหตุ: typeof null return 'object' (historical bug) ทุกอย่างอื่นเป็น object (arrays, functions, objects)"
    },
    {
      "vocab": "What is the difference between var, let, and const?",
      "pronunciation": "var (function-scoped), let (block-scoped), const (constant)",
      "meaning": "var, let และ const ต่างกันอย่างไร?",
      "example": "var: function-scoped, hoisted to undefined, can redeclare. let: block-scoped, temporal dead zone (TDZ), can reassign but not redeclare. const: block-scoped, must initialize, cannot reassign reference. const objects/arrays: reference is constant but contents can be modified. Prefer const, use let when reassignment needed, avoid var.",
      "exampleTranslation": "var: function-scoped, hoisted เป็น undefined, redeclare ได้ let: block-scoped, temporal dead zone (TDZ), reassign ได้แต่ redeclare ไม่ได้ const: block-scoped, ต้อง initialize, reassign reference ไม่ได้ const objects/arrays: reference คงที่แต่ contents แก้ไขได้ ใช้ const เป็นหลัก ใช้ let เมื่อต้อง reassign หลีกเลี่ยง var"
    },
    {
      "vocab": "What is hoisting?",
      "pronunciation": "",
      "meaning": "Hoisting คืออะไร?",
      "example": "Hoisting moves declarations to top of scope during compilation. var declarations hoisted as undefined. Function declarations fully hoisted (can call before declaration). Function expressions, let, const, classes are NOT hoisted (or have TDZ). TDZ: variable exists but cannot be accessed before declaration. Best practice: declare at top.",
      "exampleTranslation": "Hoisting ย้าย declarations ไปบนสุดของ scope ระหว่าง compilation var declarations ถูก hoist เป็น undefined Function declarations ถูก hoist ทั้งหมด (เรียกก่อน declaration ได้) Function expressions, let, const, classes ไม่ถูก hoist (หรือมี TDZ) TDZ: variable มีอยู่แต่เข้าถึงก่อน declaration ไม่ได้ Best practice: declare ที่ด้านบน"
    },
    {
      "vocab": "What is a closure?",
      "pronunciation": "function outer() { let x = 1; return function inner() { return x; } }",
      "meaning": "Closure คืออะไร?",
      "example": "Closure is a function bundled with its lexical environment (outer variables). Inner function 'closes over' outer variables and retains access even after outer function returns. Use cases: private variables, factory functions, callbacks, maintaining state. Variables are not copied - same reference is shared.",
      "exampleTranslation": "Closure คือ function ที่รวมกับ lexical environment ของมัน (outer variables) Inner function 'closes over' outer variables และเข้าถึงได้แม้หลัง outer function return แล้ว Use cases: private variables, factory functions, callbacks, maintaining state Variables ไม่ถูก copy - ใช้ reference เดียวกัน"
    },
    {
      "vocab": "What is the event loop?",
      "pronunciation": "Call Stack → Microtask Queue → Macrotask Queue",
      "meaning": "Event loop คืออะไร?",
      "example": "Event loop handles async operations in single-threaded JavaScript. Order: 1) Call stack (sync code), 2) Microtask queue (Promises, queueMicrotask), 3) Macrotask queue (setTimeout, I/O). All microtasks run before next macrotask. This is why Promise callbacks run before setTimeout(0).",
      "exampleTranslation": "Event loop จัดการ async operations ใน single-threaded JavaScript ลำดับ: 1) Call stack (sync code), 2) Microtask queue (Promises, queueMicrotask), 3) Macrotask queue (setTimeout, I/O) Microtasks ทั้งหมดรันก่อน macrotask ถัดไป นี่คือเหตุผลที่ Promise callbacks รันก่อน setTimeout(0)"
    },
    {
      "vocab": "What is the 'this' keyword?",
      "pronunciation": "",
      "meaning": "'this' keyword คืออะไร?",
      "example": "'this' is determined by how function is called, not where defined. Global: window/global. Object method: the object. Regular function: global (non-strict) or undefined (strict). Arrow function: inherits from enclosing scope. call/apply/bind: explicit binding. new keyword: new object. Arrow functions don't have own 'this'.",
      "exampleTranslation": "'this' ถูกกำหนดโดยวิธีที่ function ถูกเรียก ไม่ใช่ที่ defined Global: window/global Object method: object นั้น Regular function: global (non-strict) หรือ undefined (strict) Arrow function: สืบทอดจาก enclosing scope call/apply/bind: explicit binding new keyword: object ใหม่ Arrow functions ไม่มี 'this' ของตัวเอง"
    },
    {
      "vocab": "What is the difference between == and ===?",
      "pronunciation": "== (type coercion), === (strict equality)",
      "meaning": "== และ === ต่างกันอย่างไร?",
      "example": "== (loose equality) performs type coercion before comparing. === (strict equality) compares type and value without coercion. Always prefer === to avoid unexpected coercion bugs. Objects compared by reference, not value. NaN !== NaN, use Number.isNaN(). Object.is() is like === but handles NaN and -0 correctly.",
      "exampleTranslation": "== (loose equality) ทำ type coercion ก่อนเปรียบเทียบ === (strict equality) เปรียบเทียบ type และ value โดยไม่ coerce ใช้ === เสมอเพื่อหลีกเลี่ยง bugs จาก coercion Objects เปรียบเทียบด้วย reference ไม่ใช่ value NaN !== NaN ใช้ Number.isNaN() Object.is() เหมือน === แต่จัดการ NaN และ -0 ถูกต้อง"
    },
    {
      "vocab": "What are truthy and falsy values?",
      "pronunciation": "falsy: false, 0, '', null, undefined, NaN",
      "meaning": "Truthy และ falsy values คืออะไร?",
      "example": "8 falsy values: false, 0, -0, 0n, '', null, undefined, NaN. Everything else is truthy, including '0', 'false', [], {}, functions. Use || for falsy fallback, ?? (nullish coalescing) for null/undefined only. Convert to boolean with Boolean() or !!. Empty arrays and objects are truthy!",
      "exampleTranslation": "8 falsy values: false, 0, -0, 0n, '', null, undefined, NaN ทุกอย่างอื่นเป็น truthy รวมถึง '0', 'false', [], {}, functions ใช้ || สำหรับ falsy fallback, ?? (nullish coalescing) สำหรับ null/undefined เท่านั้น แปลงเป็น boolean ด้วย Boolean() หรือ !! Empty arrays และ objects เป็น truthy!"
    },
    {
      "vocab": "What is the difference between function declaration and expression?",
      "pronunciation": "function foo() {} vs const foo = function() {}",
      "meaning": "Function declaration และ expression ต่างกันอย่างไร?",
      "example": "Declaration: hoisted, can call before definition. Expression: assigned to variable, not hoisted. Arrow functions: concise syntax, no own 'this', 'arguments', or 'super'. Implicit return without braces. Use declarations for named functions, expressions for callbacks and when you need lexical 'this'.",
      "exampleTranslation": "Declaration: hoisted เรียกก่อน definition ได้ Expression: assign ให้ variable ไม่ถูก hoist Arrow functions: syntax กระชับ ไม่มี 'this', 'arguments', หรือ 'super' ของตัวเอง Implicit return โดยไม่ต้องมี braces ใช้ declarations สำหรับ named functions, expressions สำหรับ callbacks และเมื่อต้องการ lexical 'this'"
    },
    {
      "vocab": "What are Promises?",
      "pronunciation": "new Promise((resolve, reject) => {})",
      "meaning": "Promises คืออะไร?",
      "example": "Promise represents eventual completion or failure of async operation. States: pending, fulfilled, rejected. Use .then() for success, .catch() for errors, .finally() for cleanup. Chaining returns new promises. Static methods: Promise.all (all succeed), Promise.allSettled (all complete), Promise.race (first), Promise.any (first success).",
      "exampleTranslation": "Promise แทน eventual completion หรือ failure ของ async operation States: pending, fulfilled, rejected ใช้ .then() สำหรับ success, .catch() สำหรับ errors, .finally() สำหรับ cleanup Chaining return promises ใหม่ Static methods: Promise.all (ทั้งหมดสำเร็จ), Promise.allSettled (ทั้งหมดเสร็จ), Promise.race (ตัวแรก), Promise.any (ตัวแรกที่สำเร็จ)"
    },
    {
      "vocab": "What is async/await?",
      "pronunciation": "async function fn() { await promise }",
      "meaning": "async/await คืออะไร?",
      "example": "async/await is syntactic sugar over Promises. async function returns Promise. await pauses execution until Promise settles. Use try/catch for error handling. Common mistake: awaiting in loop (sequential). Use Promise.all for parallel execution. Top-level await available in ES modules.",
      "exampleTranslation": "async/await คือ syntactic sugar เหนือ Promises async function return Promise await หยุด execution จนกว่า Promise settles ใช้ try/catch สำหรับ error handling ข้อผิดพลาดที่พบบ่อย: awaiting ใน loop (sequential) ใช้ Promise.all สำหรับ parallel execution Top-level await มีใน ES modules"
    },
    {
      "vocab": "What is prototypal inheritance?",
      "pronunciation": "Object.create(proto), __proto__, prototype",
      "meaning": "Prototypal inheritance คืออะไร?",
      "example": "JavaScript uses prototypal inheritance - objects inherit from other objects. Every object has internal [[Prototype]] link. Property lookup walks the prototype chain. Object.create() creates object with specified prototype. Constructor functions use .prototype for shared methods. Use hasOwnProperty() to check own vs inherited properties.",
      "exampleTranslation": "JavaScript ใช้ prototypal inheritance - objects สืบทอดจาก objects อื่น ทุก object มี internal [[Prototype]] link Property lookup เดินตาม prototype chain Object.create() สร้าง object กับ prototype ที่ระบุ Constructor functions ใช้ .prototype สำหรับ shared methods ใช้ hasOwnProperty() เพื่อ check own vs inherited properties"
    },
    {
      "vocab": "What are ES6 classes?",
      "pronunciation": "class Foo extends Bar { constructor() { super() } }",
      "meaning": "ES6 classes คืออะไร?",
      "example": "ES6 classes are syntactic sugar over prototypal inheritance. Use class keyword, constructor for initialization. extends for inheritance, super to call parent. Static methods belong to class, not instances. Getters/setters for computed properties. Private fields with # prefix (ES2022). Under the hood, still uses prototypes.",
      "exampleTranslation": "ES6 classes เป็น syntactic sugar เหนือ prototypal inheritance ใช้ class keyword, constructor สำหรับ initialization extends สำหรับ inheritance, super เพื่อเรียก parent Static methods อยู่กับ class ไม่ใช่ instances Getters/setters สำหรับ computed properties Private fields ด้วย # prefix (ES2022) ภายใต้ยังคงใช้ prototypes"
    },
    {
      "vocab": "What is destructuring?",
      "pronunciation": "const {a, b} = obj; const [x, y] = arr;",
      "meaning": "Destructuring คืออะไร?",
      "example": "Destructuring extracts values from arrays/objects into variables. Array: position-based [a, b]. Object: key-based {name}. Features: default values, renaming (object), rest pattern (...), nested destructuring. Great for function parameters and module imports. Fails on null/undefined - use defaults.",
      "exampleTranslation": "Destructuring แยกค่าจาก arrays/objects เป็น variables Array: position-based [a, b] Object: key-based {name} Features: default values, renaming (object), rest pattern (...), nested destructuring ดีสำหรับ function parameters และ module imports Fail บน null/undefined - ใช้ defaults"
    },
    {
      "vocab": "What are spread and rest operators?",
      "pronunciation": "spread: [...arr], rest: function(...args)",
      "meaning": "Spread และ rest operators คืออะไร?",
      "example": "Spread (...) expands iterables/objects: array copying, merging, function arguments. Rest (...) collects elements into array: function parameters, destructuring. Same syntax, different contexts. Spread: right side of =. Rest: left side or function params. Both create shallow copies. Rest must be last parameter.",
      "exampleTranslation": "Spread (...) ขยาย iterables/objects: array copying, merging, function arguments Rest (...) รวบรวม elements เป็น array: function parameters, destructuring Syntax เดียวกัน contexts ต่างกัน Spread: ด้านขวาของ = Rest: ด้านซ้ายหรือ function params ทั้งคู่สร้าง shallow copies Rest ต้องเป็น parameter ตัวสุดท้าย"
    },
    {
      "vocab": "What are template literals?",
      "pronunciation": "`Hello ${name}`",
      "meaning": "Template literals คืออะไร?",
      "example": "Template literals use backticks (`) for strings. Features: ${expression} for interpolation, multi-line strings without \\n, nested templates. Tagged templates allow custom processing - first arg is string parts, rest are values. String.raw for raw strings without escape processing. Better than string concatenation.",
      "exampleTranslation": "Template literals ใช้ backticks (`) สำหรับ strings Features: ${expression} สำหรับ interpolation, multi-line strings โดยไม่ต้อง \\n, nested templates Tagged templates อนุญาตให้ custom processing - arg แรกเป็น string parts ที่เหลือเป็น values String.raw สำหรับ raw strings โดยไม่ process escape ดีกว่า string concatenation"
    },
    {
      "vocab": "What are Map and Set?",
      "pronunciation": "new Map(), new Set()",
      "meaning": "Map และ Set คืออะไร?",
      "example": "Map: key-value collection with any type as key (unlike Object). Maintains insertion order. Methods: set, get, has, delete, clear. Set: unique values collection. Methods: add, has, delete. Both are iterable. WeakMap/WeakSet: weak references, keys must be objects, allow garbage collection. Use Set to dedupe arrays.",
      "exampleTranslation": "Map: key-value collection ที่ key เป็น type ใดก็ได้ (ต่างจาก Object) รักษา insertion order Methods: set, get, has, delete, clear Set: unique values collection Methods: add, has, delete ทั้งคู่เป็น iterable WeakMap/WeakSet: weak references, keys ต้องเป็น objects, อนุญาต garbage collection ใช้ Set เพื่อ dedupe arrays"
    },
    {
      "vocab": "What are the common array methods?",
      "pronunciation": "map, filter, reduce, find, some, every",
      "meaning": "Array methods ที่ใช้บ่อยมีอะไรบ้าง?",
      "example": "Immutable (new array): map, filter, slice, concat, flat, flatMap. Reducing: reduce, reduceRight. Searching: find, findIndex, indexOf, includes, some, every. Mutating (modify original): push, pop, shift, unshift, splice, sort, reverse. Use immutable methods for functional programming. sort mutates - copy first if needed.",
      "exampleTranslation": "Immutable (array ใหม่): map, filter, slice, concat, flat, flatMap Reducing: reduce, reduceRight Searching: find, findIndex, indexOf, includes, some, every Mutating (แก้ไข original): push, pop, shift, unshift, splice, sort, reverse ใช้ immutable methods สำหรับ functional programming sort mutates - copy ก่อนถ้าต้องการ"
    },
    {
      "vocab": "What is optional chaining and nullish coalescing?",
      "pronunciation": "obj?.prop, value ?? default",
      "meaning": "Optional chaining และ nullish coalescing คืออะไร?",
      "example": "Optional chaining (?.) safely accesses nested properties - returns undefined if any part is null/undefined. Works with properties, methods, arrays. Nullish coalescing (??) provides default only for null/undefined, unlike || which triggers on any falsy value. Use together for safe access with defaults.",
      "exampleTranslation": "Optional chaining (?.) เข้าถึง nested properties อย่างปลอดภัย - return undefined ถ้าส่วนใดเป็น null/undefined ใช้กับ properties, methods, arrays Nullish coalescing (??) ให้ default เฉพาะ null/undefined ต่างจาก || ที่ trigger กับ falsy ใดๆ ใช้ด้วยกันสำหรับ safe access พร้อม defaults"
    },
    {
      "vocab": "What are JavaScript modules (import/export)?",
      "pronunciation": "export { x }, import { x } from './mod'",
      "meaning": "JavaScript modules (import/export) คืออะไร?",
      "example": "ES modules use import/export for code organization. Named exports: multiple per file, import with braces. Default export: one per file, import without braces. Dynamic import() returns Promise for code splitting. Modules have own scope, run in strict mode. Use .mjs extension or type='module' in HTML.",
      "exampleTranslation": "ES modules ใช้ import/export สำหรับ code organization Named exports: หลายตัวต่อ file, import ด้วย braces Default export: หนึ่งต่อ file, import โดยไม่มี braces Dynamic import() return Promise สำหรับ code splitting Modules มี scope ของตัวเอง รันใน strict mode ใช้ .mjs extension หรือ type='module' ใน HTML"
    },
    {
      "vocab": "What is the Proxy object?",
      "pronunciation": "new Proxy(target, handler)",
      "meaning": "Proxy object คืออะไร?",
      "example": "Proxy intercepts operations on target object using handler traps. Traps: get, set, has, deleteProperty, apply (functions), construct (new), etc. Use cases: validation, logging, access control, virtual properties, reactive programming. Reflect provides default behavior. Revocable proxies can be disabled.",
      "exampleTranslation": "Proxy intercept operations บน target object โดยใช้ handler traps Traps: get, set, has, deleteProperty, apply (functions), construct (new) เป็นต้น Use cases: validation, logging, access control, virtual properties, reactive programming Reflect ให้ default behavior Revocable proxies สามารถ disable ได้"
    },
    {
      "vocab": "What are generators?",
      "pronunciation": "function* gen() { yield value }",
      "meaning": "Generators คืออะไร?",
      "example": "Generators are functions that can pause execution with yield. Returns iterator with next() method. Each next() runs until yield, returning {value, done}. Can receive values via next(value). Use cases: lazy evaluation, infinite sequences, async flow control, custom iterators. Generators are iterable with for...of.",
      "exampleTranslation": "Generators เป็น functions ที่หยุด execution ด้วย yield ได้ Return iterator ที่มี next() method แต่ละ next() รันจนถึง yield return {value, done} รับค่าผ่าน next(value) ได้ Use cases: lazy evaluation, infinite sequences, async flow control, custom iterators Generators เป็น iterable ด้วย for...of"
    },
    {
      "vocab": "What is Symbol?",
      "pronunciation": "const sym = Symbol('description')",
      "meaning": "Symbol คืออะไร?",
      "example": "Symbol creates unique identifiers. Every Symbol() call returns unique value. Use as property keys for private/hidden properties - not enumerable with Object.keys(). Symbol.for() creates global symbols by key. Well-known symbols customize language behavior (Symbol.iterator, Symbol.toStringTag). Can't convert Symbol to string/number implicitly.",
      "exampleTranslation": "Symbol สร้าง unique identifiers ทุกการเรียก Symbol() return ค่า unique ใช้เป็น property keys สำหรับ private/hidden properties - ไม่ถูก enumerate ด้วย Object.keys() Symbol.for() สร้าง global symbols ด้วย key Well-known symbols customize language behavior (Symbol.iterator, Symbol.toStringTag) แปลง Symbol เป็น string/number โดยปริยายไม่ได้"
    },
    {
      "vocab": "What is the difference between call, apply, and bind?",
      "pronunciation": "fn.call(ctx, a, b), fn.apply(ctx, [a, b]), fn.bind(ctx)",
      "meaning": "call, apply และ bind ต่างกันอย่างไร?",
      "example": "All set 'this' context for function. call: invokes immediately with comma-separated args. apply: invokes immediately with args as array. bind: returns new function with bound 'this' (doesn't invoke). bind also supports partial application (pre-filling args). Use bind for callbacks and event handlers to preserve 'this'.",
      "exampleTranslation": "ทั้งหมด set 'this' context สำหรับ function call: invoke ทันทีกับ args คั่นด้วยคอมมา apply: invoke ทันทีกับ args เป็น array bind: return function ใหม่ที่ bound 'this' (ไม่ invoke) bind ยังรองรับ partial application (pre-filling args) ใช้ bind สำหรับ callbacks และ event handlers เพื่อรักษา 'this'"
    },
    {
      "vocab": "What is event bubbling and capturing?",
      "pronunciation": "capturing (down) → target → bubbling (up)",
      "meaning": "Event bubbling และ capturing คืออะไร?",
      "example": "Events propagate in 3 phases: capturing (down), target, bubbling (up). Default listeners use bubbling. Set third arg true for capturing. stopPropagation() prevents further propagation. Event delegation uses bubbling - single listener on parent handles children. Use e.target for actual clicked element, e.currentTarget for listener element.",
      "exampleTranslation": "Events propagate ใน 3 phases: capturing (ลง), target, bubbling (ขึ้น) Default listeners ใช้ bubbling Set arg ที่สามเป็น true สำหรับ capturing stopPropagation() ป้องกัน propagation ต่อไป Event delegation ใช้ bubbling - listener เดียวบน parent จัดการ children ใช้ e.target สำหรับ element ที่ถูก click, e.currentTarget สำหรับ listener element"
    },
    {
      "vocab": "What is the difference between null and undefined?",
      "pronunciation": "undefined (not assigned), null (intentional empty)",
      "meaning": "null และ undefined ต่างกันอย่างไร?",
      "example": "undefined: variable not yet assigned, missing properties, no return value. Represents 'not initialized'. null: intentional absence of value. Represents 'empty' or 'nothing'. typeof undefined = 'undefined', typeof null = 'object' (bug). null == undefined but null !== undefined. Default parameters trigger on undefined only, not null.",
      "exampleTranslation": "undefined: variable ยังไม่ถูก assign, missing properties, ไม่มี return value แทน 'not initialized' null: intentional absence of value แทน 'empty' หรือ 'nothing' typeof undefined = 'undefined', typeof null = 'object' (bug) null == undefined แต่ null !== undefined Default parameters trigger บน undefined เท่านั้น ไม่ใช่ null"
    },
    {
      "vocab": "What is JSON and how to work with it?",
      "pronunciation": "JSON.parse(string), JSON.stringify(object)",
      "meaning": "JSON คืออะไรและใช้งานอย่างไร?",
      "example": "JSON is text format for data exchange. Keys must be double-quoted, values can be string, number, boolean, null, object, array. JSON.parse() converts string to object, JSON.stringify() converts object to string. Use replacer/reviver for custom conversion. JSON.parse/stringify can deep clone simple objects but loses functions, Date, undefined.",
      "exampleTranslation": "JSON คือ text format สำหรับ data exchange Keys ต้องเป็น double-quoted, values เป็น string, number, boolean, null, object, array JSON.parse() แปลง string เป็น object, JSON.stringify() แปลง object เป็น string ใช้ replacer/reviver สำหรับ custom conversion JSON.parse/stringify deep clone simple objects ได้แต่เสีย functions, Date, undefined"
    },
    {
      "vocab": "What is the Fetch API?",
      "pronunciation": "await fetch(url, options)",
      "meaning": "Fetch API คืออะไร?",
      "example": "Fetch is Promise-based API for HTTP requests, replacing XMLHttpRequest. Returns Response object - use .json(), .text(), .blob() for body. Check response.ok for success. Set method, headers, body for different request types. Use AbortController to cancel requests. Note: Fetch doesn't reject on HTTP errors, only network failures.",
      "exampleTranslation": "Fetch คือ Promise-based API สำหรับ HTTP requests แทนที่ XMLHttpRequest Return Response object - ใช้ .json(), .text(), .blob() สำหรับ body Check response.ok สำหรับ success Set method, headers, body สำหรับ request types ต่างๆ ใช้ AbortController เพื่อ cancel requests หมายเหตุ: Fetch ไม่ reject บน HTTP errors เฉพาะ network failures"
    },
    {
      "vocab": "What is localStorage and sessionStorage?",
      "pronunciation": "localStorage.setItem(key, value)",
      "meaning": "localStorage และ sessionStorage คืออะไร?",
      "example": "Both store key-value string pairs in browser. localStorage: persists forever, shared across tabs. sessionStorage: cleared on tab close, per-tab storage. Methods: setItem, getItem, removeItem, clear. Store objects with JSON.stringify/parse. ~5-10MB limit. Storage event fires on localStorage changes from other tabs.",
      "exampleTranslation": "ทั้งคู่เก็บ key-value string pairs ใน browser localStorage: คงอยู่ตลอด shared across tabs sessionStorage: cleared เมื่อปิด tab, per-tab storage Methods: setItem, getItem, removeItem, clear เก็บ objects ด้วย JSON.stringify/parse ~5-10MB limit Storage event fire เมื่อ localStorage เปลี่ยนจาก tabs อื่น"
    },
    {
      "vocab": "What are JavaScript design patterns?",
      "pronunciation": "Module, Singleton, Factory, Observer, Decorator",
      "meaning": "JavaScript design patterns มีอะไรบ้าง?",
      "example": "Common patterns: Module (encapsulation via closures), Singleton (single instance), Factory (create objects without new), Observer/PubSub (event-driven communication), Decorator (extend functionality), Strategy (interchangeable algorithms). Modern JS uses modules for encapsulation, classes for factories, EventEmitter for observer pattern.",
      "exampleTranslation": "Patterns ที่ใช้บ่อย: Module (encapsulation ผ่าน closures), Singleton (instance เดียว), Factory (สร้าง objects โดยไม่ใช้ new), Observer/PubSub (event-driven communication), Decorator (extend functionality), Strategy (algorithms ที่สลับได้) Modern JS ใช้ modules สำหรับ encapsulation, classes สำหรับ factories, EventEmitter สำหรับ observer pattern"
    },
    {
      "vocab": "What is debounce and throttle?",
      "pronunciation": "debounce: wait for pause, throttle: rate limit",
      "meaning": "Debounce และ throttle คืออะไร?",
      "example": "Both limit function execution rate. Debounce: waits for pause in calls, executes after delay. Good for search input, resize end. Throttle: executes at most once per interval. Good for scroll, mousemove. Debounce delays until done, throttle rate-limits continuous events. Libraries: lodash.debounce, lodash.throttle.",
      "exampleTranslation": "ทั้งคู่จำกัด function execution rate Debounce: รอจนหยุดเรียก แล้ว execute หลัง delay ดีสำหรับ search input, resize end Throttle: execute อย่างมากหนึ่งครั้งต่อ interval ดีสำหรับ scroll, mousemove Debounce delay จนเสร็จ throttle rate-limit continuous events Libraries: lodash.debounce, lodash.throttle"
    },
    {
      "vocab": "What is currying?",
      "pronunciation": "const add = a => b => c => a + b + c",
      "meaning": "Currying คืออะไร?",
      "example": "Currying transforms function with multiple args into sequence of single-arg functions. f(a,b,c) becomes f(a)(b)(c). Enables partial application - fix some args and get new function. Use cases: creating specialized functions, point-free style, composition. curry() helper allows flexible calling patterns.",
      "exampleTranslation": "Currying แปลง function ที่มีหลาย args เป็น sequence ของ single-arg functions f(a,b,c) เป็น f(a)(b)(c) Enable partial application - fix บาง args และได้ function ใหม่ Use cases: สร้าง specialized functions, point-free style, composition curry() helper อนุญาตให้เรียกได้หลายแบบ"
    },
    {
      "vocab": "What are WeakMap and WeakSet?",
      "pronunciation": "new WeakMap(), new WeakSet()",
      "meaning": "WeakMap และ WeakSet คืออะไร?",
      "example": "WeakMap/WeakSet hold 'weak' references - don't prevent garbage collection. Keys must be objects. Not iterable, no size. Use cases: associate metadata without preventing GC, track processed objects, store private data. When object key is GC'd, entry is automatically removed. Essential for memory-sensitive applications.",
      "exampleTranslation": "WeakMap/WeakSet ถือ 'weak' references - ไม่ป้องกัน garbage collection Keys ต้องเป็น objects ไม่สามารถ iterate ได้ ไม่มี size Use cases: associate metadata โดยไม่ป้องกัน GC, track processed objects, store private data เมื่อ object key ถูก GC'd entry จะถูกลบอัตโนมัติ จำเป็นสำหรับ memory-sensitive applications"
    },
    {
      "vocab": "What are common JavaScript errors and how to handle them?",
      "pronunciation": "try { } catch (e) { } finally { }",
      "meaning": "JavaScript errors ที่พบบ่อยและจัดการอย่างไร?",
      "example": "Error types: SyntaxError (bad code), TypeError (wrong type operation), ReferenceError (undefined variable), RangeError (out of bounds). Use try-catch for sync, .catch() or try-catch with await for async. Create custom errors by extending Error. finally always runs. Global handlers catch unhandled errors.",
      "exampleTranslation": "Error types: SyntaxError (code ผิด), TypeError (operation ผิด type), ReferenceError (undefined variable), RangeError (out of bounds) ใช้ try-catch สำหรับ sync, .catch() หรือ try-catch กับ await สำหรับ async สร้าง custom errors โดย extending Error finally รันเสมอ Global handlers catch unhandled errors"
    },
    {
      "vocab": "What is Object.freeze, seal, and preventExtensions?",
      "pronunciation": "freeze (immutable), seal (no add/delete), preventExtensions (no add)",
      "meaning": "Object.freeze, seal และ preventExtensions คืออะไร?",
      "example": "Three levels of immutability: preventExtensions (no new props), seal (+ no delete), freeze (+ no modify). All are shallow - nested objects not affected. Use deepFreeze for full immutability. Different from const: const prevents variable reassignment, these prevent object mutation. Returns the same object.",
      "exampleTranslation": "3 ระดับของ immutability: preventExtensions (ไม่เพิ่ม props), seal (+ ไม่ delete), freeze (+ ไม่ modify) ทั้งหมดเป็น shallow - nested objects ไม่ได้รับผลกระทบ ใช้ deepFreeze สำหรับ full immutability ต่างจาก const: const ป้องกัน variable reassignment พวกนี้ป้องกัน object mutation Return object เดิม"
    },
    {
      "vocab": "What is memoization?",
      "pronunciation": "",
      "meaning": "Memoization คืออะไร?",
      "example": "Memoization caches function results based on arguments. Skips recomputation if same args seen before. Trade memory for speed. Best for: pure functions, expensive calculations, recursive algorithms (fibonacci). Use Map or object for cache. WeakMap for object args to allow GC. Clear cache if results may become stale.",
      "exampleTranslation": "Memoization cache ผลลัพธ์ของ function ตาม arguments ข้ามการคำนวณซ้ำถ้า args เดิมเคยเห็น Trade memory for speed ดีที่สุดสำหรับ: pure functions, expensive calculations, recursive algorithms (fibonacci) ใช้ Map หรือ object สำหรับ cache WeakMap สำหรับ object args เพื่ออนุญาตให้ GC Clear cache ถ้า results อาจ stale"
    },
    {
      "vocab": "What is IIFE (Immediately Invoked Function Expression)?",
      "pronunciation": "(function() { })() or (() => {})()",
      "meaning": "IIFE (Immediately Invoked Function Expression) คืออะไร?",
      "example": "IIFE is function defined and executed immediately. Syntax: (function(){})() or (() => {})(). Creates private scope, avoiding global pollution. Classic module pattern uses IIFE. Modern uses: async IIFE for await in non-module context, isolating code. Less needed with ES modules, let/const, and block scope.",
      "exampleTranslation": "IIFE คือ function ที่ define และ execute ทันที Syntax: (function(){})() หรือ (() => {})() สร้าง private scope หลีกเลี่ยง global pollution Classic module pattern ใช้ IIFE Modern uses: async IIFE สำหรับ await ใน non-module context, isolating code ต้องการน้อยลงกับ ES modules, let/const และ block scope"
    },
    {
      "vocab": "What is the difference between shallow copy and deep copy?",
      "pronunciation": "shallow: {...obj}, deep: structuredClone(obj)",
      "meaning": "Shallow copy และ deep copy ต่างกันอย่างไร?",
      "example": "Shallow copy copies first level only - nested objects share references. Methods: spread, Object.assign. Deep copy copies all levels - fully independent. Methods: structuredClone (modern), JSON.parse/stringify (limited), recursive function, lodash.cloneDeep. structuredClone handles most types but not functions or DOM nodes.",
      "exampleTranslation": "Shallow copy คัดลอกแค่ level แรก - nested objects share references Methods: spread, Object.assign Deep copy คัดลอกทุก levels - เป็นอิสระทั้งหมด Methods: structuredClone (modern), JSON.parse/stringify (จำกัด), recursive function, lodash.cloneDeep structuredClone จัดการ types ส่วนใหญ่แต่ไม่รวม functions หรือ DOM nodes"
    },
    {
      "vocab": "What is strict mode?",
      "pronunciation": "'use strict'",
      "meaning": "Strict mode คืออะไร?",
      "example": "Strict mode enables stricter parsing and error handling. 'use strict' at file/function start. Changes: no implicit globals, no duplicate params, undefined 'this' in functions, no octals, reserved keywords protected. ES modules and classes are strict by default. Catches more bugs, enables optimizations. Always use.",
      "exampleTranslation": "Strict mode enable parsing และ error handling ที่เข้มงวดขึ้น 'use strict' ที่ต้น file/function Changes: ไม่มี implicit globals, ไม่มี duplicate params, undefined 'this' ใน functions, ไม่มี octals, reserved keywords ถูกป้องกัน ES modules และ classes เป็น strict โดย default จับ bugs ได้มากขึ้น enable optimizations ใช้เสมอ"
    },
    {
      "vocab": "What are getters and setters?",
      "pronunciation": "get propName() { }, set propName(value) { }",
      "meaning": "Getters และ setters คืออะไร?",
      "example": "Getters/setters are special methods that look like property access. get propName() returns computed value. set propName(value) intercepts assignment. Use for: validation, computed properties, encapsulation, lazy loading. Convention: prefix backing property with _ . Define with Object.defineProperty for more control.",
      "exampleTranslation": "Getters/setters คือ special methods ที่ดูเหมือน property access get propName() return computed value set propName(value) intercept assignment ใช้สำหรับ: validation, computed properties, encapsulation, lazy loading Convention: prefix backing property ด้วย _ Define ด้วย Object.defineProperty สำหรับ control มากขึ้น"
    },
    {
      "vocab": "What is the difference between for...in and for...of?",
      "pronunciation": "for...in (keys), for...of (values)",
      "meaning": "for...in และ for...of ต่างกันอย่างไร?",
      "example": "for...in iterates over object property keys (strings), including inherited. for...of iterates over iterable values (arrays, strings, Map, Set, generators). Don't use for...in on arrays - use for...of or array methods. Objects aren't iterable - use Object.keys/values/entries with for...of.",
      "exampleTranslation": "for...in iterate object property keys (strings) รวม inherited for...of iterate iterable values (arrays, strings, Map, Set, generators) อย่าใช้ for...in กับ arrays - ใช้ for...of หรือ array methods Objects ไม่ iterable - ใช้ Object.keys/values/entries กับ for...of"
    },
    {
      "vocab": "What is the arguments object?",
      "pronunciation": "function fn() { console.log(arguments); }",
      "meaning": "Arguments object คืออะไร?",
      "example": "arguments is array-like object containing function arguments in regular functions. Has indexes and length but no array methods. Convert with Array.from() or spread. Arrow functions don't have arguments. Modern: use rest parameters (...args) - gives real array. arguments.callee is deprecated and banned in strict mode.",
      "exampleTranslation": "arguments คือ array-like object ที่มี function arguments ใน regular functions มี indexes และ length แต่ไม่มี array methods แปลงด้วย Array.from() หรือ spread Arrow functions ไม่มี arguments Modern: ใช้ rest parameters (...args) - ให้ real array arguments.callee deprecated และถูกห้ามใน strict mode"
    },
    {
      "vocab": "What is function composition?",
      "pronunciation": "pipe(f, g, h)(x) = h(g(f(x)))",
      "meaning": "Function composition คืออะไร?",
      "example": "Composition combines simple functions into complex operations. compose(): right-to-left (math notation). pipe(): left-to-right (data flow). Each function's output becomes next function's input. Promotes: reusability, testability, readability. Works with curried functions. pipeAsync for Promise chains.",
      "exampleTranslation": "Composition รวม simple functions เป็น complex operations compose(): ขวาไปซ้าย (math notation) pipe(): ซ้ายไปขวา (data flow) output ของแต่ละ function เป็น input ของ function ถัดไป ส่งเสริม: reusability, testability, readability ใช้กับ curried functions pipeAsync สำหรับ Promise chains"
    },
    {
      "vocab": "What are tagged template literals?",
      "pronunciation": "tag`Hello ${name}`",
      "meaning": "Tagged template literals คืออะไร?",
      "example": "Tagged templates call function with template parts. Function receives strings array and interpolated values. Can transform, validate, escape content. Use cases: syntax highlighting, SQL injection prevention, CSS-in-JS (styled-components), GraphQL queries, i18n. String.raw for raw strings without escape processing.",
      "exampleTranslation": "Tagged templates เรียก function ด้วย template parts Function รับ strings array และ interpolated values Transform, validate, escape content ได้ Use cases: syntax highlighting, SQL injection prevention, CSS-in-JS (styled-components), GraphQL queries, i18n String.raw สำหรับ raw strings โดยไม่ process escape"
    }
  ]
}
