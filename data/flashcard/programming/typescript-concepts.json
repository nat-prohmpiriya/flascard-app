{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "TypeScript Concepts",
    "description": "Core TypeScript concepts including types, generics, utility types, and advanced patterns",
    "category": "Programming",
    "tags": ["typescript", "javascript", "programming", "concepts"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What are the basic types in TypeScript?",
      "pronunciation": "// Primitives\nlet str: string = 'hello';\nlet num: number = 42;\nlet bool: boolean = true;\nlet n: null = null;\nlet u: undefined = undefined;\n\n// Arrays\nlet nums: number[] = [1, 2, 3];\nlet strs: Array<string> = ['a', 'b'];\n\n// Tuple\nlet tuple: [string, number] = ['hello', 42];\n\n// Enum\nenum Color { Red, Green, Blue }\n\n// Any, Unknown, Never, Void\nlet any: any = 'anything';\nlet unknown: unknown = 'safer any';\nfunction fail(): never { throw new Error(); }\nfunction log(): void { console.log('hi'); }",
      "meaning": "TypeScript มี basic types อะไรบ้าง?",
      "example": "TypeScript has primitives (string, number, boolean, null, undefined, symbol, bigint), arrays, tuples (fixed-length arrays with specific types), enums, and special types. 'any' opts out of type checking, 'unknown' is safer any, 'never' for impossible values, 'void' for no return.",
      "exampleTranslation": "TypeScript มี primitives (string, number, boolean, null, undefined, symbol, bigint), arrays, tuples (arrays ความยาวคงที่มี types เฉพาะ), enums และ special types 'any' ออกจาก type checking, 'unknown' คือ any ที่ปลอดภัยกว่า, 'never' สำหรับค่าที่เป็นไปไม่ได้, 'void' สำหรับไม่มี return"
    },
    {
      "vocab": "What is the difference between interface and type?",
      "pronunciation": "// Interface - extendable, for objects\ninterface User {\n  name: string;\n  age: number;\n}\n\ninterface Admin extends User {\n  role: string;\n}\n\n// Declaration merging (interface only)\ninterface User {\n  email: string;  // Added to User\n}\n\n// Type - more flexible\ntype ID = string | number;  // unions\ntype Point = { x: number; y: number };\ntype Callback = (data: string) => void;\n\n// Type intersection\ntype AdminUser = User & { role: string };\n\n// Cannot reopen type\n// type User = { phone: string };  // Error!",
      "meaning": "Interface และ type ต่างกันอย่างไร?",
      "example": "Interfaces are extendable with 'extends', support declaration merging (adding properties later), and are best for object shapes and class contracts. Types are more flexible - support unions, intersections, primitives, tuples. Types cannot be reopened. Use interface for objects, type for unions/complex types.",
      "exampleTranslation": "Interfaces extend ได้ด้วย 'extends' รองรับ declaration merging (เพิ่ม properties ทีหลัง) และดีที่สุดสำหรับ object shapes และ class contracts Types ยืดหยุ่นกว่า รองรับ unions, intersections, primitives, tuples Types เปิดใหม่ไม่ได้ ใช้ interface สำหรับ objects ใช้ type สำหรับ unions/complex types"
    },
    {
      "vocab": "What is union type?",
      "pronunciation": "// Basic union\ntype ID = string | number;\nlet id: ID = 'abc';\nid = 123;  // OK\n\n// Literal union\ntype Status = 'pending' | 'approved' | 'rejected';\nlet status: Status = 'pending';\n\n// Discriminated union\ntype Shape = \n  | { kind: 'circle'; radius: number }\n  | { kind: 'square'; side: number };\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'square':\n      return shape.side ** 2;\n  }\n}\n\n// Nullable type\ntype MaybeString = string | null | undefined;",
      "meaning": "Union type คืออะไร?",
      "example": "Union type (A | B) means the value can be either type A or type B. Use for values that can have multiple types. Literal unions create strict sets of allowed values. Discriminated unions use a common property (discriminant) to distinguish between variants - enables exhaustive type checking in switch.",
      "exampleTranslation": "Union type (A | B) หมายความว่าค่าเป็น type A หรือ type B ก็ได้ ใช้สำหรับค่าที่มีได้หลาย types Literal unions สร้าง sets ของค่าที่อนุญาตอย่างเคร่งครัด Discriminated unions ใช้ common property (discriminant) เพื่อแยกแยะระหว่าง variants ทำให้ exhaustive type checking ใน switch ได้"
    },
    {
      "vocab": "What is intersection type?",
      "pronunciation": "// Combine object types\ntype HasName = { name: string };\ntype HasAge = { age: number };\ntype Person = HasName & HasAge;\n\nconst person: Person = {\n  name: 'John',\n  age: 30\n};  // Must have both\n\n// Extend interfaces with intersection\ninterface Timestamped {\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ntype UserWithTimestamp = User & Timestamped;\n\n// Function overloading effect\ntype Fn = ((a: string) => string) & ((a: number) => number);\n\n// Never from impossible intersection\ntype Impossible = string & number;  // never",
      "meaning": "Intersection type คืออะไร?",
      "example": "Intersection type (A & B) combines multiple types - the value must satisfy ALL types. Used for mixing types together, adding properties to existing types. If types conflict (string & number), result is 'never'. Common for extending types and creating mixins.",
      "exampleTranslation": "Intersection type (A & B) รวมหลาย types เข้าด้วยกัน - ค่าต้องเป็นไปตามทุก types ใช้สำหรับผสม types เข้าด้วยกัน เพิ่ม properties ให้ existing types ถ้า types ขัดแย้งกัน (string & number) ผลลัพธ์คือ 'never' ใช้บ่อยสำหรับ extending types และสร้าง mixins"
    },
    {
      "vocab": "What is type inference?",
      "pronunciation": "// Variable inference\nlet x = 10;  // inferred as number\nlet arr = [1, 2, 3];  // number[]\nlet mixed = [1, 'a'];  // (string | number)[]\n\n// Function return inference\nfunction add(a: number, b: number) {\n  return a + b;  // return type inferred as number\n}\n\n// Object inference\nconst user = {\n  name: 'John',\n  age: 30\n};  // { name: string; age: number }\n\n// const assertion for literals\nconst status = 'active';  // type: string\nconst status2 = 'active' as const;  // type: 'active'\n\nconst config = {\n  url: '/api',\n  method: 'GET'\n} as const;  // readonly, literal types",
      "meaning": "Type inference คืออะไร?",
      "example": "TypeScript automatically infers types from values without explicit annotations. Works for variables, function returns, and object properties. 'as const' assertion creates literal types and readonly properties. Best practice: let TypeScript infer when obvious, annotate when clarity helps.",
      "exampleTranslation": "TypeScript อนุมาน types จากค่าโดยอัตโนมัติโดยไม่ต้อง annotate ชัดเจน ทำงานกับ variables, function returns และ object properties 'as const' assertion สร้าง literal types และ readonly properties Best practice: ให้ TypeScript infer เมื่อชัดเจน annotate เมื่อช่วยให้เข้าใจ"
    },
    {
      "vocab": "What are generics in TypeScript?",
      "pronunciation": "// Generic function\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nidentity<string>('hello');  // explicit\nidentity(42);  // inferred as number\n\n// Generic interface\ninterface Box<T> {\n  value: T;\n}\n\nconst stringBox: Box<string> = { value: 'hello' };\n\n// Generic class\nclass Stack<T> {\n  private items: T[] = [];\n  push(item: T) { this.items.push(item); }\n  pop(): T | undefined { return this.items.pop(); }\n}\n\n// Multiple type parameters\nfunction pair<K, V>(key: K, value: V): [K, V] {\n  return [key, value];\n}\n\n// Generic with default\ninterface Response<T = any> {\n  data: T;\n  status: number;\n}",
      "meaning": "Generics ใน TypeScript คืออะไร?",
      "example": "Generics allow creating reusable components that work with multiple types while maintaining type safety. Use <T> to declare type parameters. TypeScript can often infer the type from arguments. Generics work with functions, interfaces, classes, and type aliases. Use defaults with <T = DefaultType>.",
      "exampleTranslation": "Generics ทำให้สร้าง reusable components ที่ทำงานกับหลาย types โดยยังคง type safety ใช้ <T> เพื่อประกาศ type parameters TypeScript มักอนุมาน type จาก arguments ได้ Generics ทำงานกับ functions, interfaces, classes และ type aliases ใช้ defaults ด้วย <T = DefaultType>"
    },
    {
      "vocab": "What are generic constraints?",
      "pronunciation": "// Constraint with extends\nfunction getLength<T extends { length: number }>(arg: T): number {\n  return arg.length;\n}\n\ngetLength('hello');  // OK\ngetLength([1, 2, 3]);  // OK\ngetLength(123);  // Error: number doesn't have length\n\n// Constraint with interface\ninterface Comparable<T> {\n  compareTo(other: T): number;\n}\n\nfunction sort<T extends Comparable<T>>(arr: T[]): T[] {\n  return arr.sort((a, b) => a.compareTo(b));\n}\n\n// keyof constraint\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { name: 'John', age: 30 };\ngetProperty(user, 'name');  // string\ngetProperty(user, 'age');   // number\ngetProperty(user, 'email'); // Error!",
      "meaning": "Generic constraints คืออะไร?",
      "example": "Constraints restrict what types can be used with generics using 'extends'. Can require specific properties, methods, or use keyof for object keys. Constraints enable accessing properties that might not exist on all types. Common pattern: <K extends keyof T> for type-safe property access.",
      "exampleTranslation": "Constraints จำกัดว่า types ไหนใช้กับ generics ได้โดยใช้ 'extends' สามารถบังคับ properties, methods เฉพาะ หรือใช้ keyof สำหรับ object keys Constraints ทำให้เข้าถึง properties ที่อาจไม่มีในทุก types ได้ Pattern ที่พบบ่อย: <K extends keyof T> สำหรับ type-safe property access"
    },
    {
      "vocab": "What is keyof operator?",
      "pronunciation": "interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// keyof creates union of keys\ntype UserKeys = keyof User;  // 'id' | 'name' | 'email'\n\n// Indexed access type\ntype UserName = User['name'];  // string\ntype UserIdOrName = User['id' | 'name'];  // number | string\n\n// Type-safe object access\nfunction getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user: User = { id: 1, name: 'John', email: 'john@example.com' };\nconst name = getValue(user, 'name');  // type: string\nconst id = getValue(user, 'id');  // type: number\n\n// keyof with mapped types\ntype Readonly<T> = {\n  readonly [K in keyof T]: T[K];\n};",
      "meaning": "keyof operator คืออะไร?",
      "example": "keyof creates a union type of all property names (keys) of an object type. Use T[K] for indexed access to get the type of a property. Combined with generics, enables type-safe property access. Essential for mapped types and utility type implementations.",
      "exampleTranslation": "keyof สร้าง union type ของชื่อ properties ทั้งหมด (keys) ของ object type ใช้ T[K] สำหรับ indexed access เพื่อดึง type ของ property เมื่อรวมกับ generics ทำให้ type-safe property access ได้ จำเป็นสำหรับ mapped types และ utility type implementations"
    },
    {
      "vocab": "What is typeof operator in TypeScript?",
      "pronunciation": "// Get type from value\nconst user = {\n  name: 'John',\n  age: 30,\n  isAdmin: false\n};\n\ntype User = typeof user;\n// { name: string; age: number; isAdmin: boolean }\n\n// Get type from function\nfunction createUser(name: string, age: number) {\n  return { name, age, id: Date.now() };\n}\n\ntype CreateUserReturn = ReturnType<typeof createUser>;\n// { name: string; age: number; id: number }\n\n// Combine with keyof\nconst colors = {\n  red: '#ff0000',\n  green: '#00ff00',\n  blue: '#0000ff'\n} as const;\n\ntype ColorKey = keyof typeof colors;  // 'red' | 'green' | 'blue'\ntype ColorValue = typeof colors[ColorKey];  // '#ff0000' | '#00ff00' | '#0000ff'",
      "meaning": "typeof operator ใน TypeScript คืออะไร?",
      "example": "typeof in type context extracts the type from a value or variable. Different from JavaScript's runtime typeof. Useful for deriving types from existing values, getting function return types, and creating types from const objects. Combine with keyof for key unions from objects.",
      "exampleTranslation": "typeof ใน type context ดึง type จากค่าหรือตัวแปร ต่างจาก typeof ของ JavaScript ที่เป็น runtime มีประโยชน์สำหรับ derive types จากค่าที่มีอยู่ ดึง function return types และสร้าง types จาก const objects รวมกับ keyof สำหรับ key unions จาก objects"
    },
    {
      "vocab": "What are utility types?",
      "pronunciation": "interface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// Partial - all optional\ntype PartialUser = Partial<User>;\n// { id?: number; name?: string; ... }\n\n// Required - all required\ntype RequiredUser = Required<User>;\n\n// Readonly - all readonly\ntype ReadonlyUser = Readonly<User>;\n\n// Pick - select properties\ntype UserPreview = Pick<User, 'id' | 'name'>;\n// { id: number; name: string }\n\n// Omit - exclude properties\ntype UserWithoutEmail = Omit<User, 'email'>;\n\n// Record - object with specific key/value types\ntype UserMap = Record<string, User>;\n\n// Exclude/Extract for unions\ntype T = Exclude<'a' | 'b' | 'c', 'a'>;  // 'b' | 'c'\ntype U = Extract<'a' | 'b' | 'c', 'a' | 'b'>;  // 'a' | 'b'\n\n// NonNullable\ntype V = NonNullable<string | null>;  // string",
      "meaning": "Utility types คืออะไร?",
      "example": "TypeScript provides built-in utility types for common type transformations. Partial makes all properties optional, Required makes all required, Readonly makes immutable. Pick/Omit select or exclude properties. Record creates object types. Exclude/Extract work on union types. These reduce boilerplate significantly.",
      "exampleTranslation": "TypeScript มี built-in utility types สำหรับ type transformations ที่ใช้บ่อย Partial ทำให้ทุก properties optional, Required ทำให้ทุกตัว required, Readonly ทำให้ immutable Pick/Omit เลือกหรือ exclude properties Record สร้าง object types Exclude/Extract ทำงานกับ union types ลด boilerplate ได้มาก"
    },
    {
      "vocab": "What is Partial utility type?",
      "pronunciation": "interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// All properties become optional\ntype PartialUser = Partial<User>;\n// { id?: number; name?: string; email?: string }\n\n// Common use: update functions\nfunction updateUser(id: number, updates: Partial<User>) {\n  // Can pass any subset of User properties\n}\n\nupdateUser(1, { name: 'John' });  // OK\nupdateUser(1, { email: 'new@example.com' });  // OK\nupdateUser(1, {});  // OK\n\n// Implementation\ntype MyPartial<T> = {\n  [K in keyof T]?: T[K];\n};\n\n// Deep Partial (recursive)\ntype DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];\n};",
      "meaning": "Partial utility type คืออะไร?",
      "example": "Partial<T> makes all properties of T optional. Essential for update functions where you only want to change some properties. Implemented using mapped types with '?' modifier. For nested objects, create DeepPartial recursively. One of the most commonly used utility types.",
      "exampleTranslation": "Partial<T> ทำให้ทุก properties ของ T เป็น optional จำเป็นสำหรับ update functions ที่ต้องการเปลี่ยนแค่บาง properties Implement โดยใช้ mapped types กับ '?' modifier สำหรับ nested objects สร้าง DeepPartial แบบ recursive เป็นหนึ่งใน utility types ที่ใช้บ่อยที่สุด"
    },
    {
      "vocab": "What is Pick and Omit utility types?",
      "pronunciation": "interface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n  createdAt: Date;\n}\n\n// Pick - select specific properties\ntype PublicUser = Pick<User, 'id' | 'name' | 'email'>;\n// { id: number; name: string; email: string }\n\n// Omit - exclude specific properties\ntype UserWithoutPassword = Omit<User, 'password'>;\n// { id: number; name: string; email: string; createdAt: Date }\n\n// Combine them\ntype CreateUserInput = Omit<User, 'id' | 'createdAt'>;\n// { name: string; email: string; password: string }\n\n// Implementation\ntype MyPick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\ntype MyOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;",
      "meaning": "Pick และ Omit utility types คืออะไร?",
      "example": "Pick<T, K> creates type with only selected properties K from T. Omit<T, K> creates type excluding properties K from T. Use Pick for API responses (select public fields), Omit for form inputs (exclude auto-generated fields). Both are essential for creating derived types without duplication.",
      "exampleTranslation": "Pick<T, K> สร้าง type ที่มีเฉพาะ properties K ที่เลือกจาก T Omit<T, K> สร้าง type ที่ไม่รวม properties K จาก T ใช้ Pick สำหรับ API responses (เลือก public fields) ใช้ Omit สำหรับ form inputs (ไม่รวม auto-generated fields) ทั้งคู่จำเป็นสำหรับสร้าง derived types โดยไม่ duplicate"
    },
    {
      "vocab": "What is Record utility type?",
      "pronunciation": "// Record<Keys, Type>\ntype PageInfo = Record<string, number>;\nconst pageViews: PageInfo = {\n  home: 100,\n  about: 50,\n  contact: 25\n};\n\n// With literal union keys\ntype Role = 'admin' | 'user' | 'guest';\ntype RolePermissions = Record<Role, string[]>;\n\nconst permissions: RolePermissions = {\n  admin: ['read', 'write', 'delete'],\n  user: ['read', 'write'],\n  guest: ['read']\n};  // Must have all roles!\n\n// Object map pattern\ntype UserMap = Record<string, User>;\nconst users: UserMap = {\n  'user-1': { id: 1, name: 'John' },\n  'user-2': { id: 2, name: 'Jane' }\n};\n\n// Implementation\ntype MyRecord<K extends keyof any, T> = {\n  [P in K]: T;\n};",
      "meaning": "Record utility type คืออะไร?",
      "example": "Record<K, V> creates an object type with keys of type K and values of type V. With string keys, it's a dictionary/map. With union literal keys, all keys are required. Common for lookup tables, configuration objects, and normalized state. Alternative to index signatures with more control.",
      "exampleTranslation": "Record<K, V> สร้าง object type ที่มี keys เป็น type K และ values เป็น type V กับ string keys มันคือ dictionary/map กับ union literal keys ทุก keys ถูกบังคับ ใช้บ่อยสำหรับ lookup tables, configuration objects และ normalized state ทางเลือกแทน index signatures ที่ควบคุมได้มากกว่า"
    },
    {
      "vocab": "What are mapped types?",
      "pronunciation": "// Basic mapped type\ntype Readonly<T> = {\n  readonly [K in keyof T]: T[K];\n};\n\ntype Optional<T> = {\n  [K in keyof T]?: T[K];\n};\n\n// Remove modifiers with -\ntype Mutable<T> = {\n  -readonly [K in keyof T]: T[K];\n};\n\ntype Required<T> = {\n  [K in keyof T]-?: T[K];\n};\n\n// Transform keys with 'as'\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ninterface Person { name: string; age: number; }\ntype PersonGetters = Getters<Person>;\n// { getName: () => string; getAge: () => number }\n\n// Filter keys\ntype OnlyStrings<T> = {\n  [K in keyof T as T[K] extends string ? K : never]: T[K];\n};",
      "meaning": "Mapped types คืออะไร?",
      "example": "Mapped types transform properties of existing types. Syntax: { [K in keyof T]: NewType }. Add readonly/optional with modifiers, remove with - prefix. 'as' clause renames keys (with template literals). Filter keys by mapping to 'never'. Foundation of utility types like Partial, Required, Readonly.",
      "exampleTranslation": "Mapped types transform properties ของ existing types Syntax: { [K in keyof T]: NewType } เพิ่ม readonly/optional ด้วย modifiers ลบด้วย - prefix 'as' clause เปลี่ยนชื่อ keys (ด้วย template literals) Filter keys โดย map เป็น 'never' เป็นพื้นฐานของ utility types เช่น Partial, Required, Readonly"
    },
    {
      "vocab": "What are conditional types?",
      "pronunciation": "// Basic syntax: T extends U ? X : Y\ntype IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>;  // true\ntype B = IsString<number>;  // false\n\n// Distributive over unions\ntype ToArray<T> = T extends any ? T[] : never;\ntype C = ToArray<string | number>;  // string[] | number[]\n\n// infer keyword - extract types\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\ntype ArrayElement<T> = T extends (infer E)[] ? E : never;\n\ntype D = ReturnType<() => string>;  // string\ntype E = ArrayElement<number[]>;    // number\n\n// Nested conditionals\ntype TypeName<T> =\n  T extends string ? 'string' :\n  T extends number ? 'number' :\n  T extends boolean ? 'boolean' :\n  'object';",
      "meaning": "Conditional types คืออะไร?",
      "example": "Conditional types select types based on conditions: T extends U ? X : Y. They distribute over unions by default. 'infer' keyword extracts types from patterns (like return type from function). Enable powerful type-level programming. Used in ReturnType, Parameters, and other utility types.",
      "exampleTranslation": "Conditional types เลือก types ตาม conditions: T extends U ? X : Y มัน distribute บน unions โดย default 'infer' keyword ดึง types จาก patterns (เช่น return type จาก function) เปิดให้ type-level programming ที่มีพลัง ใช้ใน ReturnType, Parameters และ utility types อื่นๆ"
    },
    {
      "vocab": "What is the infer keyword?",
      "pronunciation": "// Extract return type\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype A = ReturnType<() => string>;  // string\ntype B = ReturnType<(x: number) => boolean>;  // boolean\n\n// Extract parameter types\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\n\ntype C = Parameters<(a: string, b: number) => void>;  // [string, number]\n\n// Extract array element\ntype Flatten<T> = T extends (infer E)[] ? E : T;\ntype D = Flatten<string[]>;  // string\ntype E = Flatten<number>;    // number\n\n// Extract promise value\ntype Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;\ntype F = Awaited<Promise<Promise<string>>>;  // string\n\n// Multiple infers\ntype First<T> = T extends [infer F, ...any[]] ? F : never;\ntype Last<T> = T extends [...any[], infer L] ? L : never;",
      "meaning": "infer keyword คืออะไร?",
      "example": "infer declares a type variable within a conditional type's extends clause, capturing part of the type being checked. Like pattern matching for types. Common uses: extracting function return/parameters, array elements, promise values, tuple elements. Only works inside conditional types.",
      "exampleTranslation": "infer ประกาศ type variable ภายใน extends clause ของ conditional type จับส่วนของ type ที่กำลัง check เหมือน pattern matching สำหรับ types ใช้บ่อย: ดึง function return/parameters, array elements, promise values, tuple elements ทำงานใน conditional types เท่านั้น"
    },
    {
      "vocab": "What are template literal types?",
      "pronunciation": "// Basic template literal type\ntype Greeting = `Hello, ${string}`;\nconst g: Greeting = 'Hello, World';  // OK\nconst h: Greeting = 'Hi, World';     // Error\n\n// With union types\ntype Color = 'red' | 'green' | 'blue';\ntype Size = 'small' | 'medium' | 'large';\ntype ColorSize = `${Color}-${Size}`;\n// 'red-small' | 'red-medium' | ... (9 combinations)\n\n// Event handlers pattern\ntype EventName = 'click' | 'focus' | 'blur';\ntype Handler = `on${Capitalize<EventName>}`;\n// 'onClick' | 'onFocus' | 'onBlur'\n\n// Intrinsic string manipulation\ntype Upper = Uppercase<'hello'>;      // 'HELLO'\ntype Lower = Lowercase<'HELLO'>;      // 'hello'\ntype Cap = Capitalize<'hello'>;       // 'Hello'\ntype Uncap = Uncapitalize<'Hello'>;   // 'hello'\n\n// Object key transformation\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};",
      "meaning": "Template literal types คืออะไร?",
      "example": "Template literal types use backtick syntax to create string literal types from combinations. They distribute over unions, creating all combinations. Built-in transformers: Uppercase, Lowercase, Capitalize, Uncapitalize. Combined with mapped types for key transformations. Powerful for type-safe string patterns.",
      "exampleTranslation": "Template literal types ใช้ backtick syntax เพื่อสร้าง string literal types จาก combinations มัน distribute บน unions สร้างทุก combinations Built-in transformers: Uppercase, Lowercase, Capitalize, Uncapitalize รวมกับ mapped types สำหรับ key transformations มีพลังสำหรับ type-safe string patterns"
    },
    {
      "vocab": "What are type guards?",
      "pronunciation": "// typeof guard\nfunction process(value: string | number) {\n  if (typeof value === 'string') {\n    return value.toUpperCase();  // TypeScript knows it's string\n  }\n  return value.toFixed(2);  // TypeScript knows it's number\n}\n\n// instanceof guard\nclass Dog { bark() {} }\nclass Cat { meow() {} }\n\nfunction speak(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\n// in operator guard\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction move(animal: Fish | Bird) {\n  if ('swim' in animal) {\n    animal.swim();\n  } else {\n    animal.fly();\n  }\n}\n\n// Custom type guard\nfunction isFish(animal: Fish | Bird): animal is Fish {\n  return 'swim' in animal;\n}",
      "meaning": "Type guards คืออะไร?",
      "example": "Type guards narrow union types within conditional blocks. Built-in guards: typeof (primitives), instanceof (classes), 'in' (property check). Custom guards use 'param is Type' return type. After a guard, TypeScript knows the specific type. Essential for working with unions safely.",
      "exampleTranslation": "Type guards narrow union types ภายใน conditional blocks Built-in guards: typeof (primitives), instanceof (classes), 'in' (property check) Custom guards ใช้ 'param is Type' return type หลังจาก guard TypeScript รู้ specific type จำเป็นสำหรับทำงานกับ unions อย่างปลอดภัย"
    },
    {
      "vocab": "What is a custom type guard (type predicate)?",
      "pronunciation": "// Type predicate: paramName is Type\ninterface Cat { meow(): void; }\ninterface Dog { bark(): void; }\n\nfunction isCat(animal: Cat | Dog): animal is Cat {\n  return 'meow' in animal;\n}\n\nfunction speak(animal: Cat | Dog) {\n  if (isCat(animal)) {\n    animal.meow();  // TypeScript knows it's Cat\n  } else {\n    animal.bark();  // TypeScript knows it's Dog\n  }\n}\n\n// With assertion function\nfunction assertIsCat(animal: Cat | Dog): asserts animal is Cat {\n  if (!('meow' in animal)) {\n    throw new Error('Not a cat!');\n  }\n}\n\nfunction handle(animal: Cat | Dog) {\n  assertIsCat(animal);\n  animal.meow();  // TypeScript knows it's Cat after assertion\n}\n\n// Filter arrays with type guards\nconst animals: (Cat | Dog)[] = [...];\nconst cats: Cat[] = animals.filter(isCat);  // Correctly typed!",
      "meaning": "Custom type guard (type predicate) คืออะไร?",
      "example": "Custom type guards use 'param is Type' syntax to tell TypeScript the result of type checking. Return true if the type matches. Assertion functions use 'asserts param is Type' and throw on failure. Type guards work with array.filter() to narrow array types. Essential for complex type narrowing.",
      "exampleTranslation": "Custom type guards ใช้ syntax 'param is Type' เพื่อบอก TypeScript ผลลัพธ์ของ type checking Return true ถ้า type ตรง Assertion functions ใช้ 'asserts param is Type' และ throw เมื่อล้มเหลว Type guards ทำงานกับ array.filter() เพื่อ narrow array types จำเป็นสำหรับ complex type narrowing"
    },
    {
      "vocab": "What is never type?",
      "pronunciation": "// Function that never returns\nfunction fail(message: string): never {\n  throw new Error(message);\n}\n\nfunction infinite(): never {\n  while (true) {}\n}\n\n// Exhaustiveness checking\ntype Shape = 'circle' | 'square' | 'triangle';\n\nfunction getArea(shape: Shape): number {\n  switch (shape) {\n    case 'circle': return Math.PI;\n    case 'square': return 1;\n    case 'triangle': return 0.5;\n    default:\n      // If we add new shape and forget case, this errors\n      const exhaustiveCheck: never = shape;\n      throw new Error(`Unknown shape: ${exhaustiveCheck}`);\n  }\n}\n\n// never in conditional types\ntype Exclude<T, U> = T extends U ? never : T;\ntype T = Exclude<'a' | 'b' | 'c', 'a'>;  // 'b' | 'c'\n\n// never is absorbed in unions\ntype U = string | never;  // string",
      "meaning": "never type คืออะไร?",
      "example": "never represents values that never occur: functions that throw or loop forever, exhausted union types after all cases handled. Used for exhaustiveness checking - assign remaining type to never, get error if cases missed. In unions, never is absorbed (string | never = string). In intersections, never dominates.",
      "exampleTranslation": "never แทนค่าที่ไม่เกิดขึ้น: functions ที่ throw หรือ loop ตลอดกาล, union types ที่หมดแล้วหลังจัดการทุก cases ใช้สำหรับ exhaustiveness checking - assign type ที่เหลือให้ never ได้ error ถ้า cases ขาด ใน unions never ถูกดูดซับ (string | never = string) ใน intersections never ครอบงำ"
    },
    {
      "vocab": "What is unknown type?",
      "pronunciation": "// unknown is type-safe any\nlet value: unknown;\n\nvalue = 'hello';\nvalue = 42;\nvalue = { x: 1 };\n\n// Cannot use unknown directly\n// value.toUpperCase();  // Error!\n// value + 1;            // Error!\n\n// Must narrow first\nif (typeof value === 'string') {\n  console.log(value.toUpperCase());  // OK\n}\n\n// Type assertion\nconst str = value as string;\n\n// Common for API responses\nasync function fetchData(): Promise<unknown> {\n  const response = await fetch('/api');\n  return response.json();\n}\n\nconst data = await fetchData();\nif (isUser(data)) {  // type guard\n  console.log(data.name);\n}\n\n// unknown in catch blocks (TS 4.4+)\ntry {\n  // ...\n} catch (error: unknown) {\n  if (error instanceof Error) {\n    console.log(error.message);\n  }\n}",
      "meaning": "unknown type คืออะไร?",
      "example": "unknown is the type-safe counterpart to any. Any value can be assigned to unknown, but you cannot use it without narrowing first (type guards, assertions). Forces explicit type checking before use. Ideal for external data (API responses, user input) where type is uncertain. Recommended over any.",
      "exampleTranslation": "unknown คือ counterpart ที่ type-safe ของ any ค่าใดก็ได้ assign ให้ unknown ได้ แต่ใช้โดยไม่ narrow ก่อนไม่ได้ (type guards, assertions) บังคับ explicit type checking ก่อนใช้ เหมาะสำหรับ external data (API responses, user input) ที่ type ไม่แน่นอน แนะนำให้ใช้แทน any"
    },
    {
      "vocab": "What is the satisfies operator?",
      "pronunciation": "// Without satisfies - loses literal types\nconst colors1: Record<string, string | number> = {\n  red: '#ff0000',\n  green: '#00ff00',\n  priority: 1\n};\ncolors1.red.toUpperCase();  // Error: might be number\n\n// With satisfies - keeps literals, validates shape\nconst colors2 = {\n  red: '#ff0000',\n  green: '#00ff00',\n  priority: 1\n} satisfies Record<string, string | number>;\n\ncolors2.red.toUpperCase();  // OK! TypeScript knows it's string\ncolors2.priority.toFixed(); // OK! TypeScript knows it's number\n\n// Validates without widening\ntype Route = { path: string; children?: Route[] };\n\nconst routes = {\n  home: { path: '/' },\n  users: { path: '/users', children: [{ path: '/users/:id' }] }\n} satisfies Record<string, Route>;\n\n// routes.home is typed as { path: string }, not Route\nroutes.home.path;  // autocomplete works!",
      "meaning": "satisfies operator คืออะไร?",
      "example": "satisfies (TS 4.9+) validates that an expression matches a type without changing its inferred type. Unlike type annotations that widen types, satisfies keeps narrow literal types while ensuring the shape is correct. Best for configuration objects where you want validation AND precise types.",
      "exampleTranslation": "satisfies (TS 4.9+) ตรวจสอบว่า expression ตรงกับ type โดยไม่เปลี่ยน inferred type ไม่เหมือน type annotations ที่ widen types satisfies เก็บ narrow literal types ไว้พร้อมรับประกันว่า shape ถูกต้อง ดีที่สุดสำหรับ configuration objects ที่ต้องการทั้ง validation และ precise types"
    },
    {
      "vocab": "What is const assertion?",
      "pronunciation": "// Without as const - types are widened\nconst config1 = {\n  url: '/api',\n  method: 'GET'\n};\n// type: { url: string; method: string }\n\n// With as const - literal and readonly\nconst config2 = {\n  url: '/api',\n  method: 'GET'\n} as const;\n// type: { readonly url: '/api'; readonly method: 'GET' }\n\n// Array as const\nconst arr1 = [1, 2, 3];        // number[]\nconst arr2 = [1, 2, 3] as const;  // readonly [1, 2, 3]\n\n// Useful for literal unions\nconst STATUSES = ['pending', 'approved', 'rejected'] as const;\ntype Status = typeof STATUSES[number];\n// 'pending' | 'approved' | 'rejected'\n\n// For function arguments\nfunction request(method: 'GET' | 'POST', url: string) {}\n\nconst params = ['GET', '/api'] as const;\nrequest(...params);  // Works! Without as const, would error",
      "meaning": "const assertion คืออะไร?",
      "example": "as const makes values deeply readonly and preserves literal types instead of widening to string/number. Arrays become readonly tuples. Objects get readonly properties with literal types. Essential for creating literal union types from arrays and ensuring immutability. Also fixes spread argument typing.",
      "exampleTranslation": "as const ทำให้ค่าเป็น deeply readonly และเก็บ literal types แทนที่จะ widen เป็น string/number Arrays กลายเป็น readonly tuples Objects ได้ readonly properties ที่มี literal types จำเป็นสำหรับสร้าง literal union types จาก arrays และรับประกัน immutability ยังแก้ spread argument typing ด้วย"
    },
    {
      "vocab": "What is declaration merging?",
      "pronunciation": "// Interface merging\ninterface User {\n  name: string;\n}\n\ninterface User {\n  age: number;\n}\n\ninterface User {\n  email: string;\n}\n\n// Result: User has all three properties\nconst user: User = {\n  name: 'John',\n  age: 30,\n  email: 'john@example.com'\n};\n\n// Module augmentation\ndeclare module 'express' {\n  interface Request {\n    user?: User;  // Add custom property to Express Request\n  }\n}\n\n// Global augmentation\ndeclare global {\n  interface Window {\n    myApp: { version: string };\n  }\n}\n\nwindow.myApp.version;  // Now typed!\n\n// Namespace merging with functions\nfunction greet(name: string): void;\nnamespace greet {\n  export const version = '1.0';\n}\n\ngreet('John');\ngreet.version;",
      "meaning": "Declaration merging คืออะไร?",
      "example": "Declaration merging combines multiple declarations with the same name into one. Interfaces with same name merge their members. Used to extend third-party library types (module augmentation), add global types, and combine namespaces with functions. Only interfaces and namespaces merge; types cannot be merged.",
      "exampleTranslation": "Declaration merging รวมหลาย declarations ที่ชื่อเดียวกันเป็นหนึ่ง Interfaces ชื่อเดียวกัน merge members ของมัน ใช้เพื่อ extend third-party library types (module augmentation) เพิ่ม global types และรวม namespaces กับ functions เฉพาะ interfaces และ namespaces ที่ merge ได้ types merge ไม่ได้"
    },
    {
      "vocab": "What are decorators in TypeScript?",
      "pronunciation": "// Enable: experimentalDecorators in tsconfig\n\n// Class decorator\nfunction Logger(constructor: Function) {\n  console.log('Logging:', constructor.name);\n}\n\n@Logger\nclass Person {\n  constructor(public name: string) {}\n}\n\n// Decorator factory (with parameters)\nfunction LoggerWithPrefix(prefix: string) {\n  return function(constructor: Function) {\n    console.log(`${prefix}: ${constructor.name}`);\n  };\n}\n\n@LoggerWithPrefix('DEBUG')\nclass Animal {}\n\n// Method decorator\nfunction Log(\n  target: any,\n  propertyKey: string,\n  descriptor: PropertyDescriptor\n) {\n  const original = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling ${propertyKey} with`, args);\n    return original.apply(this, args);\n  };\n}\n\nclass Calculator {\n  @Log\n  add(a: number, b: number) {\n    return a + b;\n  }\n}",
      "meaning": "Decorators ใน TypeScript คืออะไร?",
      "example": "Decorators are special functions that modify classes, methods, properties, or parameters. Use @ syntax above the target. Decorator factories return decorators and allow parameters. Common uses: logging, validation, dependency injection, metadata. Requires experimentalDecorators flag. TC39 Stage 3 decorators coming in TS 5.0+.",
      "exampleTranslation": "Decorators คือ functions พิเศษที่ modify classes, methods, properties หรือ parameters ใช้ @ syntax เหนือ target Decorator factories return decorators และอนุญาต parameters ใช้บ่อย: logging, validation, dependency injection, metadata ต้อง experimentalDecorators flag TC39 Stage 3 decorators กำลังมาใน TS 5.0+"
    },
    {
      "vocab": "What is function overloading?",
      "pronunciation": "// Overload signatures (declarations)\nfunction format(value: string): string;\nfunction format(value: number): string;\nfunction format(value: Date): string;\n\n// Implementation signature\nfunction format(value: string | number | Date): string {\n  if (typeof value === 'string') {\n    return value.trim();\n  } else if (typeof value === 'number') {\n    return value.toFixed(2);\n  } else {\n    return value.toISOString();\n  }\n}\n\nformat('hello');  // OK: string\nformat(42);       // OK: string\nformat(new Date()); // OK: string\nformat(true);     // Error: no matching overload\n\n// Object method overloading\nclass Calculator {\n  add(a: number, b: number): number;\n  add(a: string, b: string): string;\n  add(a: any, b: any): any {\n    return a + b;\n  }\n}\n\n// Return type based on input\nfunction getValue(key: 'name'): string;\nfunction getValue(key: 'age'): number;\nfunction getValue(key: string): unknown {\n  // implementation\n}",
      "meaning": "Function overloading คืออะไร?",
      "example": "Function overloading declares multiple signatures for the same function with different parameters or return types. Overload signatures come first (no body), implementation signature last. TypeScript matches call to most specific overload. Enables different return types based on input types.",
      "exampleTranslation": "Function overloading ประกาศหลาย signatures สำหรับ function เดียวกันที่มี parameters หรือ return types ต่างกัน Overload signatures มาก่อน (ไม่มี body) implementation signature มาสุดท้าย TypeScript match call กับ overload ที่เฉพาะเจาะจงที่สุด เปิดให้ return types ต่างกันตาม input types"
    },
    {
      "vocab": "What is strict mode in TypeScript?",
      "pronunciation": "// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,  // Enables all strict options\n    \n    // Individual strict options:\n    \"noImplicitAny\": true,        // Error on implicit any\n    \"strictNullChecks\": true,     // null/undefined not assignable\n    \"strictFunctionTypes\": true,  // Stricter function type checking\n    \"strictBindCallApply\": true,  // Check bind/call/apply\n    \"strictPropertyInitialization\": true, // Class properties must be initialized\n    \"noImplicitThis\": true,       // Error on implicit this\n    \"alwaysStrict\": true          // Emit 'use strict'\n  }\n}\n\n// strictNullChecks example\nfunction greet(name: string | null) {\n  // name.toUpperCase();  // Error: might be null\n  if (name) {\n    name.toUpperCase();  // OK after check\n  }\n}\n\n// strictPropertyInitialization\nclass User {\n  name: string;  // Error: not initialized\n  name!: string; // OK: definite assignment assertion\n  name = '';     // OK: initialized\n}",
      "meaning": "Strict mode ใน TypeScript คืออะไร?",
      "example": "strict: true enables all strict type checking options. Key options: noImplicitAny (no implicit any types), strictNullChecks (null/undefined handled explicitly), strictPropertyInitialization (class properties must be initialized). Catches more bugs at compile time. Highly recommended for new projects.",
      "exampleTranslation": "strict: true เปิดทุก strict type checking options Options สำคัญ: noImplicitAny (ไม่มี implicit any types), strictNullChecks (จัดการ null/undefined explicitly), strictPropertyInitialization (class properties ต้อง initialized) จับ bugs ได้มากขึ้นตอน compile time แนะนำอย่างยิ่งสำหรับ projects ใหม่"
    },
    {
      "vocab": "What is discriminated union?",
      "pronunciation": "// Common property (discriminant) distinguishes types\ntype Circle = {\n  kind: 'circle';  // discriminant\n  radius: number;\n};\n\ntype Square = {\n  kind: 'square';  // discriminant\n  side: number;\n};\n\ntype Triangle = {\n  kind: 'triangle';  // discriminant\n  base: number;\n  height: number;\n};\n\ntype Shape = Circle | Square | Triangle;\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      return Math.PI * shape.radius ** 2;\n    case 'square':\n      return shape.side ** 2;\n    case 'triangle':\n      return (shape.base * shape.height) / 2;\n  }\n}\n\n// TypeScript narrows type in each case\n// Exhaustiveness checking: add new shape = compile error if case missing\n\n// Real-world: Redux actions\ntype Action =\n  | { type: 'ADD_TODO'; payload: string }\n  | { type: 'TOGGLE_TODO'; payload: number }\n  | { type: 'DELETE_TODO'; payload: number };",
      "meaning": "Discriminated union คืออะไร?",
      "example": "Discriminated unions (tagged unions) use a common literal property to distinguish between union members. TypeScript narrows the type based on the discriminant in switch/if statements. Enables exhaustiveness checking - compiler errors if cases are missing. Common pattern for Redux actions, API responses, state machines.",
      "exampleTranslation": "Discriminated unions (tagged unions) ใช้ common literal property เพื่อแยกแยะระหว่าง union members TypeScript narrows type ตาม discriminant ใน switch/if statements เปิดให้ exhaustiveness checking - compiler errors ถ้า cases ขาด Pattern ที่ใช้บ่อยสำหรับ Redux actions, API responses, state machines"
    },
    {
      "vocab": "What is index signature?",
      "pronunciation": "// String index signature\ninterface StringMap {\n  [key: string]: string;\n}\n\nconst colors: StringMap = {\n  red: '#ff0000',\n  green: '#00ff00'\n};\n\ncolors.blue = '#0000ff';  // OK\ncolors.yellow = '#ffff00';  // OK\n\n// Number index signature\ninterface NumberArray {\n  [index: number]: string;\n}\n\nconst arr: NumberArray = ['a', 'b', 'c'];\n\n// Mixed with known properties\ninterface Config {\n  name: string;  // Required\n  version: number;  // Required\n  [key: string]: string | number;  // Must be compatible\n}\n\n// Readonly index signature\ninterface ReadonlyMap {\n  readonly [key: string]: number;\n}\n\n// Template literal index\ninterface EventHandlers {\n  [key: `on${string}`]: (event: Event) => void;\n}\n\nconst handlers: EventHandlers = {\n  onClick: (e) => {},\n  onSubmit: (e) => {}\n};",
      "meaning": "Index signature คืออะไร?",
      "example": "Index signatures define types for dynamic property access: [key: KeyType]: ValueType. String keys for dictionaries, number keys for array-like objects. Known properties must have compatible types. Can be readonly. Template literal patterns allow more specific key patterns. Use Record<K,V> as alternative.",
      "exampleTranslation": "Index signatures กำหนด types สำหรับ dynamic property access: [key: KeyType]: ValueType String keys สำหรับ dictionaries, number keys สำหรับ array-like objects Known properties ต้องมี compatible types เป็น readonly ได้ Template literal patterns อนุญาต key patterns ที่เฉพาะเจาะจงกว่า ใช้ Record<K,V> เป็นทางเลือก"
    },
    {
      "vocab": "What is ReturnType and Parameters utility types?",
      "pronunciation": "// ReturnType - extract return type\nfunction createUser(name: string, age: number) {\n  return { id: Date.now(), name, age };\n}\n\ntype User = ReturnType<typeof createUser>;\n// { id: number; name: string; age: number }\n\n// Parameters - extract parameter types as tuple\ntype CreateUserParams = Parameters<typeof createUser>;\n// [string, number]\n\n// Usage\nfunction wrapper(...args: Parameters<typeof createUser>) {\n  return createUser(...args);\n}\n\n// With async functions\nasync function fetchUser(id: number): Promise<User> { ... }\n\ntype FetchReturn = ReturnType<typeof fetchUser>;  // Promise<User>\ntype UnwrappedReturn = Awaited<ReturnType<typeof fetchUser>>;  // User\n\n// ConstructorParameters for classes\nclass Person {\n  constructor(public name: string, public age: number) {}\n}\n\ntype PersonParams = ConstructorParameters<typeof Person>;\n// [string, number]",
      "meaning": "ReturnType และ Parameters utility types คืออะไร?",
      "example": "ReturnType<T> extracts the return type of function type T. Parameters<T> extracts parameter types as a tuple. Use 'typeof' to get function type from value. For async functions, combine with Awaited to unwrap Promise. ConstructorParameters works for class constructors. Essential for wrapper functions and typing.",
      "exampleTranslation": "ReturnType<T> ดึง return type ของ function type T Parameters<T> ดึง parameter types เป็น tuple ใช้ 'typeof' เพื่อดึง function type จากค่า สำหรับ async functions รวมกับ Awaited เพื่อ unwrap Promise ConstructorParameters ทำงานสำหรับ class constructors จำเป็นสำหรับ wrapper functions และ typing"
    },
    {
      "vocab": "What is Awaited utility type?",
      "pronunciation": "// Unwrap Promise\ntype A = Awaited<Promise<string>>;  // string\n\n// Recursive unwrapping\ntype B = Awaited<Promise<Promise<number>>>;  // number\n\n// Non-promise passes through\ntype C = Awaited<string>;  // string\n\n// Union of promises\ntype D = Awaited<Promise<string> | Promise<number>>;  // string | number\n\n// Common use: async function return type\nasync function fetchData(): Promise<{ id: number; name: string }> {\n  const response = await fetch('/api/data');\n  return response.json();\n}\n\ntype Data = Awaited<ReturnType<typeof fetchData>>;\n// { id: number; name: string }\n\n// Promise.all typing\nasync function fetchAll() {\n  const results = await Promise.all([\n    fetchUser(),\n    fetchPosts()\n  ]);\n  // results is [User, Post[]]\n}",
      "meaning": "Awaited utility type คืออะไร?",
      "example": "Awaited<T> recursively unwraps Promise types to get the resolved value type. Handles nested promises (Promise<Promise<T>> becomes T). Non-promise types pass through unchanged. Essential for typing async/await code and getting the resolved type of async functions.",
      "exampleTranslation": "Awaited<T> unwrap Promise types แบบ recursive เพื่อดึง resolved value type จัดการ nested promises (Promise<Promise<T>> กลายเป็น T) Non-promise types ผ่านโดยไม่เปลี่ยน จำเป็นสำหรับ typing async/await code และดึง resolved type ของ async functions"
    },
    {
      "vocab": "What are Exclude and Extract utility types?",
      "pronunciation": "// Exclude<T, U> - remove U from T\ntype T1 = Exclude<'a' | 'b' | 'c', 'a'>;\n// 'b' | 'c'\n\ntype T2 = Exclude<string | number | boolean, string>;\n// number | boolean\n\n// Extract<T, U> - keep only U from T\ntype T3 = Extract<'a' | 'b' | 'c', 'a' | 'b'>;\n// 'a' | 'b'\n\ntype T4 = Extract<string | number | (() => void), Function>;\n// () => void\n\n// Practical example: event types\ntype AllEvents = 'click' | 'focus' | 'blur' | 'keydown' | 'keyup';\ntype MouseEvents = Extract<AllEvents, 'click'>;\ntype KeyboardEvents = Exclude<AllEvents, 'click' | 'focus' | 'blur'>;\n// 'keydown' | 'keyup'\n\n// Filter object keys\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n};\n\ntype StringKeys = {\n  [K in keyof User]: User[K] extends string ? K : never\n}[keyof User];\n// 'name' | 'email'",
      "meaning": "Exclude และ Extract utility types คืออะไร?",
      "example": "Exclude<T, U> removes types from T that are assignable to U. Extract<T, U> keeps only types from T that are assignable to U. Both work on union types distributively. Use for filtering union types, event types, object keys based on value types. Implemented using conditional types.",
      "exampleTranslation": "Exclude<T, U> ลบ types จาก T ที่ assignable กับ U Extract<T, U> เก็บเฉพาะ types จาก T ที่ assignable กับ U ทั้งคู่ทำงานบน union types แบบ distributive ใช้สำหรับ filter union types, event types, object keys ตาม value types Implement โดยใช้ conditional types"
    },
    {
      "vocab": "What is NonNullable utility type?",
      "pronunciation": "// Remove null and undefined from type\ntype T1 = NonNullable<string | null | undefined>;\n// string\n\ntype T2 = NonNullable<number | null>;\n// number\n\ntype T3 = NonNullable<null | undefined>;\n// never\n\n// Practical use case\ninterface User {\n  id: number;\n  name: string;\n  email: string | null;\n  phone?: string;\n}\n\nfunction sendEmail(email: NonNullable<User['email']>) {\n  // email is guaranteed to be string, not null\n  console.log(email.toLowerCase());\n}\n\nconst user: User = { id: 1, name: 'John', email: 'john@example.com' };\n\nif (user.email) {\n  sendEmail(user.email);  // OK after null check\n}\n\n// Implementation\ntype MyNonNullable<T> = T extends null | undefined ? never : T;",
      "meaning": "NonNullable utility type คืออะไร?",
      "example": "NonNullable<T> removes null and undefined from type T. Useful for function parameters that require non-nullable values after validation. Works with strictNullChecks. Implementation uses conditional types to filter out null/undefined. Common in data processing after null checks.",
      "exampleTranslation": "NonNullable<T> ลบ null และ undefined จาก type T มีประโยชน์สำหรับ function parameters ที่ต้องการ non-nullable values หลัง validation ทำงานกับ strictNullChecks Implementation ใช้ conditional types เพื่อ filter null/undefined ออก ใช้บ่อยใน data processing หลัง null checks"
    },
    {
      "vocab": "What is object type vs Object vs {}?",
      "pronunciation": "// object - non-primitive type\nlet obj: object;\nobj = {};           // OK\nobj = [];           // OK (arrays are objects)\nobj = () => {};     // OK (functions are objects)\nobj = 'string';     // Error: string is primitive\nobj = 42;           // Error: number is primitive\n\n// Object - all values with toString/valueOf\nlet val: Object;\nval = {};           // OK\nval = 'string';     // OK (has methods)\nval = 42;           // OK (has methods)\nval = null;         // Error\nval = undefined;    // Error\n\n// {} - any non-nullish value (almost anything)\nlet any: {};\nany = {};           // OK\nany = 'string';     // OK\nany = 42;           // OK\nany = null;         // Error\nany = undefined;    // Error\n\n// Recommended\nfunction process(data: Record<string, unknown>) {}  // typed object\nfunction process(data: object) {}  // any non-primitive\nfunction process(data: {}) {}  // avoid - too permissive",
      "meaning": "object vs Object vs {} ต่างกันอย่างไร?",
      "example": "object (lowercase) is non-primitive types only (objects, arrays, functions). Object (capitalized) is all values except null/undefined. {} (empty object) is any non-nullish value. Prefer: Record<string, unknown> for typed objects, object for non-primitives. Avoid {} and Object as too permissive.",
      "exampleTranslation": "object (ตัวเล็ก) คือ non-primitive types เท่านั้น (objects, arrays, functions) Object (ตัวใหญ่) คือทุกค่ายกเว้น null/undefined {} (empty object) คือค่าใดก็ได้ที่ไม่ใช่ nullish ใช้: Record<string, unknown> สำหรับ typed objects, object สำหรับ non-primitives หลีกเลี่ยง {} และ Object เพราะ permissive เกินไป"
    },
    {
      "vocab": "What is type assertion (as)?",
      "pronunciation": "// Basic assertion\nconst input = document.getElementById('email') as HTMLInputElement;\ninput.value = 'test@example.com';\n\n// Alternative syntax (not in JSX)\nconst input2 = <HTMLInputElement>document.getElementById('email');\n\n// Assertion to unknown first (for incompatible types)\nconst str = 'hello' as unknown as number;  // dangerous!\n\n// Const assertion\nconst config = { url: '/api' } as const;\n// { readonly url: '/api' }\n\n// Non-null assertion (!)\nfunction process(value: string | null) {\n  // When you're sure it's not null\n  const length = value!.length;\n}\n\n// Better: type guard instead of assertion\nfunction isHTMLInputElement(el: Element): el is HTMLInputElement {\n  return el.tagName === 'INPUT';\n}\n\nconst el = document.getElementById('email');\nif (el && isHTMLInputElement(el)) {\n  el.value = 'safe';  // properly narrowed\n}",
      "meaning": "Type assertion (as) คืออะไร?",
      "example": "Type assertions tell TypeScript to treat a value as a specific type. Use 'as Type' syntax. Only works for compatible types (use 'as unknown as Type' for incompatible). Non-null assertion (!) asserts value is not null/undefined. Prefer type guards over assertions when possible - assertions bypass type checking.",
      "exampleTranslation": "Type assertions บอก TypeScript ให้ treat ค่าเป็น specific type ใช้ syntax 'as Type' ทำงานสำหรับ compatible types เท่านั้น (ใช้ 'as unknown as Type' สำหรับ incompatible) Non-null assertion (!) assert ว่าค่าไม่ใช่ null/undefined ใช้ type guards แทน assertions เมื่อเป็นไปได้ - assertions bypass type checking"
    },
    {
      "vocab": "What is module augmentation?",
      "pronunciation": "// Augment third-party module\n// types/express.d.ts\nimport { User } from './models';\n\ndeclare module 'express' {\n  interface Request {\n    user?: User;  // Add user property to Request\n  }\n}\n\n// Now in your code\nimport express from 'express';\nconst app = express();\n\napp.use((req, res, next) => {\n  req.user = { id: 1, name: 'John' };  // TypeScript knows about user\n  next();\n});\n\n// Augment global scope\ndeclare global {\n  interface Window {\n    analytics: {\n      track: (event: string) => void;\n    };\n  }\n  \n  // Add global function\n  function myGlobalFunc(): void;\n}\n\nwindow.analytics.track('page_view');  // Typed!\n\n// Augment built-in types\ninterface Array<T> {\n  customMethod(): T[];\n}",
      "meaning": "Module augmentation คืออะไร?",
      "example": "Module augmentation extends existing module types using 'declare module'. Add properties to third-party library types (Express Request, etc). Use 'declare global' to extend global types like Window. Must be in a module file (has import/export). Essential for typing middleware, plugins, and global variables.",
      "exampleTranslation": "Module augmentation extend existing module types โดยใช้ 'declare module' เพิ่ม properties ให้ third-party library types (Express Request, etc) ใช้ 'declare global' เพื่อ extend global types เช่น Window ต้องอยู่ใน module file (มี import/export) จำเป็นสำหรับ typing middleware, plugins และ global variables"
    },
    {
      "vocab": "What is the difference between type and interface for functions?",
      "pronunciation": "// Type alias for function\ntype GreetFn = (name: string) => string;\n\n// Interface for function\ninterface GreetInterface {\n  (name: string): string;\n}\n\n// Both work the same\nconst greet1: GreetFn = (name) => `Hello, ${name}`;\nconst greet2: GreetInterface = (name) => `Hello, ${name}`;\n\n// Interface can have properties (callable with properties)\ninterface Counter {\n  (start: number): number;\n  count: number;\n  reset(): void;\n}\n\nconst counter: Counter = Object.assign(\n  (start: number) => start + counter.count++,\n  { count: 0, reset() { this.count = 0; } }\n);\n\n// Type with properties using intersection\ntype CounterType = {\n  (start: number): number;\n} & {\n  count: number;\n  reset(): void;\n};\n\n// Generic functions\ntype GenericFn<T> = (arg: T) => T;\ninterface GenericInterface<T> {\n  (arg: T): T;\n}",
      "meaning": "type และ interface สำหรับ functions ต่างกันอย่างไร?",
      "example": "Both type and interface can define function types. Type uses arrow syntax: (params) => return. Interface uses call signature: { (params): return }. Interface allows adding properties to callable objects. Type uses intersection for the same. For simple function types, type alias is cleaner.",
      "exampleTranslation": "ทั้ง type และ interface กำหนด function types ได้ Type ใช้ arrow syntax: (params) => return Interface ใช้ call signature: { (params): return } Interface อนุญาตเพิ่ม properties ให้ callable objects Type ใช้ intersection สำหรับแบบเดียวกัน สำหรับ simple function types type alias สะอาดกว่า"
    },
    {
      "vocab": "What is variance in TypeScript?",
      "pronunciation": "// Covariance - output positions (return types)\ntype Animal = { name: string };\ntype Dog = { name: string; breed: string };\n\ntype AnimalFactory = () => Animal;\ntype DogFactory = () => Dog;\n\nlet animalFactory: AnimalFactory;\nlet dogFactory: DogFactory = () => ({ name: 'Max', breed: 'Labrador' });\n\nanimalFactory = dogFactory;  // OK: Dog is subtype of Animal\n\n// Contravariance - input positions (parameters)\ntype AnimalHandler = (animal: Animal) => void;\ntype DogHandler = (dog: Dog) => void;\n\nlet animalHandler: AnimalHandler = (a) => console.log(a.name);\nlet dogHandler: DogHandler;\n\ndogHandler = animalHandler;  // OK: Animal handler can handle Dog\n// animalHandler = dogHandler;  // Error: Dog handler can't handle all Animals\n\n// Invariance - both input and output\ninterface Box<T> {\n  value: T;\n  setValue(value: T): void;\n}\n\n// strictFunctionTypes enables correct contravariance",
      "meaning": "Variance ใน TypeScript คืออะไร?",
      "example": "Variance describes how type relationships work with generics. Covariance: subtypes allowed in output positions (return types). Contravariance: supertypes allowed in input positions (parameters). Invariance: exact type required. strictFunctionTypes enables proper contravariance for function parameters.",
      "exampleTranslation": "Variance อธิบายว่า type relationships ทำงานกับ generics อย่างไร Covariance: subtypes อนุญาตใน output positions (return types) Contravariance: supertypes อนุญาตใน input positions (parameters) Invariance: ต้องการ exact type strictFunctionTypes เปิดให้ contravariance ที่ถูกต้องสำหรับ function parameters"
    },
    {
      "vocab": "What are tuple types?",
      "pronunciation": "// Basic tuple\nlet tuple: [string, number] = ['hello', 42];\n\n// Accessing elements\nconst str: string = tuple[0];\nconst num: number = tuple[1];\n\n// Destructuring\nconst [name, age]: [string, number] = ['John', 30];\n\n// Optional elements\ntype OptionalTuple = [string, number?];\nconst t1: OptionalTuple = ['hello'];\nconst t2: OptionalTuple = ['hello', 42];\n\n// Rest elements\ntype StringNumberBooleans = [string, number, ...boolean[]];\nconst t3: StringNumberBooleans = ['hello', 42, true, false, true];\n\n// Named tuple elements (documentation only)\ntype Point = [x: number, y: number, z?: number];\n\n// Readonly tuple\nconst point: readonly [number, number] = [10, 20];\n// point[0] = 5;  // Error: readonly\n\n// Function with tuple parameters\nfunction doSomething(...args: [string, number, boolean]): void {\n  const [str, num, bool] = args;\n}",
      "meaning": "Tuple types คืออะไร?",
      "example": "Tuples are fixed-length arrays with specific types at each position. Use for function returns with multiple values, coordinates, or structured data. Support optional elements (?), rest elements (...), and named elements for documentation. Readonly tuples prevent modification. Different from arrays which have uniform type.",
      "exampleTranslation": "Tuples คือ arrays ความยาวคงที่ที่มี specific types ในแต่ละตำแหน่ง ใช้สำหรับ function returns ที่มีหลายค่า coordinates หรือ structured data รองรับ optional elements (?) rest elements (...) และ named elements สำหรับ documentation Readonly tuples ป้องกันการแก้ไข ต่างจาก arrays ที่มี uniform type"
    },
    {
      "vocab": "What is ThisType utility type?",
      "pronunciation": "// ThisType<T> specifies 'this' context\ntype ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>;  // 'this' is D & M\n};\n\nfunction createObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  const data = desc.data || {} as D;\n  const methods = desc.methods || {} as M;\n  return { ...data, ...methods };\n}\n\nconst person = createObject({\n  data: {\n    name: 'John',\n    age: 30\n  },\n  methods: {\n    greet() {\n      // 'this' has type { name: string; age: number; greet(): void }\n      console.log(`Hello, I'm ${this.name}`);\n    },\n    birthday() {\n      this.age++;  // TypeScript knows about 'age'\n    }\n  }\n});\n\nperson.greet();  // \"Hello, I'm John\"\nperson.birthday();\n\n// Requires noImplicitThis in tsconfig",
      "meaning": "ThisType utility type คืออะไร?",
      "example": "ThisType<T> is a marker interface that defines the type of 'this' within an object. Doesn't transform types but provides context for 'this'. Used in factory patterns where methods need to access other properties. Requires noImplicitThis flag. Common in Vue-like APIs and object builders.",
      "exampleTranslation": "ThisType<T> คือ marker interface ที่กำหนด type ของ 'this' ภายใน object ไม่ transform types แต่ให้ context สำหรับ 'this' ใช้ใน factory patterns ที่ methods ต้องเข้าถึง properties อื่น ต้องมี noImplicitThis flag ใช้บ่อยใน Vue-like APIs และ object builders"
    },
    {
      "vocab": "What is NoInfer utility type?",
      "pronunciation": "// Without NoInfer - inference from all positions\nfunction createState<T>(initial: T, valid: T[]) {\n  return { value: initial, valid };\n}\n\nconst state1 = createState('red', ['red', 'green', 'blue']);\n// T is inferred as string (too wide)\n\n// With NoInfer - block inference from specific position\nfunction createStateFixed<T>(initial: T, valid: NoInfer<T>[]) {\n  return { value: initial, valid };\n}\n\nconst state2 = createStateFixed('red', ['red', 'green', 'blue']);\n// T is inferred as 'red' from first arg only\n// Error: Type '\"green\"' is not assignable to type '\"red\"'\n\n// Correct usage\nconst state3 = createStateFixed<'red' | 'green' | 'blue'>(\n  'red',\n  ['red', 'green', 'blue']\n);  // OK with explicit type\n\n// TypeScript 5.4+\ntype NoInfer<T> = [T][T extends any ? 0 : never];",
      "meaning": "NoInfer utility type คืออะไร?",
      "example": "NoInfer<T> (TS 5.4+) blocks type inference from that position in generic functions. Forces TypeScript to infer the type from other arguments only. Useful when one parameter should validate against a type inferred elsewhere. Prevents unwanted type widening from certain arguments.",
      "exampleTranslation": "NoInfer<T> (TS 5.4+) block type inference จากตำแหน่งนั้นใน generic functions บังคับให้ TypeScript infer type จาก arguments อื่นเท่านั้น มีประโยชน์เมื่อ parameter หนึ่งควร validate กับ type ที่ infer จากที่อื่น ป้องกัน unwanted type widening จากบาง arguments"
    }
  ]
}
