{
  "version": "2.0",
  "exportedAt": "2024-12-28T12:00:00.000Z",
  "deck": {
    "name": "TypeScript Concepts",
    "description": "Core TypeScript concepts including types, generics, utility types, and advanced patterns",
    "category": "Programming",
    "tags": ["typescript", "javascript", "programming", "concepts"],
    "sourceLang": "en",
    "targetLang": "th"
  },
  "cards": [
    {
      "vocab": "What are the basic types in TypeScript?",
      "pronunciation": "string, number, boolean, null, undefined, any, unknown, never, void",
      "meaning": "TypeScript มี basic types อะไรบ้าง?",
      "example": "TypeScript has primitives (string, number, boolean, null, undefined, symbol, bigint), arrays, tuples (fixed-length arrays with specific types), enums, and special types. 'any' opts out of type checking, 'unknown' is safer any, 'never' for impossible values, 'void' for no return.",
      "exampleTranslation": "TypeScript มี primitives (string, number, boolean, null, undefined, symbol, bigint), arrays, tuples (arrays ความยาวคงที่มี types เฉพาะ), enums และ special types 'any' ออกจาก type checking, 'unknown' คือ any ที่ปลอดภัยกว่า, 'never' สำหรับค่าที่เป็นไปไม่ได้, 'void' สำหรับไม่มี return"
    },
    {
      "vocab": "What is the difference between interface and type?",
      "pronunciation": "interface User { } vs type User = { }",
      "meaning": "Interface และ type ต่างกันอย่างไร?",
      "example": "Interfaces are extendable with 'extends', support declaration merging (adding properties later), and are best for object shapes and class contracts. Types are more flexible - support unions, intersections, primitives, tuples. Types cannot be reopened. Use interface for objects, type for unions/complex types.",
      "exampleTranslation": "Interfaces extend ได้ด้วย 'extends' รองรับ declaration merging (เพิ่ม properties ทีหลัง) และดีที่สุดสำหรับ object shapes และ class contracts Types ยืดหยุ่นกว่า รองรับ unions, intersections, primitives, tuples Types เปิดใหม่ไม่ได้ ใช้ interface สำหรับ objects ใช้ type สำหรับ unions/complex types"
    },
    {
      "vocab": "What is union type?",
      "pronunciation": "type ID = string | number",
      "meaning": "Union type คืออะไร?",
      "example": "Union type (A | B) means the value can be either type A or type B. Use for values that can have multiple types. Literal unions create strict sets of allowed values. Discriminated unions use a common property (discriminant) to distinguish between variants - enables exhaustive type checking in switch.",
      "exampleTranslation": "Union type (A | B) หมายความว่าค่าเป็น type A หรือ type B ก็ได้ ใช้สำหรับค่าที่มีได้หลาย types Literal unions สร้าง sets ของค่าที่อนุญาตอย่างเคร่งครัด Discriminated unions ใช้ common property (discriminant) เพื่อแยกแยะระหว่าง variants ทำให้ exhaustive type checking ใน switch ได้"
    },
    {
      "vocab": "What is intersection type?",
      "pronunciation": "type Person = HasName & HasAge",
      "meaning": "Intersection type คืออะไร?",
      "example": "Intersection type (A & B) combines multiple types - the value must satisfy ALL types. Used for mixing types together, adding properties to existing types. If types conflict (string & number), result is 'never'. Common for extending types and creating mixins.",
      "exampleTranslation": "Intersection type (A & B) รวมหลาย types เข้าด้วยกัน - ค่าต้องเป็นไปตามทุก types ใช้สำหรับผสม types เข้าด้วยกัน เพิ่ม properties ให้ existing types ถ้า types ขัดแย้งกัน (string & number) ผลลัพธ์คือ 'never' ใช้บ่อยสำหรับ extending types และสร้าง mixins"
    },
    {
      "vocab": "What is type inference?",
      "pronunciation": "let x = 10; // inferred as number",
      "meaning": "Type inference คืออะไร?",
      "example": "TypeScript automatically infers types from values without explicit annotations. Works for variables, function returns, and object properties. 'as const' assertion creates literal types and readonly properties. Best practice: let TypeScript infer when obvious, annotate when clarity helps.",
      "exampleTranslation": "TypeScript อนุมาน types จากค่าโดยอัตโนมัติโดยไม่ต้อง annotate ชัดเจน ทำงานกับ variables, function returns และ object properties 'as const' assertion สร้าง literal types และ readonly properties Best practice: ให้ TypeScript infer เมื่อชัดเจน annotate เมื่อช่วยให้เข้าใจ"
    },
    {
      "vocab": "What are generics in TypeScript?",
      "pronunciation": "function identity<T>(arg: T): T { return arg; }",
      "meaning": "Generics ใน TypeScript คืออะไร?",
      "example": "Generics allow creating reusable components that work with multiple types while maintaining type safety. Use <T> to declare type parameters. TypeScript can often infer the type from arguments. Generics work with functions, interfaces, classes, and type aliases. Use defaults with <T = DefaultType>.",
      "exampleTranslation": "Generics ทำให้สร้าง reusable components ที่ทำงานกับหลาย types โดยยังคง type safety ใช้ <T> เพื่อประกาศ type parameters TypeScript มักอนุมาน type จาก arguments ได้ Generics ทำงานกับ functions, interfaces, classes และ type aliases ใช้ defaults ด้วย <T = DefaultType>"
    },
    {
      "vocab": "What are generic constraints?",
      "pronunciation": "<T extends { length: number }>",
      "meaning": "Generic constraints คืออะไร?",
      "example": "Constraints restrict what types can be used with generics using 'extends'. Can require specific properties, methods, or use keyof for object keys. Constraints enable accessing properties that might not exist on all types. Common pattern: <K extends keyof T> for type-safe property access.",
      "exampleTranslation": "Constraints จำกัดว่า types ไหนใช้กับ generics ได้โดยใช้ 'extends' สามารถบังคับ properties, methods เฉพาะ หรือใช้ keyof สำหรับ object keys Constraints ทำให้เข้าถึง properties ที่อาจไม่มีในทุก types ได้ Pattern ที่พบบ่อย: <K extends keyof T> สำหรับ type-safe property access"
    },
    {
      "vocab": "What is keyof operator?",
      "pronunciation": "type UserKeys = keyof User; // 'id' | 'name' | 'email'",
      "meaning": "keyof operator คืออะไร?",
      "example": "keyof creates a union type of all property names (keys) of an object type. Use T[K] for indexed access to get the type of a property. Combined with generics, enables type-safe property access. Essential for mapped types and utility type implementations.",
      "exampleTranslation": "keyof สร้าง union type ของชื่อ properties ทั้งหมด (keys) ของ object type ใช้ T[K] สำหรับ indexed access เพื่อดึง type ของ property เมื่อรวมกับ generics ทำให้ type-safe property access ได้ จำเป็นสำหรับ mapped types และ utility type implementations"
    },
    {
      "vocab": "What is typeof operator in TypeScript?",
      "pronunciation": "type User = typeof user;",
      "meaning": "typeof operator ใน TypeScript คืออะไร?",
      "example": "typeof in type context extracts the type from a value or variable. Different from JavaScript's runtime typeof. Useful for deriving types from existing values, getting function return types, and creating types from const objects. Combine with keyof for key unions from objects.",
      "exampleTranslation": "typeof ใน type context ดึง type จากค่าหรือตัวแปร ต่างจาก typeof ของ JavaScript ที่เป็น runtime มีประโยชน์สำหรับ derive types จากค่าที่มีอยู่ ดึง function return types และสร้าง types จาก const objects รวมกับ keyof สำหรับ key unions จาก objects"
    },
    {
      "vocab": "What are utility types?",
      "pronunciation": "Partial, Required, Readonly, Pick, Omit, Record",
      "meaning": "Utility types คืออะไร?",
      "example": "TypeScript provides built-in utility types for common type transformations. Partial makes all properties optional, Required makes all required, Readonly makes immutable. Pick/Omit select or exclude properties. Record creates object types. Exclude/Extract work on union types. These reduce boilerplate significantly.",
      "exampleTranslation": "TypeScript มี built-in utility types สำหรับ type transformations ที่ใช้บ่อย Partial ทำให้ทุก properties optional, Required ทำให้ทุกตัว required, Readonly ทำให้ immutable Pick/Omit เลือกหรือ exclude properties Record สร้าง object types Exclude/Extract ทำงานกับ union types ลด boilerplate ได้มาก"
    },
    {
      "vocab": "What is Partial utility type?",
      "pronunciation": "Partial<User> // all properties optional",
      "meaning": "Partial utility type คืออะไร?",
      "example": "Partial<T> makes all properties of T optional. Essential for update functions where you only want to change some properties. Implemented using mapped types with '?' modifier. For nested objects, create DeepPartial recursively. One of the most commonly used utility types.",
      "exampleTranslation": "Partial<T> ทำให้ทุก properties ของ T เป็น optional จำเป็นสำหรับ update functions ที่ต้องการเปลี่ยนแค่บาง properties Implement โดยใช้ mapped types กับ '?' modifier สำหรับ nested objects สร้าง DeepPartial แบบ recursive เป็นหนึ่งใน utility types ที่ใช้บ่อยที่สุด"
    },
    {
      "vocab": "What is Pick and Omit utility types?",
      "pronunciation": "Pick<User, 'id' | 'name'>, Omit<User, 'password'>",
      "meaning": "Pick และ Omit utility types คืออะไร?",
      "example": "Pick<T, K> creates type with only selected properties K from T. Omit<T, K> creates type excluding properties K from T. Use Pick for API responses (select public fields), Omit for form inputs (exclude auto-generated fields). Both are essential for creating derived types without duplication.",
      "exampleTranslation": "Pick<T, K> สร้าง type ที่มีเฉพาะ properties K ที่เลือกจาก T Omit<T, K> สร้าง type ที่ไม่รวม properties K จาก T ใช้ Pick สำหรับ API responses (เลือก public fields) ใช้ Omit สำหรับ form inputs (ไม่รวม auto-generated fields) ทั้งคู่จำเป็นสำหรับสร้าง derived types โดยไม่ duplicate"
    },
    {
      "vocab": "What is Record utility type?",
      "pronunciation": "Record<string, User> // { [key: string]: User }",
      "meaning": "Record utility type คืออะไร?",
      "example": "Record<K, V> creates an object type with keys of type K and values of type V. With string keys, it's a dictionary/map. With union literal keys, all keys are required. Common for lookup tables, configuration objects, and normalized state. Alternative to index signatures with more control.",
      "exampleTranslation": "Record<K, V> สร้าง object type ที่มี keys เป็น type K และ values เป็น type V กับ string keys มันคือ dictionary/map กับ union literal keys ทุก keys ถูกบังคับ ใช้บ่อยสำหรับ lookup tables, configuration objects และ normalized state ทางเลือกแทน index signatures ที่ควบคุมได้มากกว่า"
    },
    {
      "vocab": "What are mapped types?",
      "pronunciation": "{ [K in keyof T]: T[K] }",
      "meaning": "Mapped types คืออะไร?",
      "example": "Mapped types transform properties of existing types. Syntax: { [K in keyof T]: NewType }. Add readonly/optional with modifiers, remove with - prefix. 'as' clause renames keys (with template literals). Filter keys by mapping to 'never'. Foundation of utility types like Partial, Required, Readonly.",
      "exampleTranslation": "Mapped types transform properties ของ existing types Syntax: { [K in keyof T]: NewType } เพิ่ม readonly/optional ด้วย modifiers ลบด้วย - prefix 'as' clause เปลี่ยนชื่อ keys (ด้วย template literals) Filter keys โดย map เป็น 'never' เป็นพื้นฐานของ utility types เช่น Partial, Required, Readonly"
    },
    {
      "vocab": "What are conditional types?",
      "pronunciation": "T extends U ? X : Y",
      "meaning": "Conditional types คืออะไร?",
      "example": "Conditional types select types based on conditions: T extends U ? X : Y. They distribute over unions by default. 'infer' keyword extracts types from patterns (like return type from function). Enable powerful type-level programming. Used in ReturnType, Parameters, and other utility types.",
      "exampleTranslation": "Conditional types เลือก types ตาม conditions: T extends U ? X : Y มัน distribute บน unions โดย default 'infer' keyword ดึง types จาก patterns (เช่น return type จาก function) เปิดให้ type-level programming ที่มีพลัง ใช้ใน ReturnType, Parameters และ utility types อื่นๆ"
    },
    {
      "vocab": "What is the infer keyword?",
      "pronunciation": "T extends (...args: any[]) => infer R ? R : never",
      "meaning": "infer keyword คืออะไร?",
      "example": "infer declares a type variable within a conditional type's extends clause, capturing part of the type being checked. Like pattern matching for types. Common uses: extracting function return/parameters, array elements, promise values, tuple elements. Only works inside conditional types.",
      "exampleTranslation": "infer ประกาศ type variable ภายใน extends clause ของ conditional type จับส่วนของ type ที่กำลัง check เหมือน pattern matching สำหรับ types ใช้บ่อย: ดึง function return/parameters, array elements, promise values, tuple elements ทำงานใน conditional types เท่านั้น"
    },
    {
      "vocab": "What are template literal types?",
      "pronunciation": "type Event = `on${Capitalize<EventName>}`",
      "meaning": "Template literal types คืออะไร?",
      "example": "Template literal types use backtick syntax to create string literal types from combinations. They distribute over unions, creating all combinations. Built-in transformers: Uppercase, Lowercase, Capitalize, Uncapitalize. Combined with mapped types for key transformations. Powerful for type-safe string patterns.",
      "exampleTranslation": "Template literal types ใช้ backtick syntax เพื่อสร้าง string literal types จาก combinations มัน distribute บน unions สร้างทุก combinations Built-in transformers: Uppercase, Lowercase, Capitalize, Uncapitalize รวมกับ mapped types สำหรับ key transformations มีพลังสำหรับ type-safe string patterns"
    },
    {
      "vocab": "What are type guards?",
      "pronunciation": "typeof, instanceof, 'in', custom guards",
      "meaning": "Type guards คืออะไร?",
      "example": "Type guards narrow union types within conditional blocks. Built-in guards: typeof (primitives), instanceof (classes), 'in' (property check). Custom guards use 'param is Type' return type. After a guard, TypeScript knows the specific type. Essential for working with unions safely.",
      "exampleTranslation": "Type guards narrow union types ภายใน conditional blocks Built-in guards: typeof (primitives), instanceof (classes), 'in' (property check) Custom guards ใช้ 'param is Type' return type หลังจาก guard TypeScript รู้ specific type จำเป็นสำหรับทำงานกับ unions อย่างปลอดภัย"
    },
    {
      "vocab": "What is a custom type guard (type predicate)?",
      "pronunciation": "function isCat(animal): animal is Cat { }",
      "meaning": "Custom type guard (type predicate) คืออะไร?",
      "example": "Custom type guards use 'param is Type' syntax to tell TypeScript the result of type checking. Return true if the type matches. Assertion functions use 'asserts param is Type' and throw on failure. Type guards work with array.filter() to narrow array types. Essential for complex type narrowing.",
      "exampleTranslation": "Custom type guards ใช้ syntax 'param is Type' เพื่อบอก TypeScript ผลลัพธ์ของ type checking Return true ถ้า type ตรง Assertion functions ใช้ 'asserts param is Type' และ throw เมื่อล้มเหลว Type guards ทำงานกับ array.filter() เพื่อ narrow array types จำเป็นสำหรับ complex type narrowing"
    },
    {
      "vocab": "What is never type?",
      "pronunciation": "function fail(): never { throw new Error(); }",
      "meaning": "never type คืออะไร?",
      "example": "never represents values that never occur: functions that throw or loop forever, exhausted union types after all cases handled. Used for exhaustiveness checking - assign remaining type to never, get error if cases missed. In unions, never is absorbed (string | never = string). In intersections, never dominates.",
      "exampleTranslation": "never แทนค่าที่ไม่เกิดขึ้น: functions ที่ throw หรือ loop ตลอดกาล, union types ที่หมดแล้วหลังจัดการทุก cases ใช้สำหรับ exhaustiveness checking - assign type ที่เหลือให้ never ได้ error ถ้า cases ขาด ใน unions never ถูกดูดซับ (string | never = string) ใน intersections never ครอบงำ"
    },
    {
      "vocab": "What is unknown type?",
      "pronunciation": "let value: unknown = fetchData();",
      "meaning": "unknown type คืออะไร?",
      "example": "unknown is the type-safe counterpart to any. Any value can be assigned to unknown, but you cannot use it without narrowing first (type guards, assertions). Forces explicit type checking before use. Ideal for external data (API responses, user input) where type is uncertain. Recommended over any.",
      "exampleTranslation": "unknown คือ counterpart ที่ type-safe ของ any ค่าใดก็ได้ assign ให้ unknown ได้ แต่ใช้โดยไม่ narrow ก่อนไม่ได้ (type guards, assertions) บังคับ explicit type checking ก่อนใช้ เหมาะสำหรับ external data (API responses, user input) ที่ type ไม่แน่นอน แนะนำให้ใช้แทน any"
    },
    {
      "vocab": "What is the satisfies operator?",
      "pronunciation": "const config = { } satisfies ConfigType;",
      "meaning": "satisfies operator คืออะไร?",
      "example": "satisfies (TS 4.9+) validates that an expression matches a type without changing its inferred type. Unlike type annotations that widen types, satisfies keeps narrow literal types while ensuring the shape is correct. Best for configuration objects where you want validation AND precise types.",
      "exampleTranslation": "satisfies (TS 4.9+) ตรวจสอบว่า expression ตรงกับ type โดยไม่เปลี่ยน inferred type ไม่เหมือน type annotations ที่ widen types satisfies เก็บ narrow literal types ไว้พร้อมรับประกันว่า shape ถูกต้อง ดีที่สุดสำหรับ configuration objects ที่ต้องการทั้ง validation และ precise types"
    },
    {
      "vocab": "What is const assertion?",
      "pronunciation": "const config = { url: '/api' } as const;",
      "meaning": "const assertion คืออะไร?",
      "example": "as const makes values deeply readonly and preserves literal types instead of widening to string/number. Arrays become readonly tuples. Objects get readonly properties with literal types. Essential for creating literal union types from arrays and ensuring immutability. Also fixes spread argument typing.",
      "exampleTranslation": "as const ทำให้ค่าเป็น deeply readonly และเก็บ literal types แทนที่จะ widen เป็น string/number Arrays กลายเป็น readonly tuples Objects ได้ readonly properties ที่มี literal types จำเป็นสำหรับสร้าง literal union types จาก arrays และรับประกัน immutability ยังแก้ spread argument typing ด้วย"
    },
    {
      "vocab": "What is declaration merging?",
      "pronunciation": "interface User { } interface User { } // merged",
      "meaning": "Declaration merging คืออะไร?",
      "example": "Declaration merging combines multiple declarations with the same name into one. Interfaces with same name merge their members. Used to extend third-party library types (module augmentation), add global types, and combine namespaces with functions. Only interfaces and namespaces merge; types cannot be merged.",
      "exampleTranslation": "Declaration merging รวมหลาย declarations ที่ชื่อเดียวกันเป็นหนึ่ง Interfaces ชื่อเดียวกัน merge members ของมัน ใช้เพื่อ extend third-party library types (module augmentation) เพิ่ม global types และรวม namespaces กับ functions เฉพาะ interfaces และ namespaces ที่ merge ได้ types merge ไม่ได้"
    },
    {
      "vocab": "What are decorators in TypeScript?",
      "pronunciation": "@Logger class Person { }",
      "meaning": "Decorators ใน TypeScript คืออะไร?",
      "example": "Decorators are special functions that modify classes, methods, properties, or parameters. Use @ syntax above the target. Decorator factories return decorators and allow parameters. Common uses: logging, validation, dependency injection, metadata. Requires experimentalDecorators flag. TC39 Stage 3 decorators coming in TS 5.0+.",
      "exampleTranslation": "Decorators คือ functions พิเศษที่ modify classes, methods, properties หรือ parameters ใช้ @ syntax เหนือ target Decorator factories return decorators และอนุญาต parameters ใช้บ่อย: logging, validation, dependency injection, metadata ต้อง experimentalDecorators flag TC39 Stage 3 decorators กำลังมาใน TS 5.0+"
    },
    {
      "vocab": "What is function overloading?",
      "pronunciation": "function fn(a: string): string; function fn(a: number): number;",
      "meaning": "Function overloading คืออะไร?",
      "example": "Function overloading declares multiple signatures for the same function with different parameters or return types. Overload signatures come first (no body), implementation signature last. TypeScript matches call to most specific overload. Enables different return types based on input types.",
      "exampleTranslation": "Function overloading ประกาศหลาย signatures สำหรับ function เดียวกันที่มี parameters หรือ return types ต่างกัน Overload signatures มาก่อน (ไม่มี body) implementation signature มาสุดท้าย TypeScript match call กับ overload ที่เฉพาะเจาะจงที่สุด เปิดให้ return types ต่างกันตาม input types"
    },
    {
      "vocab": "What is strict mode in TypeScript?",
      "pronunciation": "\"strict\": true in tsconfig.json",
      "meaning": "Strict mode ใน TypeScript คืออะไร?",
      "example": "strict: true enables all strict type checking options. Key options: noImplicitAny (no implicit any types), strictNullChecks (null/undefined handled explicitly), strictPropertyInitialization (class properties must be initialized). Catches more bugs at compile time. Highly recommended for new projects.",
      "exampleTranslation": "strict: true เปิดทุก strict type checking options Options สำคัญ: noImplicitAny (ไม่มี implicit any types), strictNullChecks (จัดการ null/undefined explicitly), strictPropertyInitialization (class properties ต้อง initialized) จับ bugs ได้มากขึ้นตอน compile time แนะนำอย่างยิ่งสำหรับ projects ใหม่"
    },
    {
      "vocab": "What is discriminated union?",
      "pronunciation": "type Shape = { kind: 'circle' } | { kind: 'square' }",
      "meaning": "Discriminated union คืออะไร?",
      "example": "Discriminated unions (tagged unions) use a common literal property to distinguish between union members. TypeScript narrows the type based on the discriminant in switch/if statements. Enables exhaustiveness checking - compiler errors if cases are missing. Common pattern for Redux actions, API responses, state machines.",
      "exampleTranslation": "Discriminated unions (tagged unions) ใช้ common literal property เพื่อแยกแยะระหว่าง union members TypeScript narrows type ตาม discriminant ใน switch/if statements เปิดให้ exhaustiveness checking - compiler errors ถ้า cases ขาด Pattern ที่ใช้บ่อยสำหรับ Redux actions, API responses, state machines"
    },
    {
      "vocab": "What is index signature?",
      "pronunciation": "interface Dict { [key: string]: string }",
      "meaning": "Index signature คืออะไร?",
      "example": "Index signatures define types for dynamic property access: [key: KeyType]: ValueType. String keys for dictionaries, number keys for array-like objects. Known properties must have compatible types. Can be readonly. Template literal patterns allow more specific key patterns. Use Record<K,V> as alternative.",
      "exampleTranslation": "Index signatures กำหนด types สำหรับ dynamic property access: [key: KeyType]: ValueType String keys สำหรับ dictionaries, number keys สำหรับ array-like objects Known properties ต้องมี compatible types เป็น readonly ได้ Template literal patterns อนุญาต key patterns ที่เฉพาะเจาะจงกว่า ใช้ Record<K,V> เป็นทางเลือก"
    },
    {
      "vocab": "What is ReturnType and Parameters utility types?",
      "pronunciation": "ReturnType<typeof fn>, Parameters<typeof fn>",
      "meaning": "ReturnType และ Parameters utility types คืออะไร?",
      "example": "ReturnType<T> extracts the return type of function type T. Parameters<T> extracts parameter types as a tuple. Use 'typeof' to get function type from value. For async functions, combine with Awaited to unwrap Promise. ConstructorParameters works for class constructors. Essential for wrapper functions and typing.",
      "exampleTranslation": "ReturnType<T> ดึง return type ของ function type T Parameters<T> ดึง parameter types เป็น tuple ใช้ 'typeof' เพื่อดึง function type จากค่า สำหรับ async functions รวมกับ Awaited เพื่อ unwrap Promise ConstructorParameters ทำงานสำหรับ class constructors จำเป็นสำหรับ wrapper functions และ typing"
    },
    {
      "vocab": "What is Awaited utility type?",
      "pronunciation": "Awaited<Promise<T>> // T",
      "meaning": "Awaited utility type คืออะไร?",
      "example": "Awaited<T> recursively unwraps Promise types to get the resolved value type. Handles nested promises (Promise<Promise<T>> becomes T). Non-promise types pass through unchanged. Essential for typing async/await code and getting the resolved type of async functions.",
      "exampleTranslation": "Awaited<T> unwrap Promise types แบบ recursive เพื่อดึง resolved value type จัดการ nested promises (Promise<Promise<T>> กลายเป็น T) Non-promise types ผ่านโดยไม่เปลี่ยน จำเป็นสำหรับ typing async/await code และดึง resolved type ของ async functions"
    },
    {
      "vocab": "What are Exclude and Extract utility types?",
      "pronunciation": "Exclude<'a'|'b'|'c', 'a'> // 'b'|'c'",
      "meaning": "Exclude และ Extract utility types คืออะไร?",
      "example": "Exclude<T, U> removes types from T that are assignable to U. Extract<T, U> keeps only types from T that are assignable to U. Both work on union types distributively. Use for filtering union types, event types, object keys based on value types. Implemented using conditional types.",
      "exampleTranslation": "Exclude<T, U> ลบ types จาก T ที่ assignable กับ U Extract<T, U> เก็บเฉพาะ types จาก T ที่ assignable กับ U ทั้งคู่ทำงานบน union types แบบ distributive ใช้สำหรับ filter union types, event types, object keys ตาม value types Implement โดยใช้ conditional types"
    },
    {
      "vocab": "What is NonNullable utility type?",
      "pronunciation": "NonNullable<string | null> // string",
      "meaning": "NonNullable utility type คืออะไร?",
      "example": "NonNullable<T> removes null and undefined from type T. Useful for function parameters that require non-nullable values after validation. Works with strictNullChecks. Implementation uses conditional types to filter out null/undefined. Common in data processing after null checks.",
      "exampleTranslation": "NonNullable<T> ลบ null และ undefined จาก type T มีประโยชน์สำหรับ function parameters ที่ต้องการ non-nullable values หลัง validation ทำงานกับ strictNullChecks Implementation ใช้ conditional types เพื่อ filter null/undefined ออก ใช้บ่อยใน data processing หลัง null checks"
    },
    {
      "vocab": "What is object type vs Object vs {}?",
      "pronunciation": "object (non-primitive), Object (has methods), {} (any non-null)",
      "meaning": "object vs Object vs {} ต่างกันอย่างไร?",
      "example": "object (lowercase) is non-primitive types only (objects, arrays, functions). Object (capitalized) is all values except null/undefined. {} (empty object) is any non-nullish value. Prefer: Record<string, unknown> for typed objects, object for non-primitives. Avoid {} and Object as too permissive.",
      "exampleTranslation": "object (ตัวเล็ก) คือ non-primitive types เท่านั้น (objects, arrays, functions) Object (ตัวใหญ่) คือทุกค่ายกเว้น null/undefined {} (empty object) คือค่าใดก็ได้ที่ไม่ใช่ nullish ใช้: Record<string, unknown> สำหรับ typed objects, object สำหรับ non-primitives หลีกเลี่ยง {} และ Object เพราะ permissive เกินไป"
    },
    {
      "vocab": "What is type assertion (as)?",
      "pronunciation": "const input = element as HTMLInputElement;",
      "meaning": "Type assertion (as) คืออะไร?",
      "example": "Type assertions tell TypeScript to treat a value as a specific type. Use 'as Type' syntax. Only works for compatible types (use 'as unknown as Type' for incompatible). Non-null assertion (!) asserts value is not null/undefined. Prefer type guards over assertions when possible - assertions bypass type checking.",
      "exampleTranslation": "Type assertions บอก TypeScript ให้ treat ค่าเป็น specific type ใช้ syntax 'as Type' ทำงานสำหรับ compatible types เท่านั้น (ใช้ 'as unknown as Type' สำหรับ incompatible) Non-null assertion (!) assert ว่าค่าไม่ใช่ null/undefined ใช้ type guards แทน assertions เมื่อเป็นไปได้ - assertions bypass type checking"
    },
    {
      "vocab": "What is module augmentation?",
      "pronunciation": "declare module 'express' { interface Request { user?: User } }",
      "meaning": "Module augmentation คืออะไร?",
      "example": "Module augmentation extends existing module types using 'declare module'. Add properties to third-party library types (Express Request, etc). Use 'declare global' to extend global types like Window. Must be in a module file (has import/export). Essential for typing middleware, plugins, and global variables.",
      "exampleTranslation": "Module augmentation extend existing module types โดยใช้ 'declare module' เพิ่ม properties ให้ third-party library types (Express Request, etc) ใช้ 'declare global' เพื่อ extend global types เช่น Window ต้องอยู่ใน module file (มี import/export) จำเป็นสำหรับ typing middleware, plugins และ global variables"
    },
    {
      "vocab": "What is the difference between type and interface for functions?",
      "pronunciation": "type Fn = (x: string) => void vs interface Fn { (x: string): void }",
      "meaning": "type และ interface สำหรับ functions ต่างกันอย่างไร?",
      "example": "Both type and interface can define function types. Type uses arrow syntax: (params) => return. Interface uses call signature: { (params): return }. Interface allows adding properties to callable objects. Type uses intersection for the same. For simple function types, type alias is cleaner.",
      "exampleTranslation": "ทั้ง type และ interface กำหนด function types ได้ Type ใช้ arrow syntax: (params) => return Interface ใช้ call signature: { (params): return } Interface อนุญาตเพิ่ม properties ให้ callable objects Type ใช้ intersection สำหรับแบบเดียวกัน สำหรับ simple function types type alias สะอาดกว่า"
    },
    {
      "vocab": "What is variance in TypeScript?",
      "pronunciation": "covariance (output), contravariance (input), invariance",
      "meaning": "Variance ใน TypeScript คืออะไร?",
      "example": "Variance describes how type relationships work with generics. Covariance: subtypes allowed in output positions (return types). Contravariance: supertypes allowed in input positions (parameters). Invariance: exact type required. strictFunctionTypes enables proper contravariance for function parameters.",
      "exampleTranslation": "Variance อธิบายว่า type relationships ทำงานกับ generics อย่างไร Covariance: subtypes อนุญาตใน output positions (return types) Contravariance: supertypes อนุญาตใน input positions (parameters) Invariance: ต้องการ exact type strictFunctionTypes เปิดให้ contravariance ที่ถูกต้องสำหรับ function parameters"
    },
    {
      "vocab": "What are tuple types?",
      "pronunciation": "[string, number, boolean?]",
      "meaning": "Tuple types คืออะไร?",
      "example": "Tuples are fixed-length arrays with specific types at each position. Use for function returns with multiple values, coordinates, or structured data. Support optional elements (?), rest elements (...), and named elements for documentation. Readonly tuples prevent modification. Different from arrays which have uniform type.",
      "exampleTranslation": "Tuples คือ arrays ความยาวคงที่ที่มี specific types ในแต่ละตำแหน่ง ใช้สำหรับ function returns ที่มีหลายค่า coordinates หรือ structured data รองรับ optional elements (?) rest elements (...) และ named elements สำหรับ documentation Readonly tuples ป้องกันการแก้ไข ต่างจาก arrays ที่มี uniform type"
    },
    {
      "vocab": "What is ThisType utility type?",
      "pronunciation": "methods: M & ThisType<D & M>",
      "meaning": "ThisType utility type คืออะไร?",
      "example": "ThisType<T> is a marker interface that defines the type of 'this' within an object. Doesn't transform types but provides context for 'this'. Used in factory patterns where methods need to access other properties. Requires noImplicitThis flag. Common in Vue-like APIs and object builders.",
      "exampleTranslation": "ThisType<T> คือ marker interface ที่กำหนด type ของ 'this' ภายใน object ไม่ transform types แต่ให้ context สำหรับ 'this' ใช้ใน factory patterns ที่ methods ต้องเข้าถึง properties อื่น ต้องมี noImplicitThis flag ใช้บ่อยใน Vue-like APIs และ object builders"
    },
    {
      "vocab": "What is NoInfer utility type?",
      "pronunciation": "NoInfer<T> // block inference from this position",
      "meaning": "NoInfer utility type คืออะไร?",
      "example": "NoInfer<T> (TS 5.4+) blocks type inference from that position in generic functions. Forces TypeScript to infer the type from other arguments only. Useful when one parameter should validate against a type inferred elsewhere. Prevents unwanted type widening from certain arguments.",
      "exampleTranslation": "NoInfer<T> (TS 5.4+) block type inference จากตำแหน่งนั้นใน generic functions บังคับให้ TypeScript infer type จาก arguments อื่นเท่านั้น มีประโยชน์เมื่อ parameter หนึ่งควร validate กับ type ที่ infer จากที่อื่น ป้องกัน unwanted type widening จากบาง arguments"
    }
  ]
}
